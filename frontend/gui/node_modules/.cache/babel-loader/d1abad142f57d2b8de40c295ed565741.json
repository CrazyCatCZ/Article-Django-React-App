{"ast":null,"code":"import { __extends } from 'tslib';\n\nvar cleanInternalStack = function (stack) {\n  return stack.replace(/\\s+at .*aggregate-error\\/index.js:\\d+:\\d+\\)?/g, '');\n};\n/**\r\nEscape RegExp special characters.\r\nYou can also use this to escape a string that is inserted into the middle of a regex, for example, into a character class.\r\n@example\r\n```\r\nimport escapeStringRegexp = require('escape-string-regexp');\r\nconst escapedString = escapeStringRegexp('How much $ for a ðŸ¦„?');\r\n//=> 'How much \\\\$ for a ðŸ¦„\\\\?'\r\nnew RegExp(escapedString);\r\n```\r\n*/\n\n\nvar escapeStringRegexp = function (string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  } // Escape characters with special meaning either inside or outside character sets.\n  // Use a simple backslash escape when itâ€™s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patternsâ€™ stricter grammar.\n\n\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n};\n\nvar extractPathRegex = /\\s+at.*[(\\s](.*)\\)?/;\nvar pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:babel-polyfill|pirates)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/;\n/**\r\nClean up error stack traces. Removes the mostly unhelpful internal Node.js entries.\r\n@param stack - The `stack` property of an `Error`.\r\n@example\r\n```\r\nimport cleanStack = require('clean-stack');\r\nconst error = new Error('Missing unicorn');\r\nconsole.log(error.stack);\r\n// Error: Missing unicorn\r\n//     at Object.<anonymous> (/Users/sindresorhus/dev/clean-stack/unicorn.js:2:15)\r\n//     at Module._compile (module.js:409:26)\r\n//     at Object.Module._extensions..js (module.js:416:10)\r\n//     at Module.load (module.js:343:32)\r\n//     at Function.Module._load (module.js:300:12)\r\n//     at Function.Module.runMain (module.js:441:10)\r\n//     at startup (node.js:139:18)\r\nconsole.log(cleanStack(error.stack));\r\n// Error: Missing unicorn\r\n//     at Object.<anonymous> (/Users/sindresorhus/dev/clean-stack/unicorn.js:2:15)\r\n```\r\n*/\n\nvar cleanStack = function (stack, basePath) {\n  var basePathRegex = basePath && new RegExp(\"(at | \\\\()\" + escapeStringRegexp(basePath), 'g');\n  return stack.replace(/\\\\/g, '/').split('\\n').filter(function (line) {\n    var pathMatches = line.match(extractPathRegex);\n\n    if (pathMatches === null || !pathMatches[1]) {\n      return true;\n    }\n\n    var match = pathMatches[1]; // Electron\n\n    if (match.includes('.app/Contents/Resources/electron.asar') || match.includes('.app/Contents/Resources/default_app.asar')) {\n      return false;\n    }\n\n    return !pathRegex.test(match);\n  }).filter(function (line) {\n    return line.trim() !== '';\n  }).map(function (line) {\n    if (basePathRegex) {\n      line = line.replace(basePathRegex, '$1');\n    }\n\n    return line;\n  }).join('\\n');\n};\n/**\r\nIndent each line in a string.\r\n@param string - The string to indent.\r\n@param count - How many times you want `options.indent` repeated. Default: `1`.\r\n@example\r\n```\r\nimport indentString = require('indent-string');\r\nindentString('Unicorns\\nRainbows', 4);\r\n//=> '    Unicorns\\n    Rainbows'\r\nindentString('Unicorns\\nRainbows', 4, {indent: 'â™¥'});\r\n//=> 'â™¥â™¥â™¥â™¥Unicorns\\nâ™¥â™¥â™¥â™¥Rainbows'\r\n```\r\n*/\n\n\nvar indentString = function (string, count, options) {\n  if (count === void 0) {\n    count = 1;\n  }\n\n  options = Object.assign({\n    indent: ' ',\n    includeEmptyLines: false\n  }, options);\n\n  if (typeof string !== 'string') {\n    throw new TypeError(\"Expected `input` to be a `string`, got `\" + typeof string + \"`\");\n  }\n\n  if (typeof count !== 'number') {\n    throw new TypeError(\"Expected `count` to be a `number`, got `\" + typeof count + \"`\");\n  }\n\n  if (count < 0) {\n    throw new RangeError(\"Expected `count` to be at least 0, got `\" + count + \"`\");\n  }\n\n  if (typeof options.indent !== 'string') {\n    throw new TypeError(\"Expected `options.indent` to be a `string`, got `\" + typeof options.indent + \"`\");\n  }\n\n  if (count === 0) {\n    return string;\n  }\n\n  var regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n  return string.replace(regex, options.indent.repeat(count));\n};\n\nvar AggregateError =\n/** @class */\nfunction (_super) {\n  __extends(AggregateError, _super);\n\n  function AggregateError(errors) {\n    var _this = this;\n\n    if (!Array.isArray(errors)) {\n      throw new TypeError(\"Expected input to be an Array, got \" + typeof errors);\n    }\n\n    var normalizedErrors = errors.map(function (error) {\n      if (error instanceof Error) {\n        return error;\n      }\n\n      if (error !== null && typeof error === 'object') {\n        // Handle plain error objects with message property and/or possibly other metadata\n        return Object.assign(new Error(error.message), error);\n      }\n\n      return new Error(error);\n    });\n    var message = normalizedErrors.map(function (error) {\n      // The `stack` property is not standardized, so we can't assume it exists\n      return typeof error.stack === 'string' ? cleanInternalStack(cleanStack(error.stack)) : String(error);\n    }).join('\\n');\n    message = '\\n' + indentString(message, 4);\n    _this = _super.call(this, message) || this;\n    _this.name = 'AggregateError';\n    Object.defineProperty(_this, Symbol.iterator, {\n      get: function () {\n        return function () {\n          return normalizedErrors[Symbol.iterator]();\n        };\n      }\n    });\n    return _this;\n  }\n\n  return AggregateError;\n}(Error);\n\nexport default AggregateError;","map":{"version":3,"sources":["../src/cleanInternalStack.ts","../src/escapeStringRegexp.ts","../src/cleanStack.ts","../src/indentString.ts","../src/AggregateError.ts"],"names":[],"mappings":"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","sourcesContent":["export const cleanInternalStack = (stack: string): string => stack.replace(/\\s+at .*aggregate-error\\/index.js:\\d+:\\d+\\)?/g, '');\n\n","/**\nEscape RegExp special characters.\nYou can also use this to escape a string that is inserted into the middle of a regex, for example, into a character class.\n@example\n```\nimport escapeStringRegexp = require('escape-string-regexp');\nconst escapedString = escapeStringRegexp('How much $ for a ðŸ¦„?');\n//=> 'How much \\\\$ for a ðŸ¦„\\\\?'\nnew RegExp(escapedString);\n```\n*/\nexport const escapeStringRegexp = (string: string): string => {\n    if (typeof string !== 'string') {\n        throw new TypeError('Expected a string');\n    }\n    // Escape characters with special meaning either inside or outside character sets.\n    // Use a simple backslash escape when itâ€™s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patternsâ€™ stricter grammar.\n    return string\n        .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n        .replace(/-/g, '\\\\x2d');\n};\n\n","import { escapeStringRegexp } from \"./escapeStringRegexp\";\n\nconst extractPathRegex = /\\s+at.*[(\\s](.*)\\)?/;\nconst pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:babel-polyfill|pirates)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/;\n\n/**\nClean up error stack traces. Removes the mostly unhelpful internal Node.js entries.\n@param stack - The `stack` property of an `Error`.\n@example\n```\nimport cleanStack = require('clean-stack');\nconst error = new Error('Missing unicorn');\nconsole.log(error.stack);\n// Error: Missing unicorn\n//     at Object.<anonymous> (/Users/sindresorhus/dev/clean-stack/unicorn.js:2:15)\n//     at Module._compile (module.js:409:26)\n//     at Object.Module._extensions..js (module.js:416:10)\n//     at Module.load (module.js:343:32)\n//     at Function.Module._load (module.js:300:12)\n//     at Function.Module.runMain (module.js:441:10)\n//     at startup (node.js:139:18)\nconsole.log(cleanStack(error.stack));\n// Error: Missing unicorn\n//     at Object.<anonymous> (/Users/sindresorhus/dev/clean-stack/unicorn.js:2:15)\n```\n*/\nexport const cleanStack = (stack: string, basePath?: string): string => {\n    const basePathRegex = basePath && new RegExp(`(at | \\\\()${escapeStringRegexp(basePath)}`, 'g');\n    return stack.replace(/\\\\/g, '/')\n        .split('\\n')\n        .filter(line => {\n            const pathMatches = line.match(extractPathRegex);\n            if (pathMatches === null || !pathMatches[1]) {\n                return true;\n            }\n            const match = pathMatches[1];\n            // Electron\n            if (match.includes('.app/Contents/Resources/electron.asar') ||\n                match.includes('.app/Contents/Resources/default_app.asar')) {\n                return false;\n            }\n            return !pathRegex.test(match);\n        })\n        .filter(line => line.trim() !== '')\n        .map(line => {\n            if (basePathRegex) {\n                line = line.replace(basePathRegex, '$1');\n            }\n            return line;\n        })\n        .join('\\n');\n};\n","interface Options {\n    /**\n    The string to use for the indent.\n    @default ' '\n    */\n    readonly indent?: string;\n    /**\n    Also indent empty lines.\n    @default false\n    */\n    readonly includeEmptyLines?: boolean;\n}\n/**\nIndent each line in a string.\n@param string - The string to indent.\n@param count - How many times you want `options.indent` repeated. Default: `1`.\n@example\n```\nimport indentString = require('indent-string');\nindentString('Unicorns\\nRainbows', 4);\n//=> '    Unicorns\\n    Rainbows'\nindentString('Unicorns\\nRainbows', 4, {indent: 'â™¥'});\n//=> 'â™¥â™¥â™¥â™¥Unicorns\\nâ™¥â™¥â™¥â™¥Rainbows'\n```\n*/\nexport const indentString = (string: string, count = 1, options?: Options): string => {\n    options = Object.assign({\n        indent: ' ',\n        includeEmptyLines: false,\n    }, options);\n    if (typeof string !== 'string') {\n        throw new TypeError(`Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``);\n    }\n    if (typeof count !== 'number') {\n        throw new TypeError(`Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``);\n    }\n    if (count < 0) {\n        throw new RangeError(`Expected \\`count\\` to be at least 0, got \\`${count}\\``);\n    }\n    if (typeof options.indent !== 'string') {\n        throw new TypeError(`Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof options.indent}\\``);\n    }\n    if (count === 0) {\n        return string;\n    }\n    const regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n    return string.replace(regex, options.indent.repeat(count));\n};","import { cleanInternalStack } from \"./cleanInternalStack\";\nimport { cleanStack } from \"./cleanStack\";\nimport { indentString } from \"./indentString\";\n\nexport class AggregateError extends Error {\n    /**\n    @param errors - If a string, a new `Error` is created with the string as the error message. If a non-Error object, a new `Error` is created with all properties from the object copied over.\n    @returns An Error that is also an [`Iterable`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Iterables) for the individual errors.\n    @example\n    ```\n    import AggregateError = require('aggregate-error');\n    const error = new AggregateError([new Error('foo'), 'bar', {message: 'baz'}]);\n    throw error;\n    // AggregateError:\n    //\tError: foo\n    //\t\tat Object.<anonymous> (/Users/sindresorhus/dev/aggregate-error/example.js:3:33)\n    //\tError: bar\n    //\t\tat Object.<anonymous> (/Users/sindresorhus/dev/aggregate-error/example.js:3:13)\n    //\tError: baz\n    //\t\tat Object.<anonymous> (/Users/sindresorhus/dev/aggregate-error/example.js:3:13)\n    //\tat AggregateError (/Users/sindresorhus/dev/aggregate-error/index.js:19:3)\n    //\tat Object.<anonymous> (/Users/sindresorhus/dev/aggregate-error/example.js:3:13)\n    //\tat Module._compile (module.js:556:32)\n    //\tat Object.Module._extensions..js (module.js:565:10)\n    //\tat Module.load (module.js:473:32)\n    //\tat tryModuleLoad (module.js:432:12)\n    //\tat Function.Module._load (module.js:424:3)\n    //\tat Module.runMain (module.js:590:10)\n    //\tat run (bootstrap_node.js:394:7)\n    //\tat startup (bootstrap_node.js:149:9)\n    for (const individualError of error) {\n        console.log(individualError);\n    }\n    //=> [Error: foo]\n    //=> [Error: bar]\n    //=> [Error: baz]\n    ```\n    */\n    public [Symbol.iterator]: () => IterableIterator<Error>;\n    constructor(errors: ReadonlyArray<Error | {\n        [key: string]: any;\n    } | string>) {\n        if (!Array.isArray(errors)) {\n            throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);\n        }\n        const normalizedErrors: Error[] = errors.map(error => {\n            if (error instanceof Error) {\n                return error;\n            }\n            if (error !== null && typeof error === 'object') {\n                // Handle plain error objects with message property and/or possibly other metadata\n                return Object.assign(new Error(error.message), error);\n            }\n            return new Error(error);\n        });\n        let message = normalizedErrors\n            .map(error => {\n                // The `stack` property is not standardized, so we can't assume it exists\n                return typeof error.stack === 'string' ? cleanInternalStack(cleanStack(error.stack)) : String(error);\n            })\n            .join('\\n');\n        message = '\\n' + indentString(message, 4);\n        super(message);\n        this.name = 'AggregateError';\n        Object.defineProperty(this, Symbol.iterator, {\n            get: () => () => normalizedErrors[Symbol.iterator](),\n        })\n    }\n}\n"]},"metadata":{},"sourceType":"module"}