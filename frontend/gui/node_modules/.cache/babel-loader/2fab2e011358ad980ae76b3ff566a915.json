{"ast":null,"code":"import { Kind, print } from 'graphql';\nimport { observableToAsyncIterable } from '@graphql-tools/utils';\nimport { isWebUri } from 'valid-url';\nimport { fetch } from 'cross-fetch';\nimport { introspectSchema, wrapSchema } from '@graphql-tools/wrap';\nimport { SubscriptionClient } from 'subscriptions-transport-ws';\nimport { w3cwebsocket } from 'websocket';\n/* eslint-disable no-case-declarations */\n\n/**\n * This loader loads a schema from a URL. The loaded schema is a fully-executable,\n * remote schema since it's created using [@graphql-tools/wrap](/docs/remote-schemas).\n *\n * ```\n * const schema = await loadSchema('http://localhost:3000/graphql', {\n *   loaders: [\n *     new UrlLoader(),\n *   ]\n * });\n * ```\n */\n\nclass UrlLoader {\n  loaderId() {\n    return 'url';\n  }\n\n  async canLoad(pointer, options) {\n    return this.canLoadSync(pointer, options);\n  }\n\n  canLoadSync(pointer, _options) {\n    return !!isWebUri(pointer);\n  }\n\n  buildAsyncExecutor({\n    pointer,\n    fetch,\n    extraHeaders,\n    defaultMethod,\n    useGETForQueries\n  }) {\n    const HTTP_URL = switchProtocols(pointer, {\n      wss: 'https',\n      ws: 'http'\n    });\n    return async ({\n      document,\n      variables\n    }) => {\n      let method = defaultMethod;\n\n      if (useGETForQueries) {\n        method = 'GET';\n\n        for (const definition of document.definitions) {\n          if (definition.kind === Kind.OPERATION_DEFINITION) {\n            if (definition.operation !== 'query') {\n              method = defaultMethod;\n            }\n          }\n        }\n      }\n\n      let fetchResult;\n      const query = print(document);\n\n      switch (method) {\n        case 'GET':\n          const urlObj = new URL(HTTP_URL);\n          urlObj.searchParams.set('query', query);\n\n          if (variables && Object.keys(variables).length > 0) {\n            urlObj.searchParams.set('variables', JSON.stringify(variables));\n          }\n\n          const finalUrl = urlObj.toString();\n          fetchResult = await fetch(finalUrl, {\n            method: 'GET',\n            headers: extraHeaders\n          });\n          break;\n\n        case 'POST':\n          fetchResult = await fetch(HTTP_URL, {\n            method: 'POST',\n            body: JSON.stringify({\n              query,\n              variables\n            }),\n            headers: extraHeaders\n          });\n          break;\n      }\n\n      return fetchResult.json();\n    };\n  }\n\n  buildSubscriber(pointer, webSocketImpl) {\n    const WS_URL = switchProtocols(pointer, {\n      https: 'wss',\n      http: 'ws'\n    });\n    const subscriptionClient = new SubscriptionClient(WS_URL, {}, webSocketImpl);\n    return async ({\n      document,\n      variables\n    }) => {\n      return observableToAsyncIterable(subscriptionClient.request({\n        query: document,\n        variables\n      }));\n    };\n  }\n\n  async getExecutorAndSubscriber(pointer, options) {\n    let headers = {};\n    let fetch$1 = fetch;\n    let defaultMethod = 'POST';\n    let webSocketImpl = w3cwebsocket;\n\n    if (options) {\n      if (Array.isArray(options.headers)) {\n        headers = options.headers.reduce((prev, v) => ({ ...prev,\n          ...v\n        }), {});\n      } else if (typeof options.headers === 'object') {\n        headers = options.headers;\n      }\n\n      if (options.customFetch) {\n        if (typeof options.customFetch === 'string') {\n          const [moduleName, fetchFnName] = options.customFetch.split('#');\n          fetch$1 = await import(moduleName).then(module => fetchFnName ? module[fetchFnName] : module);\n        } else {\n          fetch$1 = options.customFetch;\n        }\n      }\n\n      if (options.webSocketImpl) {\n        if (typeof options.webSocketImpl === 'string') {\n          const [moduleName, webSocketImplName] = options.webSocketImpl.split('#');\n          webSocketImpl = await import(moduleName).then(module => webSocketImplName ? module[webSocketImplName] : module);\n        } else {\n          webSocketImpl = options.webSocketImpl;\n        }\n      }\n\n      if (options.method) {\n        defaultMethod = options.method;\n      }\n    }\n\n    const extraHeaders = {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      ...headers\n    };\n    const executor = this.buildAsyncExecutor({\n      pointer,\n      fetch: fetch$1,\n      extraHeaders,\n      defaultMethod,\n      useGETForQueries: options.useGETForQueries\n    });\n    let subscriber;\n\n    if (options.enableSubscriptions) {\n      subscriber = this.buildSubscriber(pointer, webSocketImpl);\n    }\n\n    return {\n      executor,\n      subscriber\n    };\n  }\n\n  async getSubschemaConfig(pointer, options) {\n    const {\n      executor,\n      subscriber\n    } = await this.getExecutorAndSubscriber(pointer, options);\n    return {\n      schema: await introspectSchema(executor, undefined, options),\n      executor,\n      subscriber\n    };\n  }\n\n  async load(pointer, options) {\n    const subschemaConfig = await this.getSubschemaConfig(pointer, options);\n    const remoteExecutableSchema = wrapSchema(subschemaConfig);\n    return {\n      location: pointer,\n      schema: remoteExecutableSchema\n    };\n  }\n\n  loadSync() {\n    throw new Error('Loader Url has no sync mode');\n  }\n\n}\n\nfunction switchProtocols(pointer, protocolMap) {\n  const protocols = Object.keys(protocolMap).map(source => [source, protocolMap[source]]);\n  return protocols.reduce((prev, [source, target]) => prev.replace(`${source}://`, `${target}://`).replace(`${source}:\\\\`, `${target}:\\\\`), pointer);\n}\n\nexport { UrlLoader };","map":{"version":3,"sources":["../../../dist/loaders/url/src/index.js"],"names":["fetch","crossFetch"],"mappings":"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","sourcesContent":["/* eslint-disable no-case-declarations */\nimport { print, Kind } from 'graphql';\nimport { observableToAsyncIterable, } from '@graphql-tools/utils';\nimport { isWebUri } from 'valid-url';\nimport { fetch as crossFetch } from 'cross-fetch';\nimport { introspectSchema, wrapSchema } from '@graphql-tools/wrap';\nimport { SubscriptionClient } from 'subscriptions-transport-ws';\nimport { w3cwebsocket } from 'websocket';\n/**\n * This loader loads a schema from a URL. The loaded schema is a fully-executable,\n * remote schema since it's created using [@graphql-tools/wrap](/docs/remote-schemas).\n *\n * ```\n * const schema = await loadSchema('http://localhost:3000/graphql', {\n *   loaders: [\n *     new UrlLoader(),\n *   ]\n * });\n * ```\n */\nexport class UrlLoader {\n    loaderId() {\n        return 'url';\n    }\n    async canLoad(pointer, options) {\n        return this.canLoadSync(pointer, options);\n    }\n    canLoadSync(pointer, _options) {\n        return !!isWebUri(pointer);\n    }\n    buildAsyncExecutor({ pointer, fetch, extraHeaders, defaultMethod, useGETForQueries, }) {\n        const HTTP_URL = switchProtocols(pointer, {\n            wss: 'https',\n            ws: 'http',\n        });\n        return async ({ document, variables }) => {\n            let method = defaultMethod;\n            if (useGETForQueries) {\n                method = 'GET';\n                for (const definition of document.definitions) {\n                    if (definition.kind === Kind.OPERATION_DEFINITION) {\n                        if (definition.operation !== 'query') {\n                            method = defaultMethod;\n                        }\n                    }\n                }\n            }\n            let fetchResult;\n            const query = print(document);\n            switch (method) {\n                case 'GET':\n                    const urlObj = new URL(HTTP_URL);\n                    urlObj.searchParams.set('query', query);\n                    if (variables && Object.keys(variables).length > 0) {\n                        urlObj.searchParams.set('variables', JSON.stringify(variables));\n                    }\n                    const finalUrl = urlObj.toString();\n                    fetchResult = await fetch(finalUrl, {\n                        method: 'GET',\n                        headers: extraHeaders,\n                    });\n                    break;\n                case 'POST':\n                    fetchResult = await fetch(HTTP_URL, {\n                        method: 'POST',\n                        body: JSON.stringify({\n                            query,\n                            variables,\n                        }),\n                        headers: extraHeaders,\n                    });\n                    break;\n            }\n            return fetchResult.json();\n        };\n    }\n    buildSubscriber(pointer, webSocketImpl) {\n        const WS_URL = switchProtocols(pointer, {\n            https: 'wss',\n            http: 'ws',\n        });\n        const subscriptionClient = new SubscriptionClient(WS_URL, {}, webSocketImpl);\n        return async ({ document, variables }) => {\n            return observableToAsyncIterable(subscriptionClient.request({\n                query: document,\n                variables,\n            }));\n        };\n    }\n    async getExecutorAndSubscriber(pointer, options) {\n        let headers = {};\n        let fetch = crossFetch;\n        let defaultMethod = 'POST';\n        let webSocketImpl = w3cwebsocket;\n        if (options) {\n            if (Array.isArray(options.headers)) {\n                headers = options.headers.reduce((prev, v) => ({ ...prev, ...v }), {});\n            }\n            else if (typeof options.headers === 'object') {\n                headers = options.headers;\n            }\n            if (options.customFetch) {\n                if (typeof options.customFetch === 'string') {\n                    const [moduleName, fetchFnName] = options.customFetch.split('#');\n                    fetch = await import(moduleName).then(module => (fetchFnName ? module[fetchFnName] : module));\n                }\n                else {\n                    fetch = options.customFetch;\n                }\n            }\n            if (options.webSocketImpl) {\n                if (typeof options.webSocketImpl === 'string') {\n                    const [moduleName, webSocketImplName] = options.webSocketImpl.split('#');\n                    webSocketImpl = await import(moduleName).then(module => webSocketImplName ? module[webSocketImplName] : module);\n                }\n                else {\n                    webSocketImpl = options.webSocketImpl;\n                }\n            }\n            if (options.method) {\n                defaultMethod = options.method;\n            }\n        }\n        const extraHeaders = {\n            Accept: 'application/json',\n            'Content-Type': 'application/json',\n            ...headers,\n        };\n        const executor = this.buildAsyncExecutor({\n            pointer,\n            fetch,\n            extraHeaders,\n            defaultMethod,\n            useGETForQueries: options.useGETForQueries,\n        });\n        let subscriber;\n        if (options.enableSubscriptions) {\n            subscriber = this.buildSubscriber(pointer, webSocketImpl);\n        }\n        return {\n            executor,\n            subscriber,\n        };\n    }\n    async getSubschemaConfig(pointer, options) {\n        const { executor, subscriber } = await this.getExecutorAndSubscriber(pointer, options);\n        return {\n            schema: await introspectSchema(executor, undefined, options),\n            executor,\n            subscriber,\n        };\n    }\n    async load(pointer, options) {\n        const subschemaConfig = await this.getSubschemaConfig(pointer, options);\n        const remoteExecutableSchema = wrapSchema(subschemaConfig);\n        return {\n            location: pointer,\n            schema: remoteExecutableSchema,\n        };\n    }\n    loadSync() {\n        throw new Error('Loader Url has no sync mode');\n    }\n}\nfunction switchProtocols(pointer, protocolMap) {\n    const protocols = Object.keys(protocolMap).map(source => [source, protocolMap[source]]);\n    return protocols.reduce((prev, [source, target]) => prev.replace(`${source}://`, `${target}://`).replace(`${source}:\\\\`, `${target}:\\\\`), pointer);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}