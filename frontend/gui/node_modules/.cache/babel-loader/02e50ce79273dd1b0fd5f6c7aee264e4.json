{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar IRTransformer = require('../core/IRTransformer');\n\nvar IMap = require('immutable').Map;\n\nvar partitionArray = require('../util/partitionArray');\n\nvar getIdentifierForSelection = require('../core/getIdentifierForSelection');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\n * A transform that removes redundant fields and fragment spreads. Redundancy is\n * defined in this context as any selection that is guaranteed to already be\n * fetched by an ancestor selection. This can occur in two cases:\n *\n * 1. Simple duplicates at the same level of the document can always be skipped:\n *\n * ```\n * fragment Foo on FooType {\n *   id\n *   id\n *   ...Bar\n *   ...Bar\n * }\n * ```\n *\n * Becomes\n *\n * ```\n * fragment Foo on FooType {\n *   id\n *   ...Bar\n * }\n * ```\n *\n * 2. Inline fragments and conditions introduce the possibility for duplication\n * at different levels of the tree. Whenever a selection is fetched in a parent,\n * it is redundant to also fetch it in a child:\n *\n * ```\n * fragment Foo on FooType {\n *   id\n *   ... on OtherType {\n *     id # 1\n *   }\n *   ... on FooType @include(if: $cond) {\n *     id # 2\n *   }\n * }\n * ```\n *\n * Becomes:\n *\n * ```\n * fragment Foo on FooType {\n *   id\n * }\n * ```\n *\n * In this example:\n * - 1 can be skipped because `id` is already fetched by the parent. Even\n *   though the type is different (FooType/OtherType), the inline fragment\n *   cannot match without the outer fragment matching so the outer `id` is\n *   guaranteed to already be fetched.\n * - 2 can be skipped for similar reasons: it doesn't matter if the condition\n *   holds, `id` is already fetched by the parent regardless.\n *\n * This transform also handles more complicated cases in which selections are\n * nested:\n *\n * ```\n * fragment Foo on FooType {\n *   a {\n *     bb\n *   }\n *   ... on OtherType {\n *     a {\n *       bb # 1\n *       cc\n *     }\n *   }\n *  }\n * ```\n *\n * Becomes\n *\n * ```\n * fragment Foo on FooType {\n *   a {\n *     bb\n *   }\n *   ... on OtherType {\n *     a {\n *       cc\n *     }\n *   }\n *  }\n * ```\n *\n * 1 can be skipped because it is already fetched at the outer level.\n */\n\n\nfunction skipRedundantNodesTransform(context) {\n  return IRTransformer.transform(context, {\n    Root: visitNode,\n    SplitOperation: visitNode,\n    Fragment: visitNode\n  });\n}\n\nvar cache = new Map();\n\nfunction visitNode(node) {\n  cache = new Map();\n  var context = this.getContext();\n  return transformNode(context.getSchema(), node, new IMap()).node;\n}\n/**\n * The most straightforward approach would be two passes: one to record the\n * structure of the document, one to prune duplicates. This implementation uses\n * a single pass. Selections are sorted with fields first, \"conditionals\"\n * (inline fragments & conditions) last. This means that all fields that are\n * guaranteed to be fetched are encountered prior to any duplicates that may be\n * fetched within a conditional.\n *\n * Because selections fetched within a conditional are not guaranteed to be\n * fetched in the parent, a fork of the selection map is created when entering a\n * conditional. The sort ensures that guaranteed fields have already been seen\n * prior to the clone.\n */\n\n\nfunction transformNode(schema, node, selectionMap) {\n  // This will optimize a traversal of the same subselections.\n  // If it's the same node, and selectionMap is empty\n  // result of transformNode has to be the same.\n  var isEmptySelectionMap = selectionMap.size === 0;\n  var result;\n\n  if (isEmptySelectionMap) {\n    result = cache.get(node);\n\n    if (result != null) {\n      return result;\n    }\n  }\n\n  var selections = [];\n  sortSelections(node.selections).forEach(function (selection) {\n    var identifier = getIdentifierForSelection(schema, selection);\n\n    switch (selection.kind) {\n      case 'ScalarField':\n      case 'FragmentSpread':\n        {\n          if (!selectionMap.has(identifier)) {\n            selections.push(selection);\n            selectionMap = selectionMap.set(identifier, null);\n          }\n\n          break;\n        }\n\n      case 'Defer':\n      case 'Stream':\n      case 'ModuleImport':\n      case 'ClientExtension':\n      case 'InlineDataFragmentSpread':\n      case 'LinkedField':\n        {\n          var transformed = transformNode(schema, selection, selectionMap.get(identifier) || new IMap());\n\n          if (transformed.node) {\n            selections.push(transformed.node);\n            selectionMap = selectionMap.set(identifier, transformed.selectionMap);\n          }\n\n          break;\n        }\n\n      case 'InlineFragment':\n      case 'Condition':\n        {\n          // Fork the selection map to prevent conditional selections from\n          // affecting the outer \"guaranteed\" selections.\n          var _transformed = transformNode(schema, selection, selectionMap.get(identifier) || selectionMap);\n\n          if (_transformed.node) {\n            selections.push(_transformed.node);\n            selectionMap = selectionMap.set(identifier, _transformed.selectionMap);\n          }\n\n          break;\n        }\n\n      default:\n        selection;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'SkipRedundantNodesTransform: Unexpected node kind `%s`.', selection.kind) : invariant(false) : void 0;\n    }\n  });\n  var nextNode = selections.length ? _objectSpread({}, node, {\n    selections: selections\n  }) : null;\n  result = {\n    selectionMap: selectionMap,\n    node: nextNode\n  };\n\n  if (isEmptySelectionMap) {\n    cache.set(node, result);\n  }\n\n  return result;\n}\n/**\n * Sort inline fragments and conditions after other selections.\n */\n\n\nfunction sortSelections(selections) {\n  var isScalarOrLinkedField = function isScalarOrLinkedField(selection) {\n    return selection.kind === 'ScalarField' || selection.kind === 'LinkedField';\n  };\n\n  var _partitionArray = partitionArray(selections, isScalarOrLinkedField),\n      scalarsAndLinkedFields = _partitionArray[0],\n      rest = _partitionArray[1];\n\n  return [].concat((0, _toConsumableArray2[\"default\"])(scalarsAndLinkedFields), (0, _toConsumableArray2[\"default\"])(rest));\n}\n\nmodule.exports = {\n  transform: skipRedundantNodesTransform\n};","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/relay-compiler/lib/transforms/SkipRedundantNodesTransform.js"],"names":["_interopRequireDefault","require","_defineProperty2","_toConsumableArray2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","IRTransformer","IMap","Map","partitionArray","getIdentifierForSelection","invariant","skipRedundantNodesTransform","context","transform","Root","visitNode","SplitOperation","Fragment","cache","node","getContext","transformNode","getSchema","schema","selectionMap","isEmptySelectionMap","size","result","get","selections","sortSelections","selection","identifier","kind","has","set","transformed","_transformed","process","env","NODE_ENV","nextNode","isScalarOrLinkedField","_partitionArray","scalarsAndLinkedFields","rest","concat","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar IRTransformer = require('../core/IRTransformer');\n\nvar IMap = require('immutable').Map;\n\nvar partitionArray = require('../util/partitionArray');\n\nvar getIdentifierForSelection = require('../core/getIdentifierForSelection');\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\n/**\n * A transform that removes redundant fields and fragment spreads. Redundancy is\n * defined in this context as any selection that is guaranteed to already be\n * fetched by an ancestor selection. This can occur in two cases:\n *\n * 1. Simple duplicates at the same level of the document can always be skipped:\n *\n * ```\n * fragment Foo on FooType {\n *   id\n *   id\n *   ...Bar\n *   ...Bar\n * }\n * ```\n *\n * Becomes\n *\n * ```\n * fragment Foo on FooType {\n *   id\n *   ...Bar\n * }\n * ```\n *\n * 2. Inline fragments and conditions introduce the possibility for duplication\n * at different levels of the tree. Whenever a selection is fetched in a parent,\n * it is redundant to also fetch it in a child:\n *\n * ```\n * fragment Foo on FooType {\n *   id\n *   ... on OtherType {\n *     id # 1\n *   }\n *   ... on FooType @include(if: $cond) {\n *     id # 2\n *   }\n * }\n * ```\n *\n * Becomes:\n *\n * ```\n * fragment Foo on FooType {\n *   id\n * }\n * ```\n *\n * In this example:\n * - 1 can be skipped because `id` is already fetched by the parent. Even\n *   though the type is different (FooType/OtherType), the inline fragment\n *   cannot match without the outer fragment matching so the outer `id` is\n *   guaranteed to already be fetched.\n * - 2 can be skipped for similar reasons: it doesn't matter if the condition\n *   holds, `id` is already fetched by the parent regardless.\n *\n * This transform also handles more complicated cases in which selections are\n * nested:\n *\n * ```\n * fragment Foo on FooType {\n *   a {\n *     bb\n *   }\n *   ... on OtherType {\n *     a {\n *       bb # 1\n *       cc\n *     }\n *   }\n *  }\n * ```\n *\n * Becomes\n *\n * ```\n * fragment Foo on FooType {\n *   a {\n *     bb\n *   }\n *   ... on OtherType {\n *     a {\n *       cc\n *     }\n *   }\n *  }\n * ```\n *\n * 1 can be skipped because it is already fetched at the outer level.\n */\nfunction skipRedundantNodesTransform(context) {\n  return IRTransformer.transform(context, {\n    Root: visitNode,\n    SplitOperation: visitNode,\n    Fragment: visitNode\n  });\n}\n\nvar cache = new Map();\n\nfunction visitNode(node) {\n  cache = new Map();\n  var context = this.getContext();\n  return transformNode(context.getSchema(), node, new IMap()).node;\n}\n/**\n * The most straightforward approach would be two passes: one to record the\n * structure of the document, one to prune duplicates. This implementation uses\n * a single pass. Selections are sorted with fields first, \"conditionals\"\n * (inline fragments & conditions) last. This means that all fields that are\n * guaranteed to be fetched are encountered prior to any duplicates that may be\n * fetched within a conditional.\n *\n * Because selections fetched within a conditional are not guaranteed to be\n * fetched in the parent, a fork of the selection map is created when entering a\n * conditional. The sort ensures that guaranteed fields have already been seen\n * prior to the clone.\n */\n\n\nfunction transformNode(schema, node, selectionMap) {\n  // This will optimize a traversal of the same subselections.\n  // If it's the same node, and selectionMap is empty\n  // result of transformNode has to be the same.\n  var isEmptySelectionMap = selectionMap.size === 0;\n  var result;\n\n  if (isEmptySelectionMap) {\n    result = cache.get(node);\n\n    if (result != null) {\n      return result;\n    }\n  }\n\n  var selections = [];\n  sortSelections(node.selections).forEach(function (selection) {\n    var identifier = getIdentifierForSelection(schema, selection);\n\n    switch (selection.kind) {\n      case 'ScalarField':\n      case 'FragmentSpread':\n        {\n          if (!selectionMap.has(identifier)) {\n            selections.push(selection);\n            selectionMap = selectionMap.set(identifier, null);\n          }\n\n          break;\n        }\n\n      case 'Defer':\n      case 'Stream':\n      case 'ModuleImport':\n      case 'ClientExtension':\n      case 'InlineDataFragmentSpread':\n      case 'LinkedField':\n        {\n          var transformed = transformNode(schema, selection, selectionMap.get(identifier) || new IMap());\n\n          if (transformed.node) {\n            selections.push(transformed.node);\n            selectionMap = selectionMap.set(identifier, transformed.selectionMap);\n          }\n\n          break;\n        }\n\n      case 'InlineFragment':\n      case 'Condition':\n        {\n          // Fork the selection map to prevent conditional selections from\n          // affecting the outer \"guaranteed\" selections.\n          var _transformed = transformNode(schema, selection, selectionMap.get(identifier) || selectionMap);\n\n          if (_transformed.node) {\n            selections.push(_transformed.node);\n            selectionMap = selectionMap.set(identifier, _transformed.selectionMap);\n          }\n\n          break;\n        }\n\n      default:\n        selection;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'SkipRedundantNodesTransform: Unexpected node kind `%s`.', selection.kind) : invariant(false) : void 0;\n    }\n  });\n  var nextNode = selections.length ? _objectSpread({}, node, {\n    selections: selections\n  }) : null;\n  result = {\n    selectionMap: selectionMap,\n    node: nextNode\n  };\n\n  if (isEmptySelectionMap) {\n    cache.set(node, result);\n  }\n\n  return result;\n}\n/**\n * Sort inline fragments and conditions after other selections.\n */\n\n\nfunction sortSelections(selections) {\n  var isScalarOrLinkedField = function isScalarOrLinkedField(selection) {\n    return selection.kind === 'ScalarField' || selection.kind === 'LinkedField';\n  };\n\n  var _partitionArray = partitionArray(selections, isScalarOrLinkedField),\n      scalarsAndLinkedFields = _partitionArray[0],\n      rest = _partitionArray[1];\n\n  return [].concat((0, _toConsumableArray2[\"default\"])(scalarsAndLinkedFields), (0, _toConsumableArray2[\"default\"])(rest));\n}\n\nmodule.exports = {\n  transform: skipRedundantNodesTransform\n};"]},"metadata":{},"sourceType":"script"}