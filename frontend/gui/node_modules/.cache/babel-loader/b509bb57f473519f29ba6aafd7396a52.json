{"ast":null,"code":"import { defaultFieldResolver, isScalarType, getNamedType, Kind, print, buildASTSchema, extendSchema, isAbstractType, isSchema, isSpecifiedScalarType, isEnumType, isUnionType, isObjectType, isInterfaceType, GraphQLEnumType, GraphQLScalarType, GraphQLUnionType, GraphQLObjectType, GraphQLInterfaceType } from 'graphql';\nimport { mapSchema, MapperKind, forEachField, getDirectives, parseGraphQLSDL, forEachDefaultValue, serializeInputValue, healSchema, parseInputValue, mergeDeep, SchemaDirectiveVisitor, pruneSchema } from '@graphql-tools/utils'; // wraps all resolvers of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolver\n\nfunction addSchemaLevelResolver(schema, fn) {\n  // TODO test that schema is a schema, fn is a function\n  const fnToRunOnlyOnce = runAtMostOncePerRequest(fn);\n  return mapSchema(schema, {\n    [MapperKind.ROOT_FIELD]: (fieldConfig, _fieldName, typeName, schema) => {\n      // XXX this should run at most once per request to simulate a true root resolver\n      // for graphql-js this is an approximation that works with queries but not mutations\n      // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n      // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n      const subscription = schema.getSubscriptionType();\n\n      if (subscription != null && subscription.name === typeName) {\n        return { ...fieldConfig,\n          resolve: wrapResolver(fieldConfig.resolve, fn)\n        };\n      }\n\n      return { ...fieldConfig,\n        resolve: wrapResolver(fieldConfig.resolve, fnToRunOnlyOnce)\n      };\n    }\n  });\n} // XXX badly named function. this doesn't really wrap, it just chains resolvers...\n\n\nfunction wrapResolver(innerResolver, outerResolver) {\n  return (obj, args, ctx, info) => resolveMaybePromise(outerResolver(obj, args, ctx, info), root => {\n    if (innerResolver != null) {\n      return innerResolver(root, args, ctx, info);\n    }\n\n    return defaultFieldResolver(root, args, ctx, info);\n  });\n}\n\nfunction isPromise(maybePromise) {\n  return maybePromise && typeof maybePromise.then === 'function';\n} // resolvers can be synchronous or asynchronous. if all resolvers\n// in an operation return synchronously, the execution should return\n// synchronously. the maybe-sync/maybe-async nature of resolvers should be\n// preserved\n\n\nfunction resolveMaybePromise(maybePromise, fulfillmentCallback) {\n  if (isPromise(maybePromise)) {\n    return maybePromise.then(fulfillmentCallback);\n  }\n\n  return fulfillmentCallback(maybePromise);\n} // XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\n\n\nfunction runAtMostOncePerRequest(fn) {\n  let value;\n  const randomNumber = Math.random();\n  return (root, args, ctx, info) => {\n    if (!info.operation['__runAtMostOnce']) {\n      info.operation['__runAtMostOnce'] = {};\n    }\n\n    if (!info.operation['__runAtMostOnce'][randomNumber]) {\n      info.operation['__runAtMostOnce'][randomNumber] = true;\n      value = fn(root, args, ctx, info);\n    }\n\n    return value;\n  };\n}\n\nfunction assertResolversPresent(schema, resolverValidationOptions = {}) {\n  const {\n    requireResolversForArgs = false,\n    requireResolversForNonScalar = false,\n    requireResolversForAllFields = false\n  } = resolverValidationOptions;\n\n  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n    throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' + 'Please configure either requireResolversForAllFields or requireResolversForArgs / ' + 'requireResolversForNonScalar, but not a combination of them.');\n  }\n\n  forEachField(schema, (field, typeName, fieldName) => {\n    // requires a resolver for *every* field.\n    if (requireResolversForAllFields) {\n      expectResolver(field, typeName, fieldName);\n    } // requires a resolver on every field that has arguments\n\n\n    if (requireResolversForArgs && field.args.length > 0) {\n      expectResolver(field, typeName, fieldName);\n    } // requires a resolver on every field that returns a non-scalar type\n\n\n    if (requireResolversForNonScalar && !isScalarType(getNamedType(field.type))) {\n      expectResolver(field, typeName, fieldName);\n    }\n  });\n}\n\nfunction expectResolver(field, typeName, fieldName) {\n  if (!field.resolve) {\n    // eslint-disable-next-line no-console\n    console.warn(`Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this warning check pass;\nresolverValidationOptions: {\n  requireResolversForNonScalar: false\n}\n      `);\n    return;\n  }\n\n  if (typeof field.resolve !== 'function') {\n    throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n  }\n}\n\nfunction attachDirectiveResolvers(schema, directiveResolvers) {\n  if (typeof directiveResolvers !== 'object') {\n    throw new Error(`Expected directiveResolvers to be of type object, got ${typeof directiveResolvers}`);\n  }\n\n  if (Array.isArray(directiveResolvers)) {\n    throw new Error('Expected directiveResolvers to be of type object, got Array');\n  }\n\n  return mapSchema(schema, {\n    [MapperKind.OBJECT_FIELD]: fieldConfig => {\n      const newFieldConfig = { ...fieldConfig\n      };\n      const directives = getDirectives(schema, fieldConfig);\n      Object.keys(directives).forEach(directiveName => {\n        if (directiveResolvers[directiveName]) {\n          const resolver = directiveResolvers[directiveName];\n          const originalResolver = newFieldConfig.resolve != null ? newFieldConfig.resolve : defaultFieldResolver;\n          const directiveArgs = directives[directiveName];\n\n          newFieldConfig.resolve = (source, originalArgs, context, info) => {\n            return resolver(() => new Promise((resolve, reject) => {\n              const result = originalResolver(source, originalArgs, context, info);\n\n              if (result instanceof Error) {\n                reject(result);\n              }\n\n              resolve(result);\n            }), source, directiveArgs, context, info);\n          };\n        }\n      });\n      return newFieldConfig;\n    }\n  });\n}\n\nfunction extractExtensionDefinitions(ast) {\n  const extensionDefs = ast.definitions.filter(def => def.kind === Kind.OBJECT_TYPE_EXTENSION || def.kind === Kind.INTERFACE_TYPE_EXTENSION || def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION || def.kind === Kind.UNION_TYPE_EXTENSION || def.kind === Kind.ENUM_TYPE_EXTENSION || def.kind === Kind.SCALAR_TYPE_EXTENSION || def.kind === Kind.SCHEMA_EXTENSION);\n  return { ...ast,\n    definitions: extensionDefs\n  };\n}\n\nfunction filterExtensionDefinitions(ast) {\n  const extensionDefs = ast.definitions.filter(def => def.kind !== Kind.OBJECT_TYPE_EXTENSION && def.kind !== Kind.INTERFACE_TYPE_EXTENSION && def.kind !== Kind.INPUT_OBJECT_TYPE_EXTENSION && def.kind !== Kind.UNION_TYPE_EXTENSION && def.kind !== Kind.ENUM_TYPE_EXTENSION && def.kind !== Kind.SCALAR_TYPE_EXTENSION && def.kind !== Kind.SCHEMA_EXTENSION);\n  return { ...ast,\n    definitions: extensionDefs\n  };\n}\n\nfunction concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs = []) {\n  let resolvedTypeDefinitions = [];\n  typeDefinitionsAry.forEach(typeDef => {\n    if (typeof typeDef === 'function') {\n      if (calledFunctionRefs.indexOf(typeDef) === -1) {\n        calledFunctionRefs.push(typeDef);\n        resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));\n      }\n    } else if (typeof typeDef === 'string') {\n      resolvedTypeDefinitions.push(typeDef.trim());\n    } else if (typeDef.kind !== undefined) {\n      resolvedTypeDefinitions.push(print(typeDef).trim());\n    } else {\n      const type = typeof typeDef;\n      throw new Error(`typeDef array must contain only strings, documents, or functions, got ${type}`);\n    }\n  });\n  return uniq(resolvedTypeDefinitions.map(x => x.trim())).join('\\n');\n}\n\nfunction uniq(array) {\n  return array.reduce((accumulator, currentValue) => accumulator.indexOf(currentValue) === -1 ? [...accumulator, currentValue] : accumulator, []);\n}\n\nfunction buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {\n  const document = buildDocumentFromTypeDefinitions(typeDefinitions, parseOptions);\n  const typesAst = filterExtensionDefinitions(document);\n  const backcompatOptions = {\n    commentDescriptions: true\n  };\n  let schema = buildASTSchema(typesAst, backcompatOptions);\n  const extensionsAst = extractExtensionDefinitions(document);\n\n  if (extensionsAst.definitions.length > 0) {\n    schema = extendSchema(schema, extensionsAst, backcompatOptions);\n  }\n\n  return schema;\n}\n\nfunction isDocumentNode(typeDefinitions) {\n  return typeDefinitions.kind !== undefined;\n}\n\nfunction buildDocumentFromTypeDefinitions(typeDefinitions, parseOptions) {\n  let document;\n\n  if (typeof typeDefinitions === 'string') {\n    document = parseGraphQLSDL('', typeDefinitions, parseOptions).document;\n  } else if (Array.isArray(typeDefinitions)) {\n    document = parseGraphQLSDL('', concatenateTypeDefs(typeDefinitions), parseOptions).document;\n  } else if (isDocumentNode(typeDefinitions)) {\n    document = typeDefinitions;\n  } else {\n    const type = typeof typeDefinitions;\n    throw new Error(`typeDefs must be a string, array or schema AST, got ${type}`);\n  }\n\n  return document;\n}\n\nfunction chainResolvers(resolvers) {\n  return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {\n    if (curResolver != null) {\n      return curResolver(prev, args, ctx, info);\n    }\n\n    return defaultFieldResolver(prev, args, ctx, info);\n  }, root);\n}\n/*\n * fn: The function to decorate with the logger\n * logger: an object instance of type Logger\n * hint: an optional hint to add to the error's message\n */\n\n\nfunction decorateWithLogger(fn, logger, hint) {\n  const resolver = fn != null ? fn : defaultFieldResolver;\n\n  const logError = e => {\n    // TODO: clone the error properly\n    const newE = new Error();\n    newE.stack = e.stack;\n    /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n\n    if (hint) {\n      newE['originalMessage'] = e.message;\n      newE.message = `Error in resolver ${hint}\\n${e.message}`;\n    }\n\n    logger.log(newE);\n  };\n\n  return (root, args, ctx, info) => {\n    try {\n      const result = resolver(root, args, ctx, info); // If the resolver returns a Promise log any Promise rejects.\n\n      if (result && typeof result.then === 'function' && typeof result.catch === 'function') {\n        result.catch(reason => {\n          // make sure that it's an error we're logging.\n          const error = reason instanceof Error ? reason : new Error(reason);\n          logError(error); // We don't want to leave an unhandled exception so pass on error.\n\n          return reason;\n        });\n      }\n\n      return result;\n    } catch (e) {\n      logError(e); // we want to pass on the error, just in case.\n\n      throw e;\n    }\n  };\n} // If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers\n\n\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n  Object.keys(schema.getTypeMap()).map(typeName => schema.getType(typeName)).forEach(type => {\n    if (!isAbstractType(type)) {\n      return;\n    }\n\n    if (!type.resolveType) {\n      if (!requireResolversForResolveType) {\n        return;\n      }\n\n      throw new Error(`Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass false into ` + '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.');\n    }\n  });\n}\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\n  const typeNames = Object.keys({ ...schema.getTypeMap(),\n    ...resolvers\n  });\n  const extendedResolvers = {};\n  typeNames.forEach(typeName => {\n    const type = schema.getType(typeName);\n\n    if ('getInterfaces' in type) {\n      const allInterfaceResolvers = type.getInterfaces().map(iFace => resolvers[iFace.name]).filter(interfaceResolvers => interfaceResolvers != null);\n      extendedResolvers[typeName] = {};\n      allInterfaceResolvers.forEach(interfaceResolvers => {\n        Object.keys(interfaceResolvers).forEach(fieldName => {\n          if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n            extendedResolvers[typeName][fieldName] = interfaceResolvers[fieldName];\n          }\n        });\n      });\n      const typeResolvers = resolvers[typeName];\n      extendedResolvers[typeName] = { ...extendedResolvers[typeName],\n        ...typeResolvers\n      };\n    } else {\n      const typeResolvers = resolvers[typeName];\n\n      if (typeResolvers != null) {\n        extendedResolvers[typeName] = typeResolvers;\n      }\n    }\n  });\n  return extendedResolvers;\n}\n\nfunction addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n  const options = isSchema(schemaOrOptions) ? {\n    schema: schemaOrOptions,\n    resolvers: legacyInputResolvers,\n    resolverValidationOptions: legacyInputValidationOptions\n  } : schemaOrOptions;\n  let {\n    schema,\n    resolvers: inputResolvers,\n    defaultFieldResolver,\n    resolverValidationOptions = {},\n    inheritResolversFromInterfaces = false,\n    updateResolversInPlace = false\n  } = options;\n  const {\n    allowResolversNotInSchema = false,\n    requireResolversForResolveType\n  } = resolverValidationOptions;\n  const resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;\n  Object.keys(resolvers).forEach(typeName => {\n    const resolverValue = resolvers[typeName];\n    const resolverType = typeof resolverValue;\n\n    if (typeName === '__schema') {\n      if (resolverType !== 'function') {\n        throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". A schema resolver's value must be of type object or function.`);\n      }\n    } else {\n      if (resolverType !== 'object') {\n        throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n      }\n\n      const type = schema.getType(typeName);\n\n      if (type == null) {\n        if (allowResolversNotInSchema) {\n          return;\n        }\n\n        throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n      } else if (isSpecifiedScalarType(type)) {\n        // allow -- without recommending -- overriding of specified scalar types\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            type[fieldName.substring(2)] = resolverValue[fieldName];\n          } else {\n            type[fieldName] = resolverValue[fieldName];\n          }\n        });\n      } else if (isEnumType(type)) {\n        const values = type.getValues();\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (!fieldName.startsWith('__') && !values.some(value => value.name === fieldName) && !allowResolversNotInSchema) {\n            throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n          }\n        });\n      } else if (isUnionType(type)) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (!fieldName.startsWith('__') && !allowResolversNotInSchema) {\n            throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n          }\n        });\n      } else if (isObjectType(type) || isInterfaceType(type)) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (!fieldName.startsWith('__')) {\n            const fields = type.getFields();\n            const field = fields[fieldName];\n\n            if (field == null && !allowResolversNotInSchema) {\n              throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n            }\n\n            const fieldResolve = resolverValue[fieldName];\n\n            if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n              throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n            }\n          }\n        });\n      }\n    }\n  });\n  schema = updateResolversInPlace ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n  checkForResolveTypeResolver(schema, requireResolversForResolveType);\n  return schema;\n}\n\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n  const typeMap = schema.getTypeMap();\n  Object.keys(resolvers).forEach(typeName => {\n    if (typeName !== '__schema') {\n      const type = schema.getType(typeName);\n      const resolverValue = resolvers[typeName];\n\n      if (isScalarType(type)) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n\n          if (fieldName.startsWith('__')) {\n            type[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && type.astNode != null) {\n            type.astNode = { ...type.astNode,\n              description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.astNode.description,\n              directives: ((_d = type.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n            type.extensionASTNodes = ((_h = []) !== null && _h !== void 0 ? _h : type.extensionASTNodes).concat((_k = (_j = resolverValue) === null || _j === void 0 ? void 0 : _j.extensionASTNodes) !== null && _k !== void 0 ? _k : []);\n          } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {\n            type.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n          } else {\n            type[fieldName] = resolverValue[fieldName];\n          }\n        });\n      } else if (isEnumType(type)) {\n        const config = type.toConfig();\n        const enumValueConfigMap = config.values;\n        Object.keys(resolverValue).forEach(fieldName => {\n          var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = { ...config.astNode,\n              description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n              directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n          } else if (fieldName === 'extensions' && type.extensions != null && resolverValue.extensions != null) {\n            type.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n          } else if (enumValueConfigMap[fieldName]) {\n            enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n          }\n        });\n        typeMap[typeName] = new GraphQLEnumType(config);\n      } else if (isUnionType(type)) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            type[fieldName.substring(2)] = resolverValue[fieldName];\n          }\n        });\n      } else if (isObjectType(type) || isInterfaceType(type)) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            // this is for isTypeOf and resolveType and all the other stuff.\n            type[fieldName.substring(2)] = resolverValue[fieldName];\n            return;\n          }\n\n          const fields = type.getFields();\n          const field = fields[fieldName];\n\n          if (field != null) {\n            const fieldResolve = resolverValue[fieldName];\n\n            if (typeof fieldResolve === 'function') {\n              // for convenience. Allows shorter syntax in resolver definition file\n              field.resolve = fieldResolve;\n            } else {\n              setFieldProperties(field, fieldResolve);\n            }\n          }\n        });\n      }\n    }\n  }); // serialize all default values prior to healing fields with new scalar/enum types.\n\n  forEachDefaultValue(schema, serializeInputValue); // schema may have new scalar/enum types that require healing\n\n  healSchema(schema); // reparse all default values with new parsing functions.\n\n  forEachDefaultValue(schema, parseInputValue);\n\n  if (defaultFieldResolver != null) {\n    forEachField(schema, field => {\n      if (!field.resolve) {\n        field.resolve = defaultFieldResolver;\n      }\n    });\n  }\n\n  return schema;\n}\n\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n  schema = mapSchema(schema, {\n    [MapperKind.SCALAR_TYPE]: type => {\n      const config = type.toConfig();\n      const resolverValue = resolvers[type.name];\n\n      if (!isSpecifiedScalarType(type) && resolverValue != null) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = { ...config.astNode,\n              description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n              directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n          } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {\n            config.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n          } else {\n            config[fieldName] = resolverValue[fieldName];\n          }\n        });\n        return new GraphQLScalarType(config);\n      }\n    },\n    [MapperKind.ENUM_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n      const config = type.toConfig();\n      const enumValueConfigMap = config.values;\n\n      if (resolverValue != null) {\n        Object.keys(resolverValue).forEach(fieldName => {\n          var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          } else if (fieldName === 'astNode' && config.astNode != null) {\n            config.astNode = { ...config.astNode,\n              description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n              directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : [])\n            };\n          } else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n          } else if (fieldName === 'extensions' && config.extensions != null && resolverValue.extensions != null) {\n            config.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n          } else if (enumValueConfigMap[fieldName]) {\n            enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n          }\n        });\n        return new GraphQLEnumType(config);\n      }\n    },\n    [MapperKind.UNION_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          }\n        });\n        return new GraphQLUnionType(config);\n      }\n    },\n    [MapperKind.OBJECT_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          }\n        });\n        return new GraphQLObjectType(config);\n      }\n    },\n    [MapperKind.INTERFACE_TYPE]: type => {\n      const resolverValue = resolvers[type.name];\n\n      if (resolverValue != null) {\n        const config = type.toConfig();\n        Object.keys(resolverValue).forEach(fieldName => {\n          if (fieldName.startsWith('__')) {\n            config[fieldName.substring(2)] = resolverValue[fieldName];\n          }\n        });\n        return new GraphQLInterfaceType(config);\n      }\n    },\n    [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n      const resolverValue = resolvers[typeName];\n\n      if (resolverValue != null) {\n        const fieldResolve = resolverValue[fieldName];\n\n        if (fieldResolve != null) {\n          const newFieldConfig = { ...fieldConfig\n          };\n\n          if (typeof fieldResolve === 'function') {\n            // for convenience. Allows shorter syntax in resolver definition file\n            newFieldConfig.resolve = fieldResolve;\n          } else {\n            setFieldProperties(newFieldConfig, fieldResolve);\n          }\n\n          return newFieldConfig;\n        }\n      }\n    }\n  });\n\n  if (defaultFieldResolver != null) {\n    schema = mapSchema(schema, {\n      [MapperKind.OBJECT_FIELD]: fieldConfig => ({ ...fieldConfig,\n        resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver\n      })\n    });\n  }\n\n  return schema;\n}\n\nfunction setFieldProperties(field, propertiesObj) {\n  Object.keys(propertiesObj).forEach(propertyName => {\n    field[propertyName] = propertiesObj[propertyName];\n  });\n}\n\nfunction addErrorLoggingToSchema(schema, logger) {\n  if (!logger) {\n    throw new Error('Must provide a logger');\n  }\n\n  if (typeof logger.log !== 'function') {\n    throw new Error('Logger.log must be a function');\n  }\n\n  return mapSchema(schema, {\n    [MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName) => ({ ...fieldConfig,\n      resolve: decorateWithLogger(fieldConfig.resolve, logger, `${typeName}.${fieldName}`)\n    })\n  });\n}\n\nfunction decorateToCatchUndefined(fn, hint) {\n  const resolve = fn == null ? defaultFieldResolver : fn;\n  return (root, args, ctx, info) => {\n    const result = resolve(root, args, ctx, info);\n\n    if (typeof result === 'undefined') {\n      throw new Error(`Resolver for \"${hint}\" returned undefined`);\n    }\n\n    return result;\n  };\n}\n\nfunction addCatchUndefinedToSchema(schema) {\n  return mapSchema(schema, {\n    [MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName) => ({ ...fieldConfig,\n      resolve: decorateToCatchUndefined(fieldConfig.resolve, `${typeName}.${fieldName}`)\n    })\n  });\n}\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additinal syntax hightlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\n\n\nfunction makeExecutableSchema({\n  typeDefs,\n  resolvers = {},\n  logger,\n  allowUndefinedInResolve = true,\n  resolverValidationOptions = {},\n  directiveResolvers,\n  schemaDirectives,\n  schemaTransforms = [],\n  parseOptions = {},\n  inheritResolversFromInterfaces = false,\n  pruningOptions\n}) {\n  // Validate and clean up arguments\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new Error('Expected `resolverValidationOptions` to be an object');\n  }\n\n  if (!typeDefs) {\n    throw new Error('Must provide typeDefs');\n  } // We allow passing in an array of resolver maps, in which case we merge them\n\n\n  const resolverMap = Array.isArray(resolvers) ? resolvers.reduce(mergeDeep, {}) : resolvers; // Arguments are now validated and cleaned up\n\n  let schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\n  schema = addResolversToSchema({\n    schema,\n    resolvers: resolverMap,\n    resolverValidationOptions,\n    inheritResolversFromInterfaces\n  });\n  assertResolversPresent(schema, resolverValidationOptions);\n\n  if (!allowUndefinedInResolve) {\n    schema = addCatchUndefinedToSchema(schema);\n  }\n\n  if (logger != null) {\n    schema = addErrorLoggingToSchema(schema, logger);\n  }\n\n  if (typeof resolvers['__schema'] === 'function') {\n    // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n    // not doing that now, because I'd have to rewrite a lot of tests.\n    schema = addSchemaLevelResolver(schema, resolvers['__schema']);\n  }\n\n  schemaTransforms.forEach(schemaTransform => {\n    schema = schemaTransform(schema);\n  }); // directive resolvers are implemented using SchemaDirectiveVisitor.visitSchemaDirectives\n  // schema visiting modifies the schema in place\n\n  if (directiveResolvers != null) {\n    schema = attachDirectiveResolvers(schema, directiveResolvers);\n  }\n\n  if (schemaDirectives != null) {\n    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n  }\n\n  return pruningOptions ? pruneSchema(schema, pruningOptions) : schema;\n}\n\nexport { addCatchUndefinedToSchema, addErrorLoggingToSchema, addResolversToSchema, addSchemaLevelResolver, assertResolversPresent, attachDirectiveResolvers, buildDocumentFromTypeDefinitions, buildSchemaFromTypeDefinitions, chainResolvers, checkForResolveTypeResolver, concatenateTypeDefs, decorateWithLogger, extendResolversFromInterfaces, extractExtensionDefinitions, filterExtensionDefinitions, makeExecutableSchema };","map":{"version":3,"sources":["../../../dist/schema/src/addSchemaLevelResolver.js","../../../dist/schema/src/assertResolversPresent.js","../../../dist/schema/src/attachDirectiveResolvers.js","../../../dist/schema/src/extensionDefinitions.js","../../../dist/schema/src/concatenateTypeDefs.js","../../../dist/schema/src/buildSchemaFromTypeDefinitions.js","../../../dist/schema/src/chainResolvers.js","../../../dist/schema/src/decorateWithLogger.js","../../../dist/schema/src/checkForResolveTypeResolver.js","../../../dist/schema/src/extendResolversFromInterfaces.js","../../../dist/schema/src/addResolversToSchema.js","../../../dist/schema/src/addErrorLoggingToSchema.js","../../../dist/schema/src/addCatchUndefinedToSchema.js","../../../dist/schema/src/makeExecutableSchema.js"],"names":[],"mappings":"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","sourcesContent":["import { defaultFieldResolver } from 'graphql';\nimport { mapSchema, MapperKind } from '@graphql-tools/utils';\n// wraps all resolvers of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolver\nexport function addSchemaLevelResolver(schema, fn) {\n    // TODO test that schema is a schema, fn is a function\n    const fnToRunOnlyOnce = runAtMostOncePerRequest(fn);\n    return mapSchema(schema, {\n        [MapperKind.ROOT_FIELD]: (fieldConfig, _fieldName, typeName, schema) => {\n            // XXX this should run at most once per request to simulate a true root resolver\n            // for graphql-js this is an approximation that works with queries but not mutations\n            // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n            // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n            const subscription = schema.getSubscriptionType();\n            if (subscription != null && subscription.name === typeName) {\n                return {\n                    ...fieldConfig,\n                    resolve: wrapResolver(fieldConfig.resolve, fn),\n                };\n            }\n            return {\n                ...fieldConfig,\n                resolve: wrapResolver(fieldConfig.resolve, fnToRunOnlyOnce),\n            };\n        },\n    });\n}\n// XXX badly named function. this doesn't really wrap, it just chains resolvers...\nfunction wrapResolver(innerResolver, outerResolver) {\n    return (obj, args, ctx, info) => resolveMaybePromise(outerResolver(obj, args, ctx, info), root => {\n        if (innerResolver != null) {\n            return innerResolver(root, args, ctx, info);\n        }\n        return defaultFieldResolver(root, args, ctx, info);\n    });\n}\nfunction isPromise(maybePromise) {\n    return maybePromise && typeof maybePromise.then === 'function';\n}\n// resolvers can be synchronous or asynchronous. if all resolvers\n// in an operation return synchronously, the execution should return\n// synchronously. the maybe-sync/maybe-async nature of resolvers should be\n// preserved\nfunction resolveMaybePromise(maybePromise, fulfillmentCallback) {\n    if (isPromise(maybePromise)) {\n        return maybePromise.then(fulfillmentCallback);\n    }\n    return fulfillmentCallback(maybePromise);\n}\n// XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\nfunction runAtMostOncePerRequest(fn) {\n    let value;\n    const randomNumber = Math.random();\n    return (root, args, ctx, info) => {\n        if (!info.operation['__runAtMostOnce']) {\n            info.operation['__runAtMostOnce'] = {};\n        }\n        if (!info.operation['__runAtMostOnce'][randomNumber]) {\n            info.operation['__runAtMostOnce'][randomNumber] = true;\n            value = fn(root, args, ctx, info);\n        }\n        return value;\n    };\n}\n//# sourceMappingURL=addSchemaLevelResolver.js.map","import { getNamedType, isScalarType } from 'graphql';\nimport { forEachField } from '@graphql-tools/utils';\nexport function assertResolversPresent(schema, resolverValidationOptions = {}) {\n    const { requireResolversForArgs = false, requireResolversForNonScalar = false, requireResolversForAllFields = false, } = resolverValidationOptions;\n    if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n        throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' +\n            'Please configure either requireResolversForAllFields or requireResolversForArgs / ' +\n            'requireResolversForNonScalar, but not a combination of them.');\n    }\n    forEachField(schema, (field, typeName, fieldName) => {\n        // requires a resolver for *every* field.\n        if (requireResolversForAllFields) {\n            expectResolver(field, typeName, fieldName);\n        }\n        // requires a resolver on every field that has arguments\n        if (requireResolversForArgs && field.args.length > 0) {\n            expectResolver(field, typeName, fieldName);\n        }\n        // requires a resolver on every field that returns a non-scalar type\n        if (requireResolversForNonScalar && !isScalarType(getNamedType(field.type))) {\n            expectResolver(field, typeName, fieldName);\n        }\n    });\n}\nfunction expectResolver(field, typeName, fieldName) {\n    if (!field.resolve) {\n        // eslint-disable-next-line no-console\n        console.warn(`Resolver missing for \"${typeName}.${fieldName}\".\nTo disable this warning check pass;\nresolverValidationOptions: {\n  requireResolversForNonScalar: false\n}\n      `);\n        return;\n    }\n    if (typeof field.resolve !== 'function') {\n        throw new Error(`Resolver \"${typeName}.${fieldName}\" must be a function`);\n    }\n}\n//# sourceMappingURL=assertResolversPresent.js.map","import { defaultFieldResolver } from 'graphql';\nimport { mapSchema, MapperKind, getDirectives } from '@graphql-tools/utils';\nexport function attachDirectiveResolvers(schema, directiveResolvers) {\n    if (typeof directiveResolvers !== 'object') {\n        throw new Error(`Expected directiveResolvers to be of type object, got ${typeof directiveResolvers}`);\n    }\n    if (Array.isArray(directiveResolvers)) {\n        throw new Error('Expected directiveResolvers to be of type object, got Array');\n    }\n    return mapSchema(schema, {\n        [MapperKind.OBJECT_FIELD]: fieldConfig => {\n            const newFieldConfig = { ...fieldConfig };\n            const directives = getDirectives(schema, fieldConfig);\n            Object.keys(directives).forEach(directiveName => {\n                if (directiveResolvers[directiveName]) {\n                    const resolver = directiveResolvers[directiveName];\n                    const originalResolver = newFieldConfig.resolve != null ? newFieldConfig.resolve : defaultFieldResolver;\n                    const directiveArgs = directives[directiveName];\n                    newFieldConfig.resolve = (source, originalArgs, context, info) => {\n                        return resolver(() => new Promise((resolve, reject) => {\n                            const result = originalResolver(source, originalArgs, context, info);\n                            if (result instanceof Error) {\n                                reject(result);\n                            }\n                            resolve(result);\n                        }), source, directiveArgs, context, info);\n                    };\n                }\n            });\n            return newFieldConfig;\n        },\n    });\n}\n//# sourceMappingURL=attachDirectiveResolvers.js.map","import { Kind } from 'graphql';\nexport function extractExtensionDefinitions(ast) {\n    const extensionDefs = ast.definitions.filter((def) => def.kind === Kind.OBJECT_TYPE_EXTENSION ||\n        def.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n        def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION ||\n        def.kind === Kind.UNION_TYPE_EXTENSION ||\n        def.kind === Kind.ENUM_TYPE_EXTENSION ||\n        def.kind === Kind.SCALAR_TYPE_EXTENSION ||\n        def.kind === Kind.SCHEMA_EXTENSION);\n    return {\n        ...ast,\n        definitions: extensionDefs,\n    };\n}\nexport function filterExtensionDefinitions(ast) {\n    const extensionDefs = ast.definitions.filter((def) => def.kind !== Kind.OBJECT_TYPE_EXTENSION &&\n        def.kind !== Kind.INTERFACE_TYPE_EXTENSION &&\n        def.kind !== Kind.INPUT_OBJECT_TYPE_EXTENSION &&\n        def.kind !== Kind.UNION_TYPE_EXTENSION &&\n        def.kind !== Kind.ENUM_TYPE_EXTENSION &&\n        def.kind !== Kind.SCALAR_TYPE_EXTENSION &&\n        def.kind !== Kind.SCHEMA_EXTENSION);\n    return {\n        ...ast,\n        definitions: extensionDefs,\n    };\n}\n//# sourceMappingURL=extensionDefinitions.js.map","import { print } from 'graphql';\nexport function concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs = []) {\n    let resolvedTypeDefinitions = [];\n    typeDefinitionsAry.forEach((typeDef) => {\n        if (typeof typeDef === 'function') {\n            if (calledFunctionRefs.indexOf(typeDef) === -1) {\n                calledFunctionRefs.push(typeDef);\n                resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));\n            }\n        }\n        else if (typeof typeDef === 'string') {\n            resolvedTypeDefinitions.push(typeDef.trim());\n        }\n        else if (typeDef.kind !== undefined) {\n            resolvedTypeDefinitions.push(print(typeDef).trim());\n        }\n        else {\n            const type = typeof typeDef;\n            throw new Error(`typeDef array must contain only strings, documents, or functions, got ${type}`);\n        }\n    });\n    return uniq(resolvedTypeDefinitions.map(x => x.trim())).join('\\n');\n}\nfunction uniq(array) {\n    return array.reduce((accumulator, currentValue) => accumulator.indexOf(currentValue) === -1 ? [...accumulator, currentValue] : accumulator, []);\n}\n//# sourceMappingURL=concatenateTypeDefs.js.map","import { extendSchema, buildASTSchema } from 'graphql';\nimport { parseGraphQLSDL } from '@graphql-tools/utils';\nimport { extractExtensionDefinitions, filterExtensionDefinitions } from './extensionDefinitions';\nimport { concatenateTypeDefs } from './concatenateTypeDefs';\nexport function buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {\n    const document = buildDocumentFromTypeDefinitions(typeDefinitions, parseOptions);\n    const typesAst = filterExtensionDefinitions(document);\n    const backcompatOptions = { commentDescriptions: true };\n    let schema = buildASTSchema(typesAst, backcompatOptions);\n    const extensionsAst = extractExtensionDefinitions(document);\n    if (extensionsAst.definitions.length > 0) {\n        schema = extendSchema(schema, extensionsAst, backcompatOptions);\n    }\n    return schema;\n}\nexport function isDocumentNode(typeDefinitions) {\n    return typeDefinitions.kind !== undefined;\n}\nexport function buildDocumentFromTypeDefinitions(typeDefinitions, parseOptions) {\n    let document;\n    if (typeof typeDefinitions === 'string') {\n        document = parseGraphQLSDL('', typeDefinitions, parseOptions).document;\n    }\n    else if (Array.isArray(typeDefinitions)) {\n        document = parseGraphQLSDL('', concatenateTypeDefs(typeDefinitions), parseOptions).document;\n    }\n    else if (isDocumentNode(typeDefinitions)) {\n        document = typeDefinitions;\n    }\n    else {\n        const type = typeof typeDefinitions;\n        throw new Error(`typeDefs must be a string, array or schema AST, got ${type}`);\n    }\n    return document;\n}\n//# sourceMappingURL=buildSchemaFromTypeDefinitions.js.map","import { defaultFieldResolver } from 'graphql';\nexport function chainResolvers(resolvers) {\n    return (root, args, ctx, info) => resolvers.reduce((prev, curResolver) => {\n        if (curResolver != null) {\n            return curResolver(prev, args, ctx, info);\n        }\n        return defaultFieldResolver(prev, args, ctx, info);\n    }, root);\n}\n//# sourceMappingURL=chainResolvers.js.map","import { defaultFieldResolver } from 'graphql';\n/*\n * fn: The function to decorate with the logger\n * logger: an object instance of type Logger\n * hint: an optional hint to add to the error's message\n */\nexport function decorateWithLogger(fn, logger, hint) {\n    const resolver = fn != null ? fn : defaultFieldResolver;\n    const logError = (e) => {\n        // TODO: clone the error properly\n        const newE = new Error();\n        newE.stack = e.stack;\n        /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n        if (hint) {\n            newE['originalMessage'] = e.message;\n            newE.message = `Error in resolver ${hint}\\n${e.message}`;\n        }\n        logger.log(newE);\n    };\n    return (root, args, ctx, info) => {\n        try {\n            const result = resolver(root, args, ctx, info);\n            // If the resolver returns a Promise log any Promise rejects.\n            if (result && typeof result.then === 'function' && typeof result.catch === 'function') {\n                result.catch((reason) => {\n                    // make sure that it's an error we're logging.\n                    const error = reason instanceof Error ? reason : new Error(reason);\n                    logError(error);\n                    // We don't want to leave an unhandled exception so pass on error.\n                    return reason;\n                });\n            }\n            return result;\n        }\n        catch (e) {\n            logError(e);\n            // we want to pass on the error, just in case.\n            throw e;\n        }\n    };\n}\n//# sourceMappingURL=decorateWithLogger.js.map","import { isAbstractType } from 'graphql';\n// If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers\nexport function checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n    Object.keys(schema.getTypeMap())\n        .map(typeName => schema.getType(typeName))\n        .forEach((type) => {\n        if (!isAbstractType(type)) {\n            return;\n        }\n        if (!type.resolveType) {\n            if (!requireResolversForResolveType) {\n                return;\n            }\n            throw new Error(`Type \"${type.name}\" is missing a \"__resolveType\" resolver. Pass false into ` +\n                '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.');\n        }\n    });\n}\n//# sourceMappingURL=checkForResolveTypeResolver.js.map","export function extendResolversFromInterfaces(schema, resolvers) {\n    const typeNames = Object.keys({\n        ...schema.getTypeMap(),\n        ...resolvers,\n    });\n    const extendedResolvers = {};\n    typeNames.forEach(typeName => {\n        const type = schema.getType(typeName);\n        if ('getInterfaces' in type) {\n            const allInterfaceResolvers = type\n                .getInterfaces()\n                .map(iFace => resolvers[iFace.name])\n                .filter(interfaceResolvers => interfaceResolvers != null);\n            extendedResolvers[typeName] = {};\n            allInterfaceResolvers.forEach(interfaceResolvers => {\n                Object.keys(interfaceResolvers).forEach(fieldName => {\n                    if (fieldName === '__isTypeOf' || !fieldName.startsWith('__')) {\n                        extendedResolvers[typeName][fieldName] = interfaceResolvers[fieldName];\n                    }\n                });\n            });\n            const typeResolvers = resolvers[typeName];\n            extendedResolvers[typeName] = {\n                ...extendedResolvers[typeName],\n                ...typeResolvers,\n            };\n        }\n        else {\n            const typeResolvers = resolvers[typeName];\n            if (typeResolvers != null) {\n                extendedResolvers[typeName] = typeResolvers;\n            }\n        }\n    });\n    return extendedResolvers;\n}\n//# sourceMappingURL=extendResolversFromInterfaces.js.map","import { GraphQLEnumType, isSchema, GraphQLScalarType, GraphQLUnionType, GraphQLInterfaceType, GraphQLObjectType, isSpecifiedScalarType, isScalarType, isEnumType, isUnionType, isInterfaceType, isObjectType, } from 'graphql';\nimport { mapSchema, MapperKind, forEachDefaultValue, serializeInputValue, healSchema, parseInputValue, forEachField, } from '@graphql-tools/utils';\nimport { checkForResolveTypeResolver } from './checkForResolveTypeResolver';\nimport { extendResolversFromInterfaces } from './extendResolversFromInterfaces';\nexport function addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n    const options = isSchema(schemaOrOptions)\n        ? {\n            schema: schemaOrOptions,\n            resolvers: legacyInputResolvers,\n            resolverValidationOptions: legacyInputValidationOptions,\n        }\n        : schemaOrOptions;\n    let { schema, resolvers: inputResolvers, defaultFieldResolver, resolverValidationOptions = {}, inheritResolversFromInterfaces = false, updateResolversInPlace = false, } = options;\n    const { allowResolversNotInSchema = false, requireResolversForResolveType } = resolverValidationOptions;\n    const resolvers = inheritResolversFromInterfaces\n        ? extendResolversFromInterfaces(schema, inputResolvers)\n        : inputResolvers;\n    Object.keys(resolvers).forEach(typeName => {\n        const resolverValue = resolvers[typeName];\n        const resolverType = typeof resolverValue;\n        if (typeName === '__schema') {\n            if (resolverType !== 'function') {\n                throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". A schema resolver's value must be of type object or function.`);\n            }\n        }\n        else {\n            if (resolverType !== 'object') {\n                throw new Error(`\"${typeName}\" defined in resolvers, but has invalid value \"${resolverValue}\". The resolver's value must be of type object.`);\n            }\n            const type = schema.getType(typeName);\n            if (type == null) {\n                if (allowResolversNotInSchema) {\n                    return;\n                }\n                throw new Error(`\"${typeName}\" defined in resolvers, but not in schema`);\n            }\n            else if (isSpecifiedScalarType(type)) {\n                // allow -- without recommending -- overriding of specified scalar types\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        type[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else {\n                        type[fieldName] = resolverValue[fieldName];\n                    }\n                });\n            }\n            else if (isEnumType(type)) {\n                const values = type.getValues();\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (!fieldName.startsWith('__') &&\n                        !values.some(value => value.name === fieldName) &&\n                        !allowResolversNotInSchema) {\n                        throw new Error(`${type.name}.${fieldName} was defined in resolvers, but not present within ${type.name}`);\n                    }\n                });\n            }\n            else if (isUnionType(type)) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (!fieldName.startsWith('__') && !allowResolversNotInSchema) {\n                        throw new Error(`${type.name}.${fieldName} was defined in resolvers, but ${type.name} is not an object or interface type`);\n                    }\n                });\n            }\n            else if (isObjectType(type) || isInterfaceType(type)) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (!fieldName.startsWith('__')) {\n                        const fields = type.getFields();\n                        const field = fields[fieldName];\n                        if (field == null && !allowResolversNotInSchema) {\n                            throw new Error(`${typeName}.${fieldName} defined in resolvers, but not in schema`);\n                        }\n                        const fieldResolve = resolverValue[fieldName];\n                        if (typeof fieldResolve !== 'function' && typeof fieldResolve !== 'object') {\n                            throw new Error(`Resolver ${typeName}.${fieldName} must be object or function`);\n                        }\n                    }\n                });\n            }\n        }\n    });\n    schema = updateResolversInPlace\n        ? addResolversToExistingSchema(schema, resolvers, defaultFieldResolver)\n        : createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver);\n    checkForResolveTypeResolver(schema, requireResolversForResolveType);\n    return schema;\n}\nfunction addResolversToExistingSchema(schema, resolvers, defaultFieldResolver) {\n    const typeMap = schema.getTypeMap();\n    Object.keys(resolvers).forEach(typeName => {\n        if (typeName !== '__schema') {\n            const type = schema.getType(typeName);\n            const resolverValue = resolvers[typeName];\n            if (isScalarType(type)) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n                    if (fieldName.startsWith('__')) {\n                        type[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && type.astNode != null) {\n                        type.astNode = {\n                            ...type.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : type.astNode.description,\n                            directives: ((_d = type.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && type.extensionASTNodes != null) {\n                        type.extensionASTNodes = ((_h = []) !== null && _h !== void 0 ? _h : type.extensionASTNodes).concat((_k = (_j = resolverValue) === null || _j === void 0 ? void 0 : _j.extensionASTNodes) !== null && _k !== void 0 ? _k : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        type.extensions != null &&\n                        resolverValue.extensions != null) {\n                        type.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n                    }\n                    else {\n                        type[fieldName] = resolverValue[fieldName];\n                    }\n                });\n            }\n            else if (isEnumType(type)) {\n                const config = type.toConfig();\n                const enumValueConfigMap = config.values;\n                Object.keys(resolverValue).forEach(fieldName => {\n                    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n                            directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        type.extensions != null &&\n                        resolverValue.extensions != null) {\n                        type.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n                    }\n                    else if (enumValueConfigMap[fieldName]) {\n                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                    }\n                });\n                typeMap[typeName] = new GraphQLEnumType(config);\n            }\n            else if (isUnionType(type)) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        type[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                });\n            }\n            else if (isObjectType(type) || isInterfaceType(type)) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        // this is for isTypeOf and resolveType and all the other stuff.\n                        type[fieldName.substring(2)] = resolverValue[fieldName];\n                        return;\n                    }\n                    const fields = type.getFields();\n                    const field = fields[fieldName];\n                    if (field != null) {\n                        const fieldResolve = resolverValue[fieldName];\n                        if (typeof fieldResolve === 'function') {\n                            // for convenience. Allows shorter syntax in resolver definition file\n                            field.resolve = fieldResolve;\n                        }\n                        else {\n                            setFieldProperties(field, fieldResolve);\n                        }\n                    }\n                });\n            }\n        }\n    });\n    // serialize all default values prior to healing fields with new scalar/enum types.\n    forEachDefaultValue(schema, serializeInputValue);\n    // schema may have new scalar/enum types that require healing\n    healSchema(schema);\n    // reparse all default values with new parsing functions.\n    forEachDefaultValue(schema, parseInputValue);\n    if (defaultFieldResolver != null) {\n        forEachField(schema, field => {\n            if (!field.resolve) {\n                field.resolve = defaultFieldResolver;\n            }\n        });\n    }\n    return schema;\n}\nfunction createNewSchemaWithResolvers(schema, resolvers, defaultFieldResolver) {\n    schema = mapSchema(schema, {\n        [MapperKind.SCALAR_TYPE]: type => {\n            const config = type.toConfig();\n            const resolverValue = resolvers[type.name];\n            if (!isSpecifiedScalarType(type) && resolverValue != null) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n                            directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n                    }\n                    else {\n                        config[fieldName] = resolverValue[fieldName];\n                    }\n                });\n                return new GraphQLScalarType(config);\n            }\n        },\n        [MapperKind.ENUM_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            const config = type.toConfig();\n            const enumValueConfigMap = config.values;\n            if (resolverValue != null) {\n                Object.keys(resolverValue).forEach(fieldName => {\n                    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                    else if (fieldName === 'astNode' && config.astNode != null) {\n                        config.astNode = {\n                            ...config.astNode,\n                            description: (_c = (_b = (_a = resolverValue) === null || _a === void 0 ? void 0 : _a.astNode) === null || _b === void 0 ? void 0 : _b.description) !== null && _c !== void 0 ? _c : config.astNode.description,\n                            directives: ((_d = config.astNode.directives) !== null && _d !== void 0 ? _d : []).concat((_g = (_f = (_e = resolverValue) === null || _e === void 0 ? void 0 : _e.astNode) === null || _f === void 0 ? void 0 : _f.directives) !== null && _g !== void 0 ? _g : []),\n                        };\n                    }\n                    else if (fieldName === 'extensionASTNodes' && config.extensionASTNodes != null) {\n                        config.extensionASTNodes = config.extensionASTNodes.concat((_j = (_h = resolverValue) === null || _h === void 0 ? void 0 : _h.extensionASTNodes) !== null && _j !== void 0 ? _j : []);\n                    }\n                    else if (fieldName === 'extensions' &&\n                        config.extensions != null &&\n                        resolverValue.extensions != null) {\n                        config.extensions = Object.assign({}, type.extensions, resolverValue.extensions);\n                    }\n                    else if (enumValueConfigMap[fieldName]) {\n                        enumValueConfigMap[fieldName].value = resolverValue[fieldName];\n                    }\n                });\n                return new GraphQLEnumType(config);\n            }\n        },\n        [MapperKind.UNION_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                });\n                return new GraphQLUnionType(config);\n            }\n        },\n        [MapperKind.OBJECT_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                });\n                return new GraphQLObjectType(config);\n            }\n        },\n        [MapperKind.INTERFACE_TYPE]: type => {\n            const resolverValue = resolvers[type.name];\n            if (resolverValue != null) {\n                const config = type.toConfig();\n                Object.keys(resolverValue).forEach(fieldName => {\n                    if (fieldName.startsWith('__')) {\n                        config[fieldName.substring(2)] = resolverValue[fieldName];\n                    }\n                });\n                return new GraphQLInterfaceType(config);\n            }\n        },\n        [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n            const resolverValue = resolvers[typeName];\n            if (resolverValue != null) {\n                const fieldResolve = resolverValue[fieldName];\n                if (fieldResolve != null) {\n                    const newFieldConfig = { ...fieldConfig };\n                    if (typeof fieldResolve === 'function') {\n                        // for convenience. Allows shorter syntax in resolver definition file\n                        newFieldConfig.resolve = fieldResolve;\n                    }\n                    else {\n                        setFieldProperties(newFieldConfig, fieldResolve);\n                    }\n                    return newFieldConfig;\n                }\n            }\n        },\n    });\n    if (defaultFieldResolver != null) {\n        schema = mapSchema(schema, {\n            [MapperKind.OBJECT_FIELD]: fieldConfig => ({\n                ...fieldConfig,\n                resolve: fieldConfig.resolve != null ? fieldConfig.resolve : defaultFieldResolver,\n            }),\n        });\n    }\n    return schema;\n}\nfunction setFieldProperties(field, propertiesObj) {\n    Object.keys(propertiesObj).forEach(propertyName => {\n        field[propertyName] = propertiesObj[propertyName];\n    });\n}\n//# sourceMappingURL=addResolversToSchema.js.map","import { mapSchema, MapperKind } from '@graphql-tools/utils';\nimport { decorateWithLogger } from './decorateWithLogger';\nexport function addErrorLoggingToSchema(schema, logger) {\n    if (!logger) {\n        throw new Error('Must provide a logger');\n    }\n    if (typeof logger.log !== 'function') {\n        throw new Error('Logger.log must be a function');\n    }\n    return mapSchema(schema, {\n        [MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName) => ({\n            ...fieldConfig,\n            resolve: decorateWithLogger(fieldConfig.resolve, logger, `${typeName}.${fieldName}`),\n        }),\n    });\n}\n//# sourceMappingURL=addErrorLoggingToSchema.js.map","import { defaultFieldResolver } from 'graphql';\nimport { mapSchema, MapperKind } from '@graphql-tools/utils';\nfunction decorateToCatchUndefined(fn, hint) {\n    const resolve = fn == null ? defaultFieldResolver : fn;\n    return (root, args, ctx, info) => {\n        const result = resolve(root, args, ctx, info);\n        if (typeof result === 'undefined') {\n            throw new Error(`Resolver for \"${hint}\" returned undefined`);\n        }\n        return result;\n    };\n}\nexport function addCatchUndefinedToSchema(schema) {\n    return mapSchema(schema, {\n        [MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName) => ({\n            ...fieldConfig,\n            resolve: decorateToCatchUndefined(fieldConfig.resolve, `${typeName}.${fieldName}`),\n        }),\n    });\n}\n//# sourceMappingURL=addCatchUndefinedToSchema.js.map","import { mergeDeep, SchemaDirectiveVisitor, pruneSchema } from '@graphql-tools/utils';\nimport { addResolversToSchema } from './addResolversToSchema';\nimport { attachDirectiveResolvers } from './attachDirectiveResolvers';\nimport { assertResolversPresent } from './assertResolversPresent';\nimport { addSchemaLevelResolver } from './addSchemaLevelResolver';\nimport { buildSchemaFromTypeDefinitions } from './buildSchemaFromTypeDefinitions';\nimport { addErrorLoggingToSchema } from './addErrorLoggingToSchema';\nimport { addCatchUndefinedToSchema } from './addCatchUndefinedToSchema';\n/**\n * Builds a schema from the provided type definitions and resolvers.\n *\n * The type definitions are written using Schema Definition Language (SDL). They\n * can be provided as a string, a `DocumentNode`, a function, or an array of any\n * of these. If a function is provided, it will be passed no arguments and\n * should return an array of strings or `DocumentNode`s.\n *\n * Note: You can use `graphql-tag` to not only parse a string into a\n * `DocumentNode` but also to provide additinal syntax hightlighting in your\n * editor (with the appropriate editor plugin).\n *\n * ```js\n * const typeDefs = gql`\n *   type Query {\n *     posts: [Post]\n *     author(id: Int!): Author\n *   }\n * `;\n * ```\n *\n * The `resolvers` object should be a map of type names to nested object, which\n * themselves map the type's fields to their appropriate resolvers.\n * See the [Resolvers](/docs/resolvers) section of the documentation for more details.\n *\n * ```js\n * const resolvers = {\n *   Query: {\n *     posts: (obj, args, ctx, info) => getAllPosts(),\n *     author: (obj, args, ctx, info) => getAuthorById(args.id)\n *   }\n * };\n * ```\n *\n * Once you've defined both the `typeDefs` and `resolvers`, you can create your\n * schema:\n *\n * ```js\n * const schema = makeExecutableSchema({\n *   typeDefs,\n *   resolvers,\n * })\n * ```\n */\nexport function makeExecutableSchema({ typeDefs, resolvers = {}, logger, allowUndefinedInResolve = true, resolverValidationOptions = {}, directiveResolvers, schemaDirectives, schemaTransforms = [], parseOptions = {}, inheritResolversFromInterfaces = false, pruningOptions, }) {\n    // Validate and clean up arguments\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new Error('Expected `resolverValidationOptions` to be an object');\n    }\n    if (!typeDefs) {\n        throw new Error('Must provide typeDefs');\n    }\n    // We allow passing in an array of resolver maps, in which case we merge them\n    const resolverMap = Array.isArray(resolvers) ? resolvers.reduce(mergeDeep, {}) : resolvers;\n    // Arguments are now validated and cleaned up\n    let schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\n    schema = addResolversToSchema({\n        schema,\n        resolvers: resolverMap,\n        resolverValidationOptions,\n        inheritResolversFromInterfaces,\n    });\n    assertResolversPresent(schema, resolverValidationOptions);\n    if (!allowUndefinedInResolve) {\n        schema = addCatchUndefinedToSchema(schema);\n    }\n    if (logger != null) {\n        schema = addErrorLoggingToSchema(schema, logger);\n    }\n    if (typeof resolvers['__schema'] === 'function') {\n        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n        // not doing that now, because I'd have to rewrite a lot of tests.\n        schema = addSchemaLevelResolver(schema, resolvers['__schema']);\n    }\n    schemaTransforms.forEach(schemaTransform => {\n        schema = schemaTransform(schema);\n    });\n    // directive resolvers are implemented using SchemaDirectiveVisitor.visitSchemaDirectives\n    // schema visiting modifies the schema in place\n    if (directiveResolvers != null) {\n        schema = attachDirectiveResolvers(schema, directiveResolvers);\n    }\n    if (schemaDirectives != null) {\n        SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n    }\n    return pruningOptions ? pruneSchema(schema, pruningOptions) : schema;\n}\n//# sourceMappingURL=makeExecutableSchema.js.map"]},"metadata":{},"sourceType":"module"}