{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WriteStream = exports.ReadStream = exports.ReadAfterReleasedError = exports.ReadAfterDestroyedError = void 0;\n\nconst crypto_1 = __importDefault(require(\"crypto\"));\n\nconst fs_1 = __importDefault(require(\"fs\"));\n\nconst os_1 = __importDefault(require(\"os\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst stream_1 = require(\"stream\");\n\nclass ReadAfterDestroyedError extends Error {}\n\nexports.ReadAfterDestroyedError = ReadAfterDestroyedError;\n\nclass ReadAfterReleasedError extends Error {}\n\nexports.ReadAfterReleasedError = ReadAfterReleasedError;\n\nclass ReadStream extends stream_1.Readable {\n  constructor(writeStream, options) {\n    super({\n      highWaterMark: options === null || options === void 0 ? void 0 : options.highWaterMark,\n      encoding: options === null || options === void 0 ? void 0 : options.encoding,\n      autoDestroy: true\n    });\n    this._pos = 0;\n    this._writeStream = writeStream;\n  }\n\n  _read(n) {\n    if (this.destroyed) return;\n\n    if (typeof this._writeStream[\"_fd\"] !== \"number\") {\n      this._writeStream.once(\"ready\", () => this._read(n));\n\n      return;\n    } // Using `allocUnsafe` here is OK because we return a slice the length of\n    // `bytesRead`, and discard the rest. This prevents node from having to zero\n    // out the entire allocation first.\n\n\n    const buf = Buffer.allocUnsafe(n);\n    fs_1.default.read(this._writeStream[\"_fd\"], buf, 0, n, this._pos, (error, bytesRead) => {\n      if (error) this.destroy(error); // Push any read bytes into the local stream buffer.\n\n      if (bytesRead) {\n        this._pos += bytesRead;\n        this.push(buf.slice(0, bytesRead));\n        return;\n      } // If there were no more bytes to read and the write stream is finished,\n      // than this stream has reached the end.\n\n\n      if (this._writeStream._writableState.finished) {\n        this.push(null);\n        return;\n      } // Otherwise, wait for the write stream to add more data or finish.\n\n\n      const retry = () => {\n        this._writeStream.removeListener(\"finish\", retry);\n\n        this._writeStream.removeListener(\"write\", retry);\n\n        this._read(n);\n      };\n\n      this._writeStream.addListener(\"finish\", retry);\n\n      this._writeStream.addListener(\"write\", retry);\n    });\n  }\n\n}\n\nexports.ReadStream = ReadStream;\n\nclass WriteStream extends stream_1.Writable {\n  constructor(options) {\n    super({\n      highWaterMark: options === null || options === void 0 ? void 0 : options.highWaterMark,\n      defaultEncoding: options === null || options === void 0 ? void 0 : options.defaultEncoding,\n      autoDestroy: false\n    });\n    this._fd = null;\n    this._path = null;\n    this._pos = 0;\n    this._readStreams = new Set();\n    this._released = false;\n\n    this._cleanupSync = () => {\n      process.removeListener(\"exit\", this._cleanupSync);\n      if (typeof this._fd === \"number\") try {\n        fs_1.default.closeSync(this._fd);\n      } catch (error) {// An error here probably means the fd was already closed, but we can\n        // still try to unlink the file.\n      }\n\n      try {\n        if (this._path) fs_1.default.unlinkSync(this._path);\n      } catch (error) {// If we are unable to unlink the file, the operating system will clean\n        // up on next restart, since we use store thes in `os.tmpdir()`\n      }\n    }; // Generate a random filename.\n\n\n    crypto_1.default.randomBytes(16, (error, buffer) => {\n      if (error) {\n        this.destroy(error);\n        return;\n      }\n\n      this._path = path_1.default.join(os_1.default.tmpdir(), `capacitor-${buffer.toString(\"hex\")}.tmp`); // Create a file in the OS's temporary files directory.\n\n      fs_1.default.open(this._path, \"wx+\", 0o600, (error, fd) => {\n        if (error) {\n          this.destroy(error);\n          return;\n        } // Cleanup when the process exits or is killed.\n\n\n        process.addListener(\"exit\", this._cleanupSync);\n        this._fd = fd;\n        this.emit(\"ready\");\n      });\n    });\n  }\n\n  _final(callback) {\n    if (typeof this._fd !== \"number\") {\n      this.once(\"ready\", () => this._final(callback));\n      return;\n    }\n\n    callback();\n  }\n\n  _write(chunk, encoding, callback) {\n    if (typeof this._fd !== \"number\") {\n      this.once(\"ready\", () => this._write(chunk, encoding, callback));\n      return;\n    }\n\n    fs_1.default.write(this._fd, chunk, 0, chunk.length, this._pos, error => {\n      if (error) {\n        callback(error);\n        return;\n      } // It's safe to increment `this._pos` after flushing to the filesystem\n      // because node streams ensure that only one `_write()` is active at a\n      // time. If this assumption is broken, the behavior of this library is\n      // undefined, regardless of where this is incremented. Relocating this\n      // to increment syncronously would result in correct file contents, but\n      // the out-of-order writes would still open the potential for read streams\n      // to scan positions that have not yet been written.\n\n\n      this._pos += chunk.length;\n      this.emit(\"write\");\n      callback();\n    });\n  }\n\n  release() {\n    this._released = true;\n    if (this._readStreams.size === 0) this.destroy();\n  }\n\n  _destroy(error, callback) {\n    const fd = this._fd;\n    const path = this._path;\n\n    if (typeof fd !== \"number\" || typeof path !== \"string\") {\n      this.once(\"ready\", () => this._destroy(error, callback));\n      return;\n    } // Close the file descriptor.\n\n\n    fs_1.default.close(fd, closeError => {\n      // An error here probably means the fd was already closed, but we can\n      // still try to unlink the file.\n      fs_1.default.unlink(path, unlinkError => {\n        // If we are unable to unlink the file, the operating system will\n        // clean up on next restart, since we use store thes in `os.tmpdir()`\n        this._fd = null; // We avoid removing this until now in case an exit occurs while\n        // asyncronously cleaning up.\n\n        process.removeListener(\"exit\", this._cleanupSync);\n        callback(unlinkError || closeError || error);\n      });\n    }); // Destroy all attached read streams.\n\n    for (const readStream of this._readStreams) readStream.destroy(error || undefined);\n  }\n\n  createReadStream(options) {\n    if (this.destroyed) throw new ReadAfterDestroyedError(\"A ReadStream cannot be created from a destroyed WriteStream.\");\n    if (this._released) throw new ReadAfterReleasedError(\"A ReadStream cannot be created from a released WriteStream.\");\n    const readStream = new ReadStream(this, options);\n\n    this._readStreams.add(readStream);\n\n    const remove = () => {\n      readStream.removeListener(\"close\", remove);\n\n      this._readStreams.delete(readStream);\n\n      if (this._released && this._readStreams.size === 0) {\n        this.destroy();\n      }\n    };\n\n    readStream.addListener(\"close\", remove);\n    return readStream;\n  }\n\n}\n\nexports.WriteStream = WriteStream;\nexports.default = {\n  WriteStream,\n  ReadStream,\n  ReadAfterDestroyedError,\n  ReadAfterReleasedError\n};","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/fs-capacitor/dist/index.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","WriteStream","ReadStream","ReadAfterReleasedError","ReadAfterDestroyedError","crypto_1","require","fs_1","os_1","path_1","stream_1","Error","Readable","constructor","writeStream","options","highWaterMark","encoding","autoDestroy","_pos","_writeStream","_read","n","destroyed","once","buf","Buffer","allocUnsafe","default","read","error","bytesRead","destroy","push","slice","_writableState","finished","retry","removeListener","addListener","Writable","defaultEncoding","_fd","_path","_readStreams","Set","_released","_cleanupSync","process","closeSync","unlinkSync","randomBytes","buffer","join","tmpdir","toString","open","fd","emit","_final","callback","_write","chunk","write","length","release","size","_destroy","path","close","closeError","unlink","unlinkError","readStream","undefined","createReadStream","add","remove","delete"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WriteStream = exports.ReadStream = exports.ReadAfterReleasedError = exports.ReadAfterDestroyedError = void 0;\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst os_1 = __importDefault(require(\"os\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst stream_1 = require(\"stream\");\nclass ReadAfterDestroyedError extends Error {\n}\nexports.ReadAfterDestroyedError = ReadAfterDestroyedError;\nclass ReadAfterReleasedError extends Error {\n}\nexports.ReadAfterReleasedError = ReadAfterReleasedError;\nclass ReadStream extends stream_1.Readable {\n    constructor(writeStream, options) {\n        super({\n            highWaterMark: options === null || options === void 0 ? void 0 : options.highWaterMark,\n            encoding: options === null || options === void 0 ? void 0 : options.encoding,\n            autoDestroy: true,\n        });\n        this._pos = 0;\n        this._writeStream = writeStream;\n    }\n    _read(n) {\n        if (this.destroyed)\n            return;\n        if (typeof this._writeStream[\"_fd\"] !== \"number\") {\n            this._writeStream.once(\"ready\", () => this._read(n));\n            return;\n        }\n        // Using `allocUnsafe` here is OK because we return a slice the length of\n        // `bytesRead`, and discard the rest. This prevents node from having to zero\n        // out the entire allocation first.\n        const buf = Buffer.allocUnsafe(n);\n        fs_1.default.read(this._writeStream[\"_fd\"], buf, 0, n, this._pos, (error, bytesRead) => {\n            if (error)\n                this.destroy(error);\n            // Push any read bytes into the local stream buffer.\n            if (bytesRead) {\n                this._pos += bytesRead;\n                this.push(buf.slice(0, bytesRead));\n                return;\n            }\n            // If there were no more bytes to read and the write stream is finished,\n            // than this stream has reached the end.\n            if (this._writeStream._writableState.finished) {\n                this.push(null);\n                return;\n            }\n            // Otherwise, wait for the write stream to add more data or finish.\n            const retry = () => {\n                this._writeStream.removeListener(\"finish\", retry);\n                this._writeStream.removeListener(\"write\", retry);\n                this._read(n);\n            };\n            this._writeStream.addListener(\"finish\", retry);\n            this._writeStream.addListener(\"write\", retry);\n        });\n    }\n}\nexports.ReadStream = ReadStream;\nclass WriteStream extends stream_1.Writable {\n    constructor(options) {\n        super({\n            highWaterMark: options === null || options === void 0 ? void 0 : options.highWaterMark,\n            defaultEncoding: options === null || options === void 0 ? void 0 : options.defaultEncoding,\n            autoDestroy: false,\n        });\n        this._fd = null;\n        this._path = null;\n        this._pos = 0;\n        this._readStreams = new Set();\n        this._released = false;\n        this._cleanupSync = () => {\n            process.removeListener(\"exit\", this._cleanupSync);\n            if (typeof this._fd === \"number\")\n                try {\n                    fs_1.default.closeSync(this._fd);\n                }\n                catch (error) {\n                    // An error here probably means the fd was already closed, but we can\n                    // still try to unlink the file.\n                }\n            try {\n                if (this._path)\n                    fs_1.default.unlinkSync(this._path);\n            }\n            catch (error) {\n                // If we are unable to unlink the file, the operating system will clean\n                // up on next restart, since we use store thes in `os.tmpdir()`\n            }\n        };\n        // Generate a random filename.\n        crypto_1.default.randomBytes(16, (error, buffer) => {\n            if (error) {\n                this.destroy(error);\n                return;\n            }\n            this._path = path_1.default.join(os_1.default.tmpdir(), `capacitor-${buffer.toString(\"hex\")}.tmp`);\n            // Create a file in the OS's temporary files directory.\n            fs_1.default.open(this._path, \"wx+\", 0o600, (error, fd) => {\n                if (error) {\n                    this.destroy(error);\n                    return;\n                }\n                // Cleanup when the process exits or is killed.\n                process.addListener(\"exit\", this._cleanupSync);\n                this._fd = fd;\n                this.emit(\"ready\");\n            });\n        });\n    }\n    _final(callback) {\n        if (typeof this._fd !== \"number\") {\n            this.once(\"ready\", () => this._final(callback));\n            return;\n        }\n        callback();\n    }\n    _write(chunk, encoding, callback) {\n        if (typeof this._fd !== \"number\") {\n            this.once(\"ready\", () => this._write(chunk, encoding, callback));\n            return;\n        }\n        fs_1.default.write(this._fd, chunk, 0, chunk.length, this._pos, (error) => {\n            if (error) {\n                callback(error);\n                return;\n            }\n            // It's safe to increment `this._pos` after flushing to the filesystem\n            // because node streams ensure that only one `_write()` is active at a\n            // time. If this assumption is broken, the behavior of this library is\n            // undefined, regardless of where this is incremented. Relocating this\n            // to increment syncronously would result in correct file contents, but\n            // the out-of-order writes would still open the potential for read streams\n            // to scan positions that have not yet been written.\n            this._pos += chunk.length;\n            this.emit(\"write\");\n            callback();\n        });\n    }\n    release() {\n        this._released = true;\n        if (this._readStreams.size === 0)\n            this.destroy();\n    }\n    _destroy(error, callback) {\n        const fd = this._fd;\n        const path = this._path;\n        if (typeof fd !== \"number\" || typeof path !== \"string\") {\n            this.once(\"ready\", () => this._destroy(error, callback));\n            return;\n        }\n        // Close the file descriptor.\n        fs_1.default.close(fd, (closeError) => {\n            // An error here probably means the fd was already closed, but we can\n            // still try to unlink the file.\n            fs_1.default.unlink(path, (unlinkError) => {\n                // If we are unable to unlink the file, the operating system will\n                // clean up on next restart, since we use store thes in `os.tmpdir()`\n                this._fd = null;\n                // We avoid removing this until now in case an exit occurs while\n                // asyncronously cleaning up.\n                process.removeListener(\"exit\", this._cleanupSync);\n                callback(unlinkError || closeError || error);\n            });\n        });\n        // Destroy all attached read streams.\n        for (const readStream of this._readStreams)\n            readStream.destroy(error || undefined);\n    }\n    createReadStream(options) {\n        if (this.destroyed)\n            throw new ReadAfterDestroyedError(\"A ReadStream cannot be created from a destroyed WriteStream.\");\n        if (this._released)\n            throw new ReadAfterReleasedError(\"A ReadStream cannot be created from a released WriteStream.\");\n        const readStream = new ReadStream(this, options);\n        this._readStreams.add(readStream);\n        const remove = () => {\n            readStream.removeListener(\"close\", remove);\n            this._readStreams.delete(readStream);\n            if (this._released && this._readStreams.size === 0) {\n                this.destroy();\n            }\n        };\n        readStream.addListener(\"close\", remove);\n        return readStream;\n    }\n}\nexports.WriteStream = WriteStream;\nexports.default = {\n    WriteStream,\n    ReadStream,\n    ReadAfterDestroyedError,\n    ReadAfterReleasedError,\n};\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}