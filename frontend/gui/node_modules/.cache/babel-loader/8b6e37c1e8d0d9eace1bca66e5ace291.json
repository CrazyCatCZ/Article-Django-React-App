{"ast":null,"code":"import globby, { sync } from 'globby';\nimport unixify from 'unixify';\nimport { extname } from 'path';\nimport { readFileSync, readFile, statSync, stat } from 'fs-extra';\nconst DEFAULT_IGNORED_EXTENSIONS = ['spec', 'test', 'd', 'map'];\nconst DEFAULT_EXTENSIONS = ['gql', 'graphql', 'graphqls', 'ts', 'js'];\nconst DEFAULT_EXPORT_NAMES = ['typeDefs', 'schema'];\n\nfunction asArray(obj) {\n  if (obj instanceof Array) {\n    return obj;\n  } else {\n    return [obj];\n  }\n}\n\nfunction isDirectorySync(path) {\n  try {\n    const pathStat = statSync(path);\n    return pathStat.isDirectory();\n  } catch (e) {\n    return false;\n  }\n}\n\nasync function isDirectory(path) {\n  try {\n    const pathStat = await stat(path);\n    return pathStat.isDirectory();\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction scanForFilesSync(globStr, globOptions = {}) {\n  return sync(globStr, {\n    absolute: true,\n    ...globOptions\n  });\n}\n\nfunction buildGlob(basePath, extensions, ignoredExtensions = [], recursive) {\n  const ignored = ignoredExtensions.length > 0 ? `!(${ignoredExtensions.map(e => '*.' + e).join('|')})` : '*';\n  const ext = extensions.map(e => '*.' + e).join('|');\n  return `${basePath}${recursive ? '/**' : ''}/${ignored}+(${ext})`;\n}\n\nfunction extractExports(fileExport, exportNames) {\n  if (!fileExport) {\n    return null;\n  }\n\n  if (fileExport.default) {\n    for (const exportName of exportNames) {\n      if (fileExport.default[exportName]) {\n        return fileExport.default[exportName];\n      }\n    }\n\n    return fileExport.default;\n  }\n\n  for (const exportName of exportNames) {\n    if (fileExport[exportName]) {\n      return fileExport[exportName];\n    }\n  }\n\n  return fileExport;\n}\n\nconst LoadFilesDefaultOptions = {\n  ignoredExtensions: DEFAULT_IGNORED_EXTENSIONS,\n  extensions: DEFAULT_EXTENSIONS,\n  useRequire: false,\n  requireMethod: null,\n  globOptions: {\n    absolute: true\n  },\n  exportNames: DEFAULT_EXPORT_NAMES,\n  recursive: true,\n  ignoreIndex: false\n};\n/**\n * Synchronously loads files using the provided glob pattern.\n * @param pattern Glob pattern or patterns to use when loading files\n * @param options Additional options\n */\n\nfunction loadFilesSync(pattern, options = LoadFilesDefaultOptions) {\n  const execOptions = { ...LoadFilesDefaultOptions,\n    ...options\n  };\n  const relevantPaths = scanForFilesSync(asArray(pattern).map(path => isDirectorySync(path) ? buildGlob(unixify(path), execOptions.extensions, execOptions.ignoredExtensions, execOptions.recursive) : unixify(path)), options.globOptions);\n  return relevantPaths.map(path => {\n    if (!checkExtension(path, options)) {\n      return;\n    }\n\n    if (isIndex(path, execOptions.extensions) && options.ignoreIndex) {\n      return false;\n    }\n\n    const extension = extname(path);\n\n    if (extension.endsWith('.js') || extension.endsWith('.ts') || execOptions.useRequire) {\n      const fileExports = (execOptions.requireMethod ? execOptions.requireMethod : require)(path);\n      const extractedExport = extractExports(fileExports, execOptions.exportNames);\n\n      if (extractedExport.typeDefs && extractedExport.resolvers) {\n        return extractedExport;\n      }\n\n      if (extractedExport.schema) {\n        return extractedExport.schema;\n      }\n\n      if (extractedExport.typeDef) {\n        return extractedExport.typeDef;\n      }\n\n      if (extractedExport.typeDefs) {\n        return extractedExport.typeDefs;\n      }\n\n      if (extractedExport.resolver) {\n        return extractedExport.resolver;\n      }\n\n      if (extractedExport.resolvers) {\n        return extractedExport.resolvers;\n      }\n\n      return extractedExport;\n    } else {\n      return readFileSync(path, {\n        encoding: 'utf-8'\n      });\n    }\n  }).filter(v => v);\n}\n\nasync function scanForFiles(globStr, globOptions = {}) {\n  return globby(globStr, {\n    absolute: true,\n    ...globOptions\n  });\n}\n\nconst checkExtension = (path, {\n  extensions,\n  ignoredExtensions\n}) => {\n  if (ignoredExtensions) {\n    for (const ignoredExtension of ignoredExtensions) {\n      if (path.endsWith(ignoredExtension)) {\n        return false;\n      }\n    }\n  }\n\n  if (!extensions) {\n    return true;\n  }\n\n  for (const extension of extensions) {\n    if (path.endsWith(extension)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Asynchronously loads files using the provided glob pattern.\n * @param pattern Glob pattern or patterns to use when loading files\n * @param options Additional options\n */\n\n\nasync function loadFiles(pattern, options = LoadFilesDefaultOptions) {\n  const execOptions = { ...LoadFilesDefaultOptions,\n    ...options\n  };\n  const relevantPaths = await scanForFiles(await Promise.all(asArray(pattern).map(async path => (await isDirectory(path)) ? buildGlob(unixify(path), execOptions.extensions, execOptions.ignoredExtensions, execOptions.recursive) : unixify(path))), options.globOptions);\n\n  const require$ = path => import(path).catch(async () => require(path));\n\n  return Promise.all(relevantPaths.filter(path => checkExtension(path, options) && !(isIndex(path, execOptions.extensions) && options.ignoreIndex)).map(async path => {\n    const extension = extname(path);\n\n    if (extension.endsWith('.js') || extension.endsWith('.ts') || execOptions.useRequire) {\n      const fileExports = await (execOptions.requireMethod ? execOptions.requireMethod : require$)(path);\n      const extractedExport = extractExports(fileExports, execOptions.exportNames);\n\n      if (extractedExport.resolver) {\n        return extractedExport.resolver;\n      }\n\n      if (extractedExport.resolvers) {\n        return extractedExport.resolvers;\n      }\n\n      return extractedExport;\n    } else {\n      return readFile(path, {\n        encoding: 'utf-8'\n      });\n    }\n  }));\n}\n\nfunction isIndex(path, extensions = []) {\n  const IS_INDEX = /(\\/|\\\\)index\\.[^\\/\\\\]+$/i; // (/ or \\) AND `index.` AND (everything except \\ and /)(end of line)\n\n  return IS_INDEX.test(path) && extensions.some(ext => path.endsWith('.' + ext));\n}\n\nexport { loadFiles, loadFilesSync };","map":{"version":3,"sources":["../../../dist/load-files/src/index.js"],"names":["globbySync"],"mappings":"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","sourcesContent":["import globby, { sync as globbySync } from 'globby';\nimport unixify from 'unixify';\nimport { extname } from 'path';\nimport { readFile, stat, statSync, readFileSync } from 'fs-extra';\nconst DEFAULT_IGNORED_EXTENSIONS = ['spec', 'test', 'd', 'map'];\nconst DEFAULT_EXTENSIONS = ['gql', 'graphql', 'graphqls', 'ts', 'js'];\nconst DEFAULT_EXPORT_NAMES = ['typeDefs', 'schema'];\nfunction asArray(obj) {\n    if (obj instanceof Array) {\n        return obj;\n    }\n    else {\n        return [obj];\n    }\n}\nfunction isDirectorySync(path) {\n    try {\n        const pathStat = statSync(path);\n        return pathStat.isDirectory();\n    }\n    catch (e) {\n        return false;\n    }\n}\nasync function isDirectory(path) {\n    try {\n        const pathStat = await stat(path);\n        return pathStat.isDirectory();\n    }\n    catch (e) {\n        return false;\n    }\n}\nfunction scanForFilesSync(globStr, globOptions = {}) {\n    return globbySync(globStr, { absolute: true, ...globOptions });\n}\nfunction buildGlob(basePath, extensions, ignoredExtensions = [], recursive) {\n    const ignored = ignoredExtensions.length > 0 ? `!(${ignoredExtensions.map(e => '*.' + e).join('|')})` : '*';\n    const ext = extensions.map(e => '*.' + e).join('|');\n    return `${basePath}${recursive ? '/**' : ''}/${ignored}+(${ext})`;\n}\nfunction extractExports(fileExport, exportNames) {\n    if (!fileExport) {\n        return null;\n    }\n    if (fileExport.default) {\n        for (const exportName of exportNames) {\n            if (fileExport.default[exportName]) {\n                return fileExport.default[exportName];\n            }\n        }\n        return fileExport.default;\n    }\n    for (const exportName of exportNames) {\n        if (fileExport[exportName]) {\n            return fileExport[exportName];\n        }\n    }\n    return fileExport;\n}\nconst LoadFilesDefaultOptions = {\n    ignoredExtensions: DEFAULT_IGNORED_EXTENSIONS,\n    extensions: DEFAULT_EXTENSIONS,\n    useRequire: false,\n    requireMethod: null,\n    globOptions: {\n        absolute: true,\n    },\n    exportNames: DEFAULT_EXPORT_NAMES,\n    recursive: true,\n    ignoreIndex: false,\n};\n/**\n * Synchronously loads files using the provided glob pattern.\n * @param pattern Glob pattern or patterns to use when loading files\n * @param options Additional options\n */\nexport function loadFilesSync(pattern, options = LoadFilesDefaultOptions) {\n    const execOptions = { ...LoadFilesDefaultOptions, ...options };\n    const relevantPaths = scanForFilesSync(asArray(pattern).map(path => isDirectorySync(path)\n        ? buildGlob(unixify(path), execOptions.extensions, execOptions.ignoredExtensions, execOptions.recursive)\n        : unixify(path)), options.globOptions);\n    return relevantPaths\n        .map(path => {\n        if (!checkExtension(path, options)) {\n            return;\n        }\n        if (isIndex(path, execOptions.extensions) && options.ignoreIndex) {\n            return false;\n        }\n        const extension = extname(path);\n        if (extension.endsWith('.js') || extension.endsWith('.ts') || execOptions.useRequire) {\n            const fileExports = (execOptions.requireMethod ? execOptions.requireMethod : require)(path);\n            const extractedExport = extractExports(fileExports, execOptions.exportNames);\n            if (extractedExport.typeDefs && extractedExport.resolvers) {\n                return extractedExport;\n            }\n            if (extractedExport.schema) {\n                return extractedExport.schema;\n            }\n            if (extractedExport.typeDef) {\n                return extractedExport.typeDef;\n            }\n            if (extractedExport.typeDefs) {\n                return extractedExport.typeDefs;\n            }\n            if (extractedExport.resolver) {\n                return extractedExport.resolver;\n            }\n            if (extractedExport.resolvers) {\n                return extractedExport.resolvers;\n            }\n            return extractedExport;\n        }\n        else {\n            return readFileSync(path, { encoding: 'utf-8' });\n        }\n    })\n        .filter(v => v);\n}\nasync function scanForFiles(globStr, globOptions = {}) {\n    return globby(globStr, { absolute: true, ...globOptions });\n}\nconst checkExtension = (path, { extensions, ignoredExtensions }) => {\n    if (ignoredExtensions) {\n        for (const ignoredExtension of ignoredExtensions) {\n            if (path.endsWith(ignoredExtension)) {\n                return false;\n            }\n        }\n    }\n    if (!extensions) {\n        return true;\n    }\n    for (const extension of extensions) {\n        if (path.endsWith(extension)) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * Asynchronously loads files using the provided glob pattern.\n * @param pattern Glob pattern or patterns to use when loading files\n * @param options Additional options\n */\nexport async function loadFiles(pattern, options = LoadFilesDefaultOptions) {\n    const execOptions = { ...LoadFilesDefaultOptions, ...options };\n    const relevantPaths = await scanForFiles(await Promise.all(asArray(pattern).map(async (path) => (await isDirectory(path))\n        ? buildGlob(unixify(path), execOptions.extensions, execOptions.ignoredExtensions, execOptions.recursive)\n        : unixify(path))), options.globOptions);\n    const require$ = (path) => import(path).catch(async () => require(path));\n    return Promise.all(relevantPaths\n        .filter(path => checkExtension(path, options) && !(isIndex(path, execOptions.extensions) && options.ignoreIndex))\n        .map(async (path) => {\n        const extension = extname(path);\n        if (extension.endsWith('.js') || extension.endsWith('.ts') || execOptions.useRequire) {\n            const fileExports = await (execOptions.requireMethod ? execOptions.requireMethod : require$)(path);\n            const extractedExport = extractExports(fileExports, execOptions.exportNames);\n            if (extractedExport.resolver) {\n                return extractedExport.resolver;\n            }\n            if (extractedExport.resolvers) {\n                return extractedExport.resolvers;\n            }\n            return extractedExport;\n        }\n        else {\n            return readFile(path, { encoding: 'utf-8' });\n        }\n    }));\n}\nfunction isIndex(path, extensions = []) {\n    const IS_INDEX = /(\\/|\\\\)index\\.[^\\/\\\\]+$/i; // (/ or \\) AND `index.` AND (everything except \\ and /)(end of line)\n    return IS_INDEX.test(path) && extensions.some(ext => path.endsWith('.' + ext));\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}