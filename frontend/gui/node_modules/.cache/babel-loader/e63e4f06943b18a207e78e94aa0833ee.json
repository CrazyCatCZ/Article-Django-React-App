{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\n * The compiler profiler builds a \"call graph\" of high level operations as a\n * means of tracking time spent over the course of running the compiler.\n */\n\n\nvar enabled = false;\nvar traces = [{\n  ph: 'M',\n  pid: 0,\n  tid: 0,\n  name: 'process_name',\n  args: {\n    name: 'relay-compiler'\n  }\n}, {\n  ph: 'M',\n  pid: 0,\n  tid: 0,\n  name: 'thread_name',\n  args: {\n    name: 'relay-compiler'\n  }\n}];\nvar stack = [];\n\nfunction enable() {\n  enabled = true;\n}\n\nfunction getTraces() {\n  return traces;\n}\n/**\n * Run the provided function as part of a stack profile.\n */\n\n\nfunction run(name, fn) {\n  return instrument(fn, name)();\n}\n/**\n * Run the provided async function as part context in a stack profile.\n * See instrumentAsyncContext() for limitations and usage notes.\n */\n\n\nfunction asyncContext(name, fn) {\n  return instrumentAsyncContext(fn, name)();\n}\n/**\n * Wait for the provided async operation as an async profile.\n */\n\n\nfunction waitFor(name, fn) {\n  return instrumentWait(fn, name)();\n}\n/**\n * Return a new instrumented sync function to be part of a stack profile.\n *\n * This instruments synchronous functions to be displayed in a stack\n * visualization. To instrument async functions, see instrumentAsyncContext()\n * and instrumentWait().\n */\n\n\nfunction instrument(fn, name) {\n  var _ref;\n\n  if (!enabled) {\n    return fn;\n  }\n\n  var profileName = (_ref = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any\n  fn.displayName) !== null && _ref !== void 0 ? _ref : fn.name;\n\n  var instrumented = function instrumented() {\n    var traceId = start(profileName);\n\n    try {\n      return fn.apply(this, arguments);\n    } finally {\n      end(traceId);\n    }\n  };\n\n  instrumented.displayName = profileName;\n  return instrumented;\n}\n/**\n * Return a new instrumented async function which provides context for a stack.\n *\n * Because the resulting profiling information will be incorporated into a\n * stack visualization, the instrumented function must represent a distinct\n * region of time which does not overlap with any other async context.\n *\n * In other words, functions instrumented with instrumentAsyncContext must not\n * run in parallel via Promise.all().\n *\n * To instrument functions which will run in parallel, use instrumentWait().\n */\n\n\nfunction instrumentAsyncContext(fn, name) {\n  var _ref2;\n\n  if (!enabled) {\n    return fn;\n  }\n\n  var profileName = (_ref2 = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any\n  fn.displayName) !== null && _ref2 !== void 0 ? _ref2 : fn.name;\n\n  var instrumented = /*#__PURE__*/function () {\n    var _instrumented = _asyncToGenerator(function* () {\n      var traceId = start(profileName);\n\n      try {\n        return yield fn.apply(this, arguments);\n      } finally {\n        end(traceId);\n      }\n    });\n\n    function instrumented() {\n      return _instrumented.apply(this, arguments);\n    }\n\n    return instrumented;\n  }();\n\n  instrumented.displayName = profileName;\n  return instrumented;\n}\n/**\n * Return a new instrumented function which performs an awaited async operation.\n *\n * The instrumented function is not included in the overall run time of the\n * compiler, instead it captures the time waiting on some asynchronous external\n * resource such as network or filesystem which are often run in parallel.\n */\n\n\nfunction instrumentWait(fn, name) {\n  var _ref3;\n\n  if (!enabled) {\n    return fn;\n  }\n\n  var profileName = (_ref3 = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any\n  fn.displayName) !== null && _ref3 !== void 0 ? _ref3 : fn.name;\n\n  var instrumented = /*#__PURE__*/function () {\n    var _instrumented2 = _asyncToGenerator(function* () {\n      var traceId = startWait(profileName);\n\n      try {\n        return yield fn.apply(this, arguments);\n      } finally {\n        end(traceId);\n      }\n    });\n\n    function instrumented() {\n      return _instrumented2.apply(this, arguments);\n    }\n\n    return instrumented;\n  }();\n\n  instrumented.displayName = profileName;\n  return instrumented;\n}\n\nvar T_ZERO = process.hrtime(); // Return a Uint32 of microtime duration since program start.\n\nfunction microtime() {\n  var hrtime = process.hrtime(T_ZERO); // eslint-disable-next-line no-bitwise\n\n  return 0 | hrtime[0] * 1e6 + Math.round(hrtime[1] / 1e3);\n}\n/**\n * Start a stack profile with a particular name, returns an ID to pass to end().\n *\n * Other profiles may start before this one ends, which will be represented as\n * nested operations, however all nested operations must end before this ends.\n *\n * In particular, be careful to end after errors.\n */\n\n\nfunction start(name) {\n  var beginTrace = {\n    ph: 'B',\n    name: name,\n    pid: 0,\n    tid: 0,\n    ts: microtime()\n  };\n  traces.push(beginTrace);\n  stack.push(beginTrace);\n  return traces.length - 1;\n}\n\nvar asyncID = 0;\n/**\n * Start an async wait profile with a particular name, returns an ID to pass\n * to end().\n *\n * Other profiles may start before this one ends, which will be represented as\n * nested operations, however all nested operations must end before this ends.\n *\n * In particular, be careful to end after errors.\n */\n\nfunction startWait(name) {\n  traces.push({\n    ph: 'b',\n    name: name,\n    cat: 'wait',\n    id: asyncID++,\n    pid: 0,\n    tid: 0,\n    ts: microtime()\n  });\n  return traces.length - 1;\n}\n\nfunction end(traceIdx) {\n  var trace = traces[traceIdx];\n\n  if (trace.ph === 'b') {\n    traces.push({\n      ph: 'e',\n      cat: trace.cat,\n      name: trace.name,\n      id: trace.id,\n      pid: trace.pid,\n      tid: trace.tid,\n      ts: microtime()\n    });\n    return;\n  }\n\n  !(trace.ph === 'B') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Begin trace phase') : invariant(false) : void 0;\n  !(stack.pop() === trace) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'GraphQLCompilerProfiler: The profile trace %s ended before nested traces. ' + 'If it is async, try using Profile.waitFor or Profile.profileWait.', trace.name) : invariant(false) : void 0;\n  var prevTrace = traces[traces.length - 1];\n\n  if (trace === prevTrace) {\n    traces[traceIdx] = {\n      ph: 'X',\n      name: trace.name,\n      pid: trace.pid,\n      tid: trace.tid,\n      ts: trace.ts,\n      dur: microtime() - trace.ts\n    };\n    return;\n  }\n\n  traces.push({\n    ph: 'E',\n    name: trace.name,\n    pid: trace.pid,\n    tid: trace.tid,\n    ts: microtime()\n  });\n}\n\nmodule.exports = {\n  enable: enable,\n  getTraces: getTraces,\n  run: run,\n  asyncContext: asyncContext,\n  waitFor: waitFor,\n  instrument: instrument,\n  instrumentAsyncContext: instrumentAsyncContext,\n  instrumentWait: instrumentWait,\n  start: start,\n  startWait: startWait,\n  end: end\n};","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/relay-compiler/lib/core/GraphQLCompilerProfiler.js"],"names":["_asyncToGenerator","require","invariant","enabled","traces","ph","pid","tid","name","args","stack","enable","getTraces","run","fn","instrument","asyncContext","instrumentAsyncContext","waitFor","instrumentWait","_ref","profileName","displayName","instrumented","traceId","start","apply","arguments","end","_ref2","_instrumented","_ref3","_instrumented2","startWait","T_ZERO","process","hrtime","microtime","Math","round","beginTrace","ts","push","length","asyncID","cat","id","traceIdx","trace","env","NODE_ENV","pop","prevTrace","dur","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _asyncToGenerator = require(\"@babel/runtime/helpers/asyncToGenerator\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n/**\n * The compiler profiler builds a \"call graph\" of high level operations as a\n * means of tracking time spent over the course of running the compiler.\n */\n\n\nvar enabled = false;\nvar traces = [{\n  ph: 'M',\n  pid: 0,\n  tid: 0,\n  name: 'process_name',\n  args: {\n    name: 'relay-compiler'\n  }\n}, {\n  ph: 'M',\n  pid: 0,\n  tid: 0,\n  name: 'thread_name',\n  args: {\n    name: 'relay-compiler'\n  }\n}];\nvar stack = [];\n\nfunction enable() {\n  enabled = true;\n}\n\nfunction getTraces() {\n  return traces;\n}\n/**\n * Run the provided function as part of a stack profile.\n */\n\n\nfunction run(name, fn) {\n  return instrument(fn, name)();\n}\n/**\n * Run the provided async function as part context in a stack profile.\n * See instrumentAsyncContext() for limitations and usage notes.\n */\n\n\nfunction asyncContext(name, fn) {\n  return instrumentAsyncContext(fn, name)();\n}\n/**\n * Wait for the provided async operation as an async profile.\n */\n\n\nfunction waitFor(name, fn) {\n  return instrumentWait(fn, name)();\n}\n/**\n * Return a new instrumented sync function to be part of a stack profile.\n *\n * This instruments synchronous functions to be displayed in a stack\n * visualization. To instrument async functions, see instrumentAsyncContext()\n * and instrumentWait().\n */\n\n\nfunction instrument(fn, name) {\n  var _ref;\n\n  if (!enabled) {\n    return fn;\n  }\n\n  var profileName = (_ref = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any\n  fn.displayName) !== null && _ref !== void 0 ? _ref : fn.name;\n\n  var instrumented = function instrumented() {\n    var traceId = start(profileName);\n\n    try {\n      return fn.apply(this, arguments);\n    } finally {\n      end(traceId);\n    }\n  };\n\n  instrumented.displayName = profileName;\n  return instrumented;\n}\n/**\n * Return a new instrumented async function which provides context for a stack.\n *\n * Because the resulting profiling information will be incorporated into a\n * stack visualization, the instrumented function must represent a distinct\n * region of time which does not overlap with any other async context.\n *\n * In other words, functions instrumented with instrumentAsyncContext must not\n * run in parallel via Promise.all().\n *\n * To instrument functions which will run in parallel, use instrumentWait().\n */\n\n\nfunction instrumentAsyncContext(fn, name) {\n  var _ref2;\n\n  if (!enabled) {\n    return fn;\n  }\n\n  var profileName = (_ref2 = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any\n  fn.displayName) !== null && _ref2 !== void 0 ? _ref2 : fn.name;\n\n  var instrumented = /*#__PURE__*/function () {\n    var _instrumented = _asyncToGenerator(function* () {\n      var traceId = start(profileName);\n\n      try {\n        return yield fn.apply(this, arguments);\n      } finally {\n        end(traceId);\n      }\n    });\n\n    function instrumented() {\n      return _instrumented.apply(this, arguments);\n    }\n\n    return instrumented;\n  }();\n\n  instrumented.displayName = profileName;\n  return instrumented;\n}\n/**\n * Return a new instrumented function which performs an awaited async operation.\n *\n * The instrumented function is not included in the overall run time of the\n * compiler, instead it captures the time waiting on some asynchronous external\n * resource such as network or filesystem which are often run in parallel.\n */\n\n\nfunction instrumentWait(fn, name) {\n  var _ref3;\n\n  if (!enabled) {\n    return fn;\n  }\n\n  var profileName = (_ref3 = name !== null && name !== void 0 ? name : // $FlowFixMe[prop-missing] - Flow no longer considers statics of functions as any\n  fn.displayName) !== null && _ref3 !== void 0 ? _ref3 : fn.name;\n\n  var instrumented = /*#__PURE__*/function () {\n    var _instrumented2 = _asyncToGenerator(function* () {\n      var traceId = startWait(profileName);\n\n      try {\n        return yield fn.apply(this, arguments);\n      } finally {\n        end(traceId);\n      }\n    });\n\n    function instrumented() {\n      return _instrumented2.apply(this, arguments);\n    }\n\n    return instrumented;\n  }();\n\n  instrumented.displayName = profileName;\n  return instrumented;\n}\n\nvar T_ZERO = process.hrtime(); // Return a Uint32 of microtime duration since program start.\n\nfunction microtime() {\n  var hrtime = process.hrtime(T_ZERO); // eslint-disable-next-line no-bitwise\n\n  return 0 | hrtime[0] * 1e6 + Math.round(hrtime[1] / 1e3);\n}\n/**\n * Start a stack profile with a particular name, returns an ID to pass to end().\n *\n * Other profiles may start before this one ends, which will be represented as\n * nested operations, however all nested operations must end before this ends.\n *\n * In particular, be careful to end after errors.\n */\n\n\nfunction start(name) {\n  var beginTrace = {\n    ph: 'B',\n    name: name,\n    pid: 0,\n    tid: 0,\n    ts: microtime()\n  };\n  traces.push(beginTrace);\n  stack.push(beginTrace);\n  return traces.length - 1;\n}\n\nvar asyncID = 0;\n/**\n * Start an async wait profile with a particular name, returns an ID to pass\n * to end().\n *\n * Other profiles may start before this one ends, which will be represented as\n * nested operations, however all nested operations must end before this ends.\n *\n * In particular, be careful to end after errors.\n */\n\nfunction startWait(name) {\n  traces.push({\n    ph: 'b',\n    name: name,\n    cat: 'wait',\n    id: asyncID++,\n    pid: 0,\n    tid: 0,\n    ts: microtime()\n  });\n  return traces.length - 1;\n}\n\nfunction end(traceIdx) {\n  var trace = traces[traceIdx];\n\n  if (trace.ph === 'b') {\n    traces.push({\n      ph: 'e',\n      cat: trace.cat,\n      name: trace.name,\n      id: trace.id,\n      pid: trace.pid,\n      tid: trace.tid,\n      ts: microtime()\n    });\n    return;\n  }\n\n  !(trace.ph === 'B') ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Begin trace phase') : invariant(false) : void 0;\n  !(stack.pop() === trace) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'GraphQLCompilerProfiler: The profile trace %s ended before nested traces. ' + 'If it is async, try using Profile.waitFor or Profile.profileWait.', trace.name) : invariant(false) : void 0;\n  var prevTrace = traces[traces.length - 1];\n\n  if (trace === prevTrace) {\n    traces[traceIdx] = {\n      ph: 'X',\n      name: trace.name,\n      pid: trace.pid,\n      tid: trace.tid,\n      ts: trace.ts,\n      dur: microtime() - trace.ts\n    };\n    return;\n  }\n\n  traces.push({\n    ph: 'E',\n    name: trace.name,\n    pid: trace.pid,\n    tid: trace.tid,\n    ts: microtime()\n  });\n}\n\nmodule.exports = {\n  enable: enable,\n  getTraces: getTraces,\n  run: run,\n  asyncContext: asyncContext,\n  waitFor: waitFor,\n  instrument: instrument,\n  instrumentAsyncContext: instrumentAsyncContext,\n  instrumentWait: instrumentWait,\n  start: start,\n  startWait: startWait,\n  end: end\n};"]},"metadata":{},"sourceType":"script"}