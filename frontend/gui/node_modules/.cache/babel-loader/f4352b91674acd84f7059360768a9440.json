{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar _require = require('./CompilerError'),\n    eachWithCombinedError = _require.eachWithCombinedError;\n/**\n * @public\n *\n * Helper for writing compiler transforms that apply \"map\" and/or \"filter\"-style\n * operations to compiler contexts. The `visitor` argument accepts a map of IR\n * kinds to user-defined functions that can map nodes of that kind to new values\n * (of the same kind).\n *\n * If a visitor function is defined for a kind, the visitor function is\n * responsible for traversing its children (by calling `this.traverse(node)`)\n * and returning either the input (to indicate no changes), a new node (to\n * indicate changes), or null/undefined (to indicate the removal of that node\n * from the output).\n *\n * If a visitor function is *not* defined for a kind, a default traversal is\n * used to evaluate its children.\n *\n * The `stateInitializer` argument accepts an optional function to construct the\n * state for each document (fragment or root) in the context. Any documents for\n * which the initializer returns null/undefined is deleted from the context\n * without being traversed.\n *\n * Example: Alias all scalar fields with the reverse of their name:\n *\n * ```\n * transform(context, {\n *   ScalarField: visitScalarField,\n * });\n *\n * function visitScalarField(field: ScalarField, state: State): ?ScalarField {\n *   // Traverse child nodes - for a scalar field these are the arguments &\n *   // directives.\n *   const nextField = this.traverse(field, state);\n *   // Return a new node with a different alias.\n *   return {\n *     ...nextField,\n *     alias: nextField.name.split('').reverse().join(''),\n *   };\n * }\n * ```\n */\n\n\nfunction transform(context, visitor, stateInitializer) {\n  var transformer = new Transformer(context, visitor);\n  return context.withMutations(function (ctx) {\n    var nextContext = ctx;\n    eachWithCombinedError(context.documents(), function (prevNode) {\n      var nextNode;\n\n      if (stateInitializer === undefined) {\n        nextNode = transformer.visit(prevNode, undefined);\n      } else {\n        var _state = stateInitializer(prevNode);\n\n        if (_state != null) {\n          nextNode = transformer.visit(prevNode, _state);\n        }\n      }\n\n      if (!nextNode) {\n        nextContext = nextContext.remove(prevNode.name);\n      } else if (nextNode !== prevNode) {\n        nextContext = nextContext.replace(nextNode);\n      }\n    });\n    return nextContext;\n  });\n}\n/**\n * @internal\n */\n\n\nvar Transformer = /*#__PURE__*/function () {\n  function Transformer(context, visitor) {\n    this._context = context;\n    this._states = [];\n    this._visitor = visitor;\n  }\n  /**\n   * @public\n   *\n   * Returns the original compiler context that is being transformed. This can\n   * be used to look up fragments by name, for example.\n   */\n\n\n  var _proto = Transformer.prototype;\n\n  _proto.getContext = function getContext() {\n    return this._context;\n  }\n  /**\n   * @public\n   *\n   * Transforms the node, calling a user-defined visitor function if defined for\n   * the node's kind. Uses the given state for this portion of the traversal.\n   *\n   * Note: This differs from `traverse` in that it calls a visitor function for\n   * the node itself.\n   */\n  ;\n\n  _proto.visit = function visit(node, state) {\n    this._states.push(state);\n\n    var nextNode = this._visit(node);\n\n    this._states.pop();\n\n    return nextNode;\n  }\n  /**\n   * @public\n   *\n   * Transforms the children of the given node, skipping the user-defined\n   * visitor function for the node itself. Uses the given state for this portion\n   * of the traversal.\n   *\n   * Note: This differs from `visit` in that it does not call a visitor function\n   * for the node itself.\n   */\n  ;\n\n  _proto.traverse = function traverse(node, state) {\n    this._states.push(state);\n\n    var nextNode = this._traverse(node);\n\n    this._states.pop();\n\n    return nextNode;\n  };\n\n  _proto._visit = function _visit(node) {\n    var nodeVisitor = this._visitor[node.kind];\n\n    if (nodeVisitor) {\n      // If a handler for the kind is defined, it is responsible for calling\n      // `traverse` to transform children as necessary.\n      var _state2 = this._getState();\n\n      var nextNode = nodeVisitor.call(this, node, _state2);\n      return nextNode;\n    } // Otherwise traverse is called automatically.\n\n\n    return this._traverse(node);\n  };\n\n  _proto._traverse = function _traverse(prevNode) {\n    var nextNode;\n\n    switch (prevNode.kind) {\n      case 'Argument':\n        nextNode = this._traverseChildren(prevNode, null, ['value']);\n        break;\n\n      case 'Literal':\n      case 'LocalArgumentDefinition':\n      case 'RootArgumentDefinition':\n      case 'Variable':\n        nextNode = prevNode;\n        break;\n\n      case 'Defer':\n        nextNode = this._traverseChildren(prevNode, ['selections'], ['if']);\n        break;\n\n      case 'Stream':\n        nextNode = this._traverseChildren(prevNode, ['selections'], ['if', 'initialCount']);\n        break;\n\n      case 'ClientExtension':\n        nextNode = this._traverseChildren(prevNode, ['selections']);\n        break;\n\n      case 'Directive':\n        nextNode = this._traverseChildren(prevNode, ['args']);\n        break;\n\n      case 'ModuleImport':\n        nextNode = this._traverseChildren(prevNode, ['selections']);\n\n        if (!nextNode.selections.length) {\n          nextNode = null;\n        }\n\n        break;\n\n      case 'FragmentSpread':\n      case 'ScalarField':\n        nextNode = this._traverseChildren(prevNode, ['args', 'directives']);\n        break;\n\n      case 'InlineDataFragmentSpread':\n        nextNode = this._traverseChildren(prevNode, ['selections']);\n        break;\n\n      case 'LinkedField':\n        nextNode = this._traverseChildren(prevNode, ['args', 'directives', 'selections']);\n\n        if (!nextNode.selections.length) {\n          nextNode = null;\n        }\n\n        break;\n\n      case 'ListValue':\n        nextNode = this._traverseChildren(prevNode, ['items']);\n        break;\n\n      case 'ObjectFieldValue':\n        nextNode = this._traverseChildren(prevNode, null, ['value']);\n        break;\n\n      case 'ObjectValue':\n        nextNode = this._traverseChildren(prevNode, ['fields']);\n        break;\n\n      case 'Condition':\n        nextNode = this._traverseChildren(prevNode, ['directives', 'selections'], ['condition']);\n\n        if (!nextNode.selections.length) {\n          nextNode = null;\n        }\n\n        break;\n\n      case 'InlineFragment':\n        nextNode = this._traverseChildren(prevNode, ['directives', 'selections']);\n\n        if (!nextNode.selections.length) {\n          nextNode = null;\n        }\n\n        break;\n\n      case 'Fragment':\n      case 'Root':\n        nextNode = this._traverseChildren(prevNode, ['argumentDefinitions', 'directives', 'selections']);\n        break;\n\n      case 'Request':\n        nextNode = this._traverseChildren(prevNode, null, ['fragment', 'root']);\n        break;\n\n      case 'SplitOperation':\n        nextNode = this._traverseChildren(prevNode, ['selections']);\n        break;\n\n      default:\n        prevNode;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'IRTransformer: Unknown kind `%s`.', prevNode.kind) : invariant(false) : void 0;\n    }\n\n    return nextNode;\n  };\n\n  _proto._traverseChildren = function _traverseChildren(prevNode, pluralKeys, singularKeys) {\n    var _this = this;\n\n    var nextNode;\n    pluralKeys && pluralKeys.forEach(function (key) {\n      var prevItems = prevNode[key];\n\n      if (!prevItems) {\n        return;\n      }\n\n      !Array.isArray(prevItems) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'IRTransformer: Expected data for `%s` to be an array, got `%s`.', key, prevItems) : invariant(false) : void 0;\n\n      var nextItems = _this._map(prevItems);\n\n      if (nextNode || nextItems !== prevItems) {\n        nextNode = nextNode || _objectSpread({}, prevNode);\n        nextNode[key] = nextItems;\n      }\n    });\n    singularKeys && singularKeys.forEach(function (key) {\n      var prevItem = prevNode[key];\n\n      if (!prevItem) {\n        return;\n      }\n\n      var nextItem = _this._visit(prevItem);\n\n      if (nextNode || nextItem !== prevItem) {\n        nextNode = nextNode || _objectSpread({}, prevNode);\n        nextNode[key] = nextItem;\n      }\n    });\n    return nextNode || prevNode;\n  };\n\n  _proto._map = function _map(prevItems) {\n    var _this2 = this;\n\n    var nextItems;\n    prevItems.forEach(function (prevItem, index) {\n      var nextItem = _this2._visit(prevItem);\n\n      if (nextItems || nextItem !== prevItem) {\n        nextItems = nextItems || prevItems.slice(0, index);\n\n        if (nextItem) {\n          nextItems.push(nextItem);\n        }\n      }\n    });\n    return nextItems || prevItems;\n  };\n\n  _proto._getState = function _getState() {\n    !this._states.length ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'IRTransformer: Expected a current state to be set but found none. ' + 'This is usually the result of mismatched number of pushState()/popState() ' + 'calls.') : invariant(false) : void 0;\n    return this._states[this._states.length - 1];\n  };\n\n  return Transformer;\n}();\n\nmodule.exports = {\n  transform: transform\n};","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/relay-compiler/lib/core/IRTransformer.js"],"names":["_interopRequireDefault","require","_defineProperty2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","invariant","_require","eachWithCombinedError","transform","context","visitor","stateInitializer","transformer","Transformer","withMutations","ctx","nextContext","documents","prevNode","nextNode","undefined","visit","_state","remove","name","replace","_context","_states","_visitor","_proto","prototype","getContext","node","state","_visit","pop","traverse","_traverse","nodeVisitor","kind","_state2","_getState","call","_traverseChildren","selections","process","env","NODE_ENV","pluralKeys","singularKeys","_this","prevItems","Array","isArray","nextItems","_map","prevItem","nextItem","_this2","index","slice","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar _require = require('./CompilerError'),\n    eachWithCombinedError = _require.eachWithCombinedError;\n\n/**\n * @public\n *\n * Helper for writing compiler transforms that apply \"map\" and/or \"filter\"-style\n * operations to compiler contexts. The `visitor` argument accepts a map of IR\n * kinds to user-defined functions that can map nodes of that kind to new values\n * (of the same kind).\n *\n * If a visitor function is defined for a kind, the visitor function is\n * responsible for traversing its children (by calling `this.traverse(node)`)\n * and returning either the input (to indicate no changes), a new node (to\n * indicate changes), or null/undefined (to indicate the removal of that node\n * from the output).\n *\n * If a visitor function is *not* defined for a kind, a default traversal is\n * used to evaluate its children.\n *\n * The `stateInitializer` argument accepts an optional function to construct the\n * state for each document (fragment or root) in the context. Any documents for\n * which the initializer returns null/undefined is deleted from the context\n * without being traversed.\n *\n * Example: Alias all scalar fields with the reverse of their name:\n *\n * ```\n * transform(context, {\n *   ScalarField: visitScalarField,\n * });\n *\n * function visitScalarField(field: ScalarField, state: State): ?ScalarField {\n *   // Traverse child nodes - for a scalar field these are the arguments &\n *   // directives.\n *   const nextField = this.traverse(field, state);\n *   // Return a new node with a different alias.\n *   return {\n *     ...nextField,\n *     alias: nextField.name.split('').reverse().join(''),\n *   };\n * }\n * ```\n */\nfunction transform(context, visitor, stateInitializer) {\n  var transformer = new Transformer(context, visitor);\n  return context.withMutations(function (ctx) {\n    var nextContext = ctx;\n    eachWithCombinedError(context.documents(), function (prevNode) {\n      var nextNode;\n\n      if (stateInitializer === undefined) {\n        nextNode = transformer.visit(prevNode, undefined);\n      } else {\n        var _state = stateInitializer(prevNode);\n\n        if (_state != null) {\n          nextNode = transformer.visit(prevNode, _state);\n        }\n      }\n\n      if (!nextNode) {\n        nextContext = nextContext.remove(prevNode.name);\n      } else if (nextNode !== prevNode) {\n        nextContext = nextContext.replace(nextNode);\n      }\n    });\n    return nextContext;\n  });\n}\n/**\n * @internal\n */\n\n\nvar Transformer = /*#__PURE__*/function () {\n  function Transformer(context, visitor) {\n    this._context = context;\n    this._states = [];\n    this._visitor = visitor;\n  }\n  /**\n   * @public\n   *\n   * Returns the original compiler context that is being transformed. This can\n   * be used to look up fragments by name, for example.\n   */\n\n\n  var _proto = Transformer.prototype;\n\n  _proto.getContext = function getContext() {\n    return this._context;\n  }\n  /**\n   * @public\n   *\n   * Transforms the node, calling a user-defined visitor function if defined for\n   * the node's kind. Uses the given state for this portion of the traversal.\n   *\n   * Note: This differs from `traverse` in that it calls a visitor function for\n   * the node itself.\n   */\n  ;\n\n  _proto.visit = function visit(node, state) {\n    this._states.push(state);\n\n    var nextNode = this._visit(node);\n\n    this._states.pop();\n\n    return nextNode;\n  }\n  /**\n   * @public\n   *\n   * Transforms the children of the given node, skipping the user-defined\n   * visitor function for the node itself. Uses the given state for this portion\n   * of the traversal.\n   *\n   * Note: This differs from `visit` in that it does not call a visitor function\n   * for the node itself.\n   */\n  ;\n\n  _proto.traverse = function traverse(node, state) {\n    this._states.push(state);\n\n    var nextNode = this._traverse(node);\n\n    this._states.pop();\n\n    return nextNode;\n  };\n\n  _proto._visit = function _visit(node) {\n    var nodeVisitor = this._visitor[node.kind];\n\n    if (nodeVisitor) {\n      // If a handler for the kind is defined, it is responsible for calling\n      // `traverse` to transform children as necessary.\n      var _state2 = this._getState();\n\n      var nextNode = nodeVisitor.call(this, node, _state2);\n      return nextNode;\n    } // Otherwise traverse is called automatically.\n\n\n    return this._traverse(node);\n  };\n\n  _proto._traverse = function _traverse(prevNode) {\n    var nextNode;\n\n    switch (prevNode.kind) {\n      case 'Argument':\n        nextNode = this._traverseChildren(prevNode, null, ['value']);\n        break;\n\n      case 'Literal':\n      case 'LocalArgumentDefinition':\n      case 'RootArgumentDefinition':\n      case 'Variable':\n        nextNode = prevNode;\n        break;\n\n      case 'Defer':\n        nextNode = this._traverseChildren(prevNode, ['selections'], ['if']);\n        break;\n\n      case 'Stream':\n        nextNode = this._traverseChildren(prevNode, ['selections'], ['if', 'initialCount']);\n        break;\n\n      case 'ClientExtension':\n        nextNode = this._traverseChildren(prevNode, ['selections']);\n        break;\n\n      case 'Directive':\n        nextNode = this._traverseChildren(prevNode, ['args']);\n        break;\n\n      case 'ModuleImport':\n        nextNode = this._traverseChildren(prevNode, ['selections']);\n\n        if (!nextNode.selections.length) {\n          nextNode = null;\n        }\n\n        break;\n\n      case 'FragmentSpread':\n      case 'ScalarField':\n        nextNode = this._traverseChildren(prevNode, ['args', 'directives']);\n        break;\n\n      case 'InlineDataFragmentSpread':\n        nextNode = this._traverseChildren(prevNode, ['selections']);\n        break;\n\n      case 'LinkedField':\n        nextNode = this._traverseChildren(prevNode, ['args', 'directives', 'selections']);\n\n        if (!nextNode.selections.length) {\n          nextNode = null;\n        }\n\n        break;\n\n      case 'ListValue':\n        nextNode = this._traverseChildren(prevNode, ['items']);\n        break;\n\n      case 'ObjectFieldValue':\n        nextNode = this._traverseChildren(prevNode, null, ['value']);\n        break;\n\n      case 'ObjectValue':\n        nextNode = this._traverseChildren(prevNode, ['fields']);\n        break;\n\n      case 'Condition':\n        nextNode = this._traverseChildren(prevNode, ['directives', 'selections'], ['condition']);\n\n        if (!nextNode.selections.length) {\n          nextNode = null;\n        }\n\n        break;\n\n      case 'InlineFragment':\n        nextNode = this._traverseChildren(prevNode, ['directives', 'selections']);\n\n        if (!nextNode.selections.length) {\n          nextNode = null;\n        }\n\n        break;\n\n      case 'Fragment':\n      case 'Root':\n        nextNode = this._traverseChildren(prevNode, ['argumentDefinitions', 'directives', 'selections']);\n        break;\n\n      case 'Request':\n        nextNode = this._traverseChildren(prevNode, null, ['fragment', 'root']);\n        break;\n\n      case 'SplitOperation':\n        nextNode = this._traverseChildren(prevNode, ['selections']);\n        break;\n\n      default:\n        prevNode;\n        !false ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'IRTransformer: Unknown kind `%s`.', prevNode.kind) : invariant(false) : void 0;\n    }\n\n    return nextNode;\n  };\n\n  _proto._traverseChildren = function _traverseChildren(prevNode, pluralKeys, singularKeys) {\n    var _this = this;\n\n    var nextNode;\n    pluralKeys && pluralKeys.forEach(function (key) {\n      var prevItems = prevNode[key];\n\n      if (!prevItems) {\n        return;\n      }\n\n      !Array.isArray(prevItems) ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'IRTransformer: Expected data for `%s` to be an array, got `%s`.', key, prevItems) : invariant(false) : void 0;\n\n      var nextItems = _this._map(prevItems);\n\n      if (nextNode || nextItems !== prevItems) {\n        nextNode = nextNode || _objectSpread({}, prevNode);\n        nextNode[key] = nextItems;\n      }\n    });\n    singularKeys && singularKeys.forEach(function (key) {\n      var prevItem = prevNode[key];\n\n      if (!prevItem) {\n        return;\n      }\n\n      var nextItem = _this._visit(prevItem);\n\n      if (nextNode || nextItem !== prevItem) {\n        nextNode = nextNode || _objectSpread({}, prevNode);\n        nextNode[key] = nextItem;\n      }\n    });\n    return nextNode || prevNode;\n  };\n\n  _proto._map = function _map(prevItems) {\n    var _this2 = this;\n\n    var nextItems;\n    prevItems.forEach(function (prevItem, index) {\n      var nextItem = _this2._visit(prevItem);\n\n      if (nextItems || nextItem !== prevItem) {\n        nextItems = nextItems || prevItems.slice(0, index);\n\n        if (nextItem) {\n          nextItems.push(nextItem);\n        }\n      }\n    });\n    return nextItems || prevItems;\n  };\n\n  _proto._getState = function _getState() {\n    !this._states.length ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'IRTransformer: Expected a current state to be set but found none. ' + 'This is usually the result of mismatched number of pushState()/popState() ' + 'calls.') : invariant(false) : void 0;\n    return this._states[this._states.length - 1];\n  };\n\n  return Transformer;\n}();\n\nmodule.exports = {\n  transform: transform\n};"]},"metadata":{},"sourceType":"script"}