{"ast":null,"code":"import { isSchema, isInterfaceType, GraphQLInterfaceType, GraphQLUnionType, graphql, getNullableType, getNamedType, isListType, isAbstractType, isObjectType, isEnumType } from 'graphql';\nimport { buildSchemaFromTypeDefinitions } from '@graphql-tools/schema';\nimport { mapSchema, MapperKind } from '@graphql-tools/utils';\n/**\n * A convenience wrapper on top of addMocksToSchema. It adds your mock resolvers\n * to your schema and returns a client that will correctly execute your query with\n * variables. Note: when executing queries from the returned server, context and\n * root will both equal `{}`.\n * @param schema The schema to which to add mocks. This can also be a set of type\n * definitions instead.\n * @param mocks The mocks to add to the schema.\n * @param preserveResolvers Set to `true` to prevent existing resolvers from being\n * overwritten to provide mock data. This can be used to mock some parts of the\n * server and not others.\n */\n\nfunction mockServer(schema, mocks, preserveResolvers = false) {\n  let mySchema;\n\n  if (!isSchema(schema)) {\n    // TODO: provide useful error messages here if this fails\n    mySchema = buildSchemaFromTypeDefinitions(schema);\n  } else {\n    mySchema = schema;\n  }\n\n  mySchema = addMocksToSchema({\n    schema: mySchema,\n    mocks,\n    preserveResolvers\n  });\n  return {\n    query: (query, vars) => graphql(mySchema, query, {}, {}, vars)\n  };\n}\n\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = Math.random() * 16 | 0; // eslint-disable-next-line eqeqeq\n\n    const v = c == 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n}\n\nconst defaultMockMap = new Map();\ndefaultMockMap.set('Int', () => Math.round(Math.random() * 200) - 100);\ndefaultMockMap.set('Float', () => Math.random() * 200 - 100);\ndefaultMockMap.set('String', () => 'Hello World');\ndefaultMockMap.set('Boolean', () => Math.random() > 0.5);\ndefaultMockMap.set('ID', () => uuidv4()); // TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\n\n/**\n * Given an instance of GraphQLSchema and a mock object, returns a new schema\n * that can return mock data for any valid query that is sent to the server.\n * @param options Options object\n */\n\nfunction addMocksToSchema({\n  schema,\n  mocks = {},\n  preserveResolvers = false\n}) {\n  if (!schema) {\n    throw new Error('Must provide schema to mock');\n  }\n\n  if (!isSchema(schema)) {\n    throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n  }\n\n  if (!isObject(mocks)) {\n    throw new Error('mocks must be of type Object');\n  } // use Map internally, because that API is nicer.\n\n\n  const mockFunctionMap = new Map();\n  Object.keys(mocks).forEach(typeName => {\n    mockFunctionMap.set(typeName, mocks[typeName]);\n  });\n  mockFunctionMap.forEach((mockFunction, mockTypeName) => {\n    if (typeof mockFunction !== 'function') {\n      throw new Error(`mockFunctionMap[${mockTypeName}] must be a function`);\n    }\n  });\n\n  const mockType = function (type, _typeName, fieldName) {\n    // order of precendence for mocking:\n    // 1. if the object passed in already has fieldName, just use that\n    // --> if it's a function, that becomes your resolver\n    // --> if it's a value, the mock resolver will return that\n    // 2. if the nullableType is a list, recurse\n    // 2. if there's a mock defined for this typeName, that will be used\n    // 3. if there's no mock defined, use the default mocks for this type\n    return (root, args, context, info) => {\n      // nullability doesn't matter for the purpose of mocking.\n      const fieldType = getNullableType(type);\n      const namedFieldType = getNamedType(fieldType);\n\n      if (fieldName && root && typeof root[fieldName] !== 'undefined') {\n        let result; // if we're here, the field is already defined\n\n        if (typeof root[fieldName] === 'function') {\n          result = root[fieldName](root, args, context, info);\n\n          if (isMockList(result)) {\n            result = result.mock(root, args, context, info, fieldType, mockType);\n          }\n        } else {\n          result = root[fieldName];\n        } // Now we merge the result with the default mock for this type.\n        // This allows overriding defaults while writing very little code.\n\n\n        if (mockFunctionMap.has(namedFieldType.name)) {\n          const mock = mockFunctionMap.get(namedFieldType.name);\n          result = mergeMocks(mock.bind(null, root, args, context, info), result);\n        }\n\n        return result;\n      }\n\n      if (isListType(fieldType)) {\n        return [mockType(fieldType.ofType)(root, args, context, info), mockType(fieldType.ofType)(root, args, context, info)];\n      }\n\n      if (mockFunctionMap.has(fieldType.name) && !isAbstractType(fieldType)) {\n        // the object passed doesn't have this field, so we apply the default mock\n        const mock = mockFunctionMap.get(fieldType.name);\n        return mock(root, args, context, info);\n      }\n\n      if (isObjectType(fieldType)) {\n        // objects don't return actual data, we only need to mock scalars!\n        return {};\n      } // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n      // otherwise randomly pick a type from all implementation types\n\n\n      if (isAbstractType(fieldType)) {\n        let implementationType;\n        let interfaceMockObj = {};\n\n        if (mockFunctionMap.has(fieldType.name)) {\n          const mock = mockFunctionMap.get(fieldType.name);\n          interfaceMockObj = mock(root, args, context, info);\n\n          if (!interfaceMockObj || !interfaceMockObj.__typename) {\n            return Error(`Please return a __typename in \"${fieldType.name}\"`);\n          }\n\n          implementationType = schema.getType(interfaceMockObj.__typename);\n        } else {\n          const possibleTypes = schema.getPossibleTypes(fieldType);\n          implementationType = getRandomElement(possibleTypes);\n        }\n\n        return {\n          __typename: implementationType,\n          ...interfaceMockObj,\n          ...mockType(implementationType)(root, args, context, info)\n        };\n      }\n\n      if (isEnumType(fieldType)) {\n        return getRandomElement(fieldType.getValues()).value;\n      }\n\n      if (defaultMockMap.has(fieldType.name)) {\n        const defaultMock = defaultMockMap.get(fieldType.name);\n        return defaultMock(root, args, context, info);\n      } // if we get to here, we don't have a value, and we don't have a mock for this type,\n      // we could return undefined, but that would be hard to debug, so we throw instead.\n      // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n\n\n      return Error(`No mock defined for type \"${fieldType.name}\"`);\n    };\n  };\n\n  return mapSchema(schema, {\n    [MapperKind.ABSTRACT_TYPE]: type => {\n      const oldResolveType = type.resolveType;\n\n      if (preserveResolvers && oldResolveType != null && oldResolveType.length) {\n        return;\n      } // the default `resolveType` always returns null. We add a fallback\n      // resolution that works with how unions and interface are mocked\n\n\n      const resolveType = (data, _context, info) => info.schema.getType(data.__typename);\n\n      if (isInterfaceType(type)) {\n        return new GraphQLInterfaceType({ ...type.toConfig(),\n          resolveType\n        });\n      } else {\n        return new GraphQLUnionType({ ...type.toConfig(),\n          resolveType\n        });\n      }\n    },\n    [MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName) => {\n      const fieldType = fieldConfig.type;\n      const fieldResolver = fieldConfig.resolve;\n      const newFieldConfig = { ...fieldConfig\n      };\n      let mockResolver = mockType(fieldType, typeName, fieldName); // we have to handle the root mutation and root query types differently,\n      // because no resolver is called at the root.\n\n      const queryType = schema.getQueryType();\n      const isOnQueryType = queryType != null && queryType.name === typeName;\n      const mutationType = schema.getMutationType();\n      const isOnMutationType = mutationType != null && mutationType.name === typeName;\n      const subscriptionType = schema.getSubscriptionType();\n      const isOnSubscriptionType = subscriptionType != null && subscriptionType.name === typeName;\n\n      if (isOnQueryType || isOnMutationType || isOnSubscriptionType) {\n        if (mockFunctionMap.has(typeName)) {\n          const rootMock = mockFunctionMap.get(typeName); // XXX: BUG in here, need to provide proper signature for rootMock.\n\n          if (typeof rootMock(undefined, {}, {}, {})[fieldName] === 'function') {\n            mockResolver = (root, args, context, info) => {\n              const updatedRoot = root !== null && root !== void 0 ? root : {}; // TODO: should we clone instead?\n\n              updatedRoot[fieldName] = rootMock(root, args, context, info)[fieldName]; // XXX this is a bit of a hack to still use mockType, which\n              // lets you mock lists etc. as well\n              // otherwise we could just set field.resolve to rootMock()[fieldName]\n              // it's like pretending there was a resolver that ran before\n              // the root resolver.\n\n              const result = mockType(fieldConfig.type, typeName, fieldName)(updatedRoot, args, context, info);\n              return result;\n            };\n          }\n        }\n      }\n\n      if (!preserveResolvers || !fieldResolver) {\n        newFieldConfig.resolve = mockResolver;\n      } else {\n        const oldResolver = fieldResolver;\n\n        newFieldConfig.resolve = (rootObject, args, context, info) => Promise.all([mockResolver(rootObject, args, context, info), oldResolver(rootObject, args, context, info)]).then(values => {\n          const [mockedValue, resolvedValue] = values; // In case we couldn't mock\n\n          if (mockedValue instanceof Error) {\n            // only if value was not resolved, populate the error.\n            if (undefined === resolvedValue) {\n              throw mockedValue;\n            }\n\n            return resolvedValue;\n          }\n\n          if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n            return undefined !== resolvedValue ? resolvedValue : mockedValue;\n          }\n\n          if (isObject(mockedValue) && isObject(resolvedValue)) {\n            // Object.assign() won't do here, as we need to all properties, including\n            // the non-enumerable ones and defined using Object.defineProperty\n            const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n            return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n          }\n\n          return undefined !== resolvedValue ? resolvedValue : mockedValue;\n        });\n      }\n\n      const fieldSubscriber = fieldConfig.subscribe;\n\n      const mockSubscriber = (..._args) => ({\n        [Symbol.asyncIterator]() {\n          return {\n            async next() {\n              return {\n                done: true,\n                value: {}\n              };\n            }\n\n          };\n        }\n\n      });\n\n      if (!preserveResolvers || !fieldSubscriber) {\n        newFieldConfig.subscribe = mockSubscriber;\n      } else {\n        newFieldConfig.subscribe = async (rootObject, args, context, info) => {\n          const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([mockSubscriber(rootObject, args, context, info), fieldSubscriber(rootObject, args, context, info)]);\n          return oldAsyncIterable || mockAsyncIterable;\n        };\n      }\n\n      return newFieldConfig;\n    }\n  });\n}\n\nfunction isObject(thing) {\n  return thing === Object(thing) && !Array.isArray(thing);\n} // returns a random element from that ary\n\n\nfunction getRandomElement(ary) {\n  const sample = Math.floor(Math.random() * ary.length);\n  return ary[sample];\n}\n\nfunction mergeObjects(a, b) {\n  return Object.assign(a, b);\n}\n\nfunction copyOwnPropsIfNotPresent(target, source) {\n  Object.getOwnPropertyNames(source).forEach(prop => {\n    if (!Object.getOwnPropertyDescriptor(target, prop)) {\n      const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n      Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);\n    }\n  });\n}\n\nfunction copyOwnProps(target, ...sources) {\n  sources.forEach(source => {\n    let chain = source;\n\n    while (chain != null) {\n      copyOwnPropsIfNotPresent(target, chain);\n      chain = Object.getPrototypeOf(chain);\n    }\n  });\n  return target;\n} // takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\n\n\nfunction mergeMocks(genericMockFunction, customMock) {\n  if (Array.isArray(customMock)) {\n    return customMock.map(el => mergeMocks(genericMockFunction, el));\n  }\n\n  if (customMock instanceof Promise) {\n    return customMock.then(res => mergeObjects(genericMockFunction(), res));\n  }\n\n  if (isObject(customMock)) {\n    return mergeObjects(genericMockFunction(), customMock);\n  }\n\n  return customMock;\n}\n/**\n * @internal\n */\n\n\nfunction isMockList(obj) {\n  if (typeof (obj === null || obj === void 0 ? void 0 : obj.len) === 'number' || Array.isArray(obj === null || obj === void 0 ? void 0 : obj.len) && typeof (obj === null || obj === void 0 ? void 0 : obj.len[0]) === 'number') {\n    if (typeof obj.wrappedFunction === 'undefined' || typeof obj.wrappedFunction === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * This is an object you can return from your mock resolvers which calls the\n * provided `mockFunction` once for each list item.\n */\n\n\nclass MockList {\n  /**\n   * @param length Either the exact length of items to return or an inclusive\n   * range of possible lengths.\n   * @param mockFunction The function to call for each item in the list to\n   * resolve it. It can return another MockList or a value.\n   */\n  constructor(length, mockFunction) {\n    this.len = length;\n\n    if (typeof mockFunction !== 'undefined') {\n      if (typeof mockFunction !== 'function') {\n        throw new Error('Second argument to MockList must be a function or undefined');\n      }\n\n      this.wrappedFunction = mockFunction;\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  mock(root, args, context, info, fieldType, mockTypeFunc) {\n    let arr;\n\n    if (Array.isArray(this.len)) {\n      arr = new Array(this.randint(this.len[0], this.len[1]));\n    } else {\n      arr = new Array(this.len);\n    }\n\n    for (let i = 0; i < arr.length; i++) {\n      if (typeof this.wrappedFunction === 'function') {\n        const res = this.wrappedFunction(root, args, context, info);\n\n        if (isMockList(res)) {\n          const nullableType = getNullableType(fieldType.ofType);\n          arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);\n        } else {\n          arr[i] = res;\n        }\n      } else {\n        arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n      }\n    }\n\n    return arr;\n  }\n\n  randint(low, high) {\n    return Math.floor(Math.random() * (high - low + 1) + low);\n  }\n\n}\n\nexport { MockList, addMocksToSchema, isMockList, mockServer };","map":{"version":3,"sources":["../../../dist/mock/src/mocking.js"],"names":[],"mappings":"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","sourcesContent":["import { graphql, getNullableType, getNamedType, isSchema, isObjectType, isInterfaceType, isListType, isEnumType, isAbstractType, GraphQLInterfaceType, GraphQLUnionType, } from 'graphql';\nimport { buildSchemaFromTypeDefinitions } from '@graphql-tools/schema';\nimport { mapSchema, MapperKind } from '@graphql-tools/utils';\n/**\n * A convenience wrapper on top of addMocksToSchema. It adds your mock resolvers\n * to your schema and returns a client that will correctly execute your query with\n * variables. Note: when executing queries from the returned server, context and\n * root will both equal `{}`.\n * @param schema The schema to which to add mocks. This can also be a set of type\n * definitions instead.\n * @param mocks The mocks to add to the schema.\n * @param preserveResolvers Set to `true` to prevent existing resolvers from being\n * overwritten to provide mock data. This can be used to mock some parts of the\n * server and not others.\n */\nexport function mockServer(schema, mocks, preserveResolvers = false) {\n    let mySchema;\n    if (!isSchema(schema)) {\n        // TODO: provide useful error messages here if this fails\n        mySchema = buildSchemaFromTypeDefinitions(schema);\n    }\n    else {\n        mySchema = schema;\n    }\n    mySchema = addMocksToSchema({ schema: mySchema, mocks, preserveResolvers });\n    return { query: (query, vars) => graphql(mySchema, query, {}, {}, vars) };\n}\nfunction uuidv4() {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (Math.random() * 16) | 0;\n        // eslint-disable-next-line eqeqeq\n        const v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n}\nconst defaultMockMap = new Map();\ndefaultMockMap.set('Int', () => Math.round(Math.random() * 200) - 100);\ndefaultMockMap.set('Float', () => Math.random() * 200 - 100);\ndefaultMockMap.set('String', () => 'Hello World');\ndefaultMockMap.set('Boolean', () => Math.random() > 0.5);\ndefaultMockMap.set('ID', () => uuidv4());\n// TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\n/**\n * Given an instance of GraphQLSchema and a mock object, returns a new schema\n * that can return mock data for any valid query that is sent to the server.\n * @param options Options object\n */\nexport function addMocksToSchema({ schema, mocks = {}, preserveResolvers = false }) {\n    if (!schema) {\n        throw new Error('Must provide schema to mock');\n    }\n    if (!isSchema(schema)) {\n        throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n    }\n    if (!isObject(mocks)) {\n        throw new Error('mocks must be of type Object');\n    }\n    // use Map internally, because that API is nicer.\n    const mockFunctionMap = new Map();\n    Object.keys(mocks).forEach(typeName => {\n        mockFunctionMap.set(typeName, mocks[typeName]);\n    });\n    mockFunctionMap.forEach((mockFunction, mockTypeName) => {\n        if (typeof mockFunction !== 'function') {\n            throw new Error(`mockFunctionMap[${mockTypeName}] must be a function`);\n        }\n    });\n    const mockType = function (type, _typeName, fieldName) {\n        // order of precendence for mocking:\n        // 1. if the object passed in already has fieldName, just use that\n        // --> if it's a function, that becomes your resolver\n        // --> if it's a value, the mock resolver will return that\n        // 2. if the nullableType is a list, recurse\n        // 2. if there's a mock defined for this typeName, that will be used\n        // 3. if there's no mock defined, use the default mocks for this type\n        return (root, args, context, info) => {\n            // nullability doesn't matter for the purpose of mocking.\n            const fieldType = getNullableType(type);\n            const namedFieldType = getNamedType(fieldType);\n            if (fieldName && root && typeof root[fieldName] !== 'undefined') {\n                let result;\n                // if we're here, the field is already defined\n                if (typeof root[fieldName] === 'function') {\n                    result = root[fieldName](root, args, context, info);\n                    if (isMockList(result)) {\n                        result = result.mock(root, args, context, info, fieldType, mockType);\n                    }\n                }\n                else {\n                    result = root[fieldName];\n                }\n                // Now we merge the result with the default mock for this type.\n                // This allows overriding defaults while writing very little code.\n                if (mockFunctionMap.has(namedFieldType.name)) {\n                    const mock = mockFunctionMap.get(namedFieldType.name);\n                    result = mergeMocks(mock.bind(null, root, args, context, info), result);\n                }\n                return result;\n            }\n            if (isListType(fieldType)) {\n                return [\n                    mockType(fieldType.ofType)(root, args, context, info),\n                    mockType(fieldType.ofType)(root, args, context, info),\n                ];\n            }\n            if (mockFunctionMap.has(fieldType.name) && !isAbstractType(fieldType)) {\n                // the object passed doesn't have this field, so we apply the default mock\n                const mock = mockFunctionMap.get(fieldType.name);\n                return mock(root, args, context, info);\n            }\n            if (isObjectType(fieldType)) {\n                // objects don't return actual data, we only need to mock scalars!\n                return {};\n            }\n            // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n            // otherwise randomly pick a type from all implementation types\n            if (isAbstractType(fieldType)) {\n                let implementationType;\n                let interfaceMockObj = {};\n                if (mockFunctionMap.has(fieldType.name)) {\n                    const mock = mockFunctionMap.get(fieldType.name);\n                    interfaceMockObj = mock(root, args, context, info);\n                    if (!interfaceMockObj || !interfaceMockObj.__typename) {\n                        return Error(`Please return a __typename in \"${fieldType.name}\"`);\n                    }\n                    implementationType = schema.getType(interfaceMockObj.__typename);\n                }\n                else {\n                    const possibleTypes = schema.getPossibleTypes(fieldType);\n                    implementationType = getRandomElement(possibleTypes);\n                }\n                return {\n                    __typename: implementationType,\n                    ...interfaceMockObj,\n                    ...mockType(implementationType)(root, args, context, info),\n                };\n            }\n            if (isEnumType(fieldType)) {\n                return getRandomElement(fieldType.getValues()).value;\n            }\n            if (defaultMockMap.has(fieldType.name)) {\n                const defaultMock = defaultMockMap.get(fieldType.name);\n                return defaultMock(root, args, context, info);\n            }\n            // if we get to here, we don't have a value, and we don't have a mock for this type,\n            // we could return undefined, but that would be hard to debug, so we throw instead.\n            // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n            return Error(`No mock defined for type \"${fieldType.name}\"`);\n        };\n    };\n    return mapSchema(schema, {\n        [MapperKind.ABSTRACT_TYPE]: type => {\n            const oldResolveType = type.resolveType;\n            if (preserveResolvers && oldResolveType != null && oldResolveType.length) {\n                return;\n            }\n            // the default `resolveType` always returns null. We add a fallback\n            // resolution that works with how unions and interface are mocked\n            const resolveType = (data, _context, info) => info.schema.getType(data.__typename);\n            if (isInterfaceType(type)) {\n                return new GraphQLInterfaceType({\n                    ...type.toConfig(),\n                    resolveType,\n                });\n            }\n            else {\n                return new GraphQLUnionType({\n                    ...type.toConfig(),\n                    resolveType,\n                });\n            }\n        },\n        [MapperKind.OBJECT_FIELD]: (fieldConfig, fieldName, typeName) => {\n            const fieldType = fieldConfig.type;\n            const fieldResolver = fieldConfig.resolve;\n            const newFieldConfig = {\n                ...fieldConfig,\n            };\n            let mockResolver = mockType(fieldType, typeName, fieldName);\n            // we have to handle the root mutation and root query types differently,\n            // because no resolver is called at the root.\n            const queryType = schema.getQueryType();\n            const isOnQueryType = queryType != null && queryType.name === typeName;\n            const mutationType = schema.getMutationType();\n            const isOnMutationType = mutationType != null && mutationType.name === typeName;\n            const subscriptionType = schema.getSubscriptionType();\n            const isOnSubscriptionType = subscriptionType != null && subscriptionType.name === typeName;\n            if (isOnQueryType || isOnMutationType || isOnSubscriptionType) {\n                if (mockFunctionMap.has(typeName)) {\n                    const rootMock = mockFunctionMap.get(typeName);\n                    // XXX: BUG in here, need to provide proper signature for rootMock.\n                    if (typeof rootMock(undefined, {}, {}, {})[fieldName] === 'function') {\n                        mockResolver = (root, args, context, info) => {\n                            const updatedRoot = root !== null && root !== void 0 ? root : {}; // TODO: should we clone instead?\n                            updatedRoot[fieldName] = rootMock(root, args, context, info)[fieldName];\n                            // XXX this is a bit of a hack to still use mockType, which\n                            // lets you mock lists etc. as well\n                            // otherwise we could just set field.resolve to rootMock()[fieldName]\n                            // it's like pretending there was a resolver that ran before\n                            // the root resolver.\n                            const result = mockType(fieldConfig.type, typeName, fieldName)(updatedRoot, args, context, info);\n                            return result;\n                        };\n                    }\n                }\n            }\n            if (!preserveResolvers || !fieldResolver) {\n                newFieldConfig.resolve = mockResolver;\n            }\n            else {\n                const oldResolver = fieldResolver;\n                newFieldConfig.resolve = (rootObject, args, context, info) => Promise.all([\n                    mockResolver(rootObject, args, context, info),\n                    oldResolver(rootObject, args, context, info),\n                ]).then(values => {\n                    const [mockedValue, resolvedValue] = values;\n                    // In case we couldn't mock\n                    if (mockedValue instanceof Error) {\n                        // only if value was not resolved, populate the error.\n                        if (undefined === resolvedValue) {\n                            throw mockedValue;\n                        }\n                        return resolvedValue;\n                    }\n                    if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n                        return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                    }\n                    if (isObject(mockedValue) && isObject(resolvedValue)) {\n                        // Object.assign() won't do here, as we need to all properties, including\n                        // the non-enumerable ones and defined using Object.defineProperty\n                        const emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n                        return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n                    }\n                    return undefined !== resolvedValue ? resolvedValue : mockedValue;\n                });\n            }\n            const fieldSubscriber = fieldConfig.subscribe;\n            const mockSubscriber = (..._args) => ({\n                [Symbol.asyncIterator]() {\n                    return {\n                        async next() {\n                            return {\n                                done: true,\n                                value: {},\n                            };\n                        },\n                    };\n                },\n            });\n            if (!preserveResolvers || !fieldSubscriber) {\n                newFieldConfig.subscribe = mockSubscriber;\n            }\n            else {\n                newFieldConfig.subscribe = async (rootObject, args, context, info) => {\n                    const [mockAsyncIterable, oldAsyncIterable] = await Promise.all([\n                        mockSubscriber(rootObject, args, context, info),\n                        fieldSubscriber(rootObject, args, context, info),\n                    ]);\n                    return oldAsyncIterable || mockAsyncIterable;\n                };\n            }\n            return newFieldConfig;\n        },\n    });\n}\nfunction isObject(thing) {\n    return thing === Object(thing) && !Array.isArray(thing);\n}\n// returns a random element from that ary\nfunction getRandomElement(ary) {\n    const sample = Math.floor(Math.random() * ary.length);\n    return ary[sample];\n}\nfunction mergeObjects(a, b) {\n    return Object.assign(a, b);\n}\nfunction copyOwnPropsIfNotPresent(target, source) {\n    Object.getOwnPropertyNames(source).forEach(prop => {\n        if (!Object.getOwnPropertyDescriptor(target, prop)) {\n            const propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n            Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);\n        }\n    });\n}\nfunction copyOwnProps(target, ...sources) {\n    sources.forEach(source => {\n        let chain = source;\n        while (chain != null) {\n            copyOwnPropsIfNotPresent(target, chain);\n            chain = Object.getPrototypeOf(chain);\n        }\n    });\n    return target;\n}\n// takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\nfunction mergeMocks(genericMockFunction, customMock) {\n    if (Array.isArray(customMock)) {\n        return customMock.map((el) => mergeMocks(genericMockFunction, el));\n    }\n    if (customMock instanceof Promise) {\n        return customMock.then((res) => mergeObjects(genericMockFunction(), res));\n    }\n    if (isObject(customMock)) {\n        return mergeObjects(genericMockFunction(), customMock);\n    }\n    return customMock;\n}\n/**\n * @internal\n */\nexport function isMockList(obj) {\n    if (typeof (obj === null || obj === void 0 ? void 0 : obj.len) === 'number' || (Array.isArray(obj === null || obj === void 0 ? void 0 : obj.len) && typeof (obj === null || obj === void 0 ? void 0 : obj.len[0]) === 'number')) {\n        if (typeof obj.wrappedFunction === 'undefined' || typeof obj.wrappedFunction === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * This is an object you can return from your mock resolvers which calls the\n * provided `mockFunction` once for each list item.\n */\nexport class MockList {\n    /**\n     * @param length Either the exact length of items to return or an inclusive\n     * range of possible lengths.\n     * @param mockFunction The function to call for each item in the list to\n     * resolve it. It can return another MockList or a value.\n     */\n    constructor(length, mockFunction) {\n        this.len = length;\n        if (typeof mockFunction !== 'undefined') {\n            if (typeof mockFunction !== 'function') {\n                throw new Error('Second argument to MockList must be a function or undefined');\n            }\n            this.wrappedFunction = mockFunction;\n        }\n    }\n    /**\n     * @internal\n     */\n    mock(root, args, context, info, fieldType, mockTypeFunc) {\n        let arr;\n        if (Array.isArray(this.len)) {\n            arr = new Array(this.randint(this.len[0], this.len[1]));\n        }\n        else {\n            arr = new Array(this.len);\n        }\n        for (let i = 0; i < arr.length; i++) {\n            if (typeof this.wrappedFunction === 'function') {\n                const res = this.wrappedFunction(root, args, context, info);\n                if (isMockList(res)) {\n                    const nullableType = getNullableType(fieldType.ofType);\n                    arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);\n                }\n                else {\n                    arr[i] = res;\n                }\n            }\n            else {\n                arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n            }\n        }\n        return arr;\n    }\n    randint(low, high) {\n        return Math.floor(Math.random() * (high - low + 1) + low);\n    }\n}\n//# sourceMappingURL=mocking.js.map"]},"metadata":{},"sourceType":"module"}