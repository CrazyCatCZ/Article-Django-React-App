{"ast":null,"code":"import { Kind, GraphQLDirective, valueFromASTUntyped, GraphQLInputObjectType, GraphQLScalarType, GraphQLUnionType, GraphQLEnumType, GraphQLInterfaceType, GraphQLObjectType, DirectiveLocation, TokenKind, getDirectiveValues, GraphQLDeprecatedDirective, isObjectType, isInputObjectType, isInterfaceType, isUnionType, isEnumType, isScalarType, isSchema, isNamedType, getNamedType, isSpecifiedScalarType, GraphQLSchema, isLeafType, print, specifiedDirectives, extendSchema } from 'graphql';\nimport { createStub, createNamedStub, fieldToFieldConfig, inputFieldToFieldConfig, parseSelectionSet, parseFragmentToInlineFragment, concatInlineFragments, rewireTypes, mergeDeep, SchemaDirectiveVisitor, pruneSchema } from '@graphql-tools/utils';\nimport { buildDocumentFromTypeDefinitions, extendResolversFromInterfaces, addResolversToSchema, assertResolversPresent, addCatchUndefinedToSchema, addErrorLoggingToSchema, addSchemaLevelResolver, attachDirectiveResolvers } from '@graphql-tools/schema';\nimport { wrapSchema } from '@graphql-tools/wrap';\nimport { isSubschemaConfig, delegateToSchema } from '@graphql-tools/delegate';\nimport { mergeType, mergeInputType, mergeInterface, mergeUnion, mergeEnum } from '@graphql-tools/merge';\nimport { batchDelegateToSchema } from '@graphql-tools/batch-delegate';\n\nfunction extractTypeDefinitions(ast) {\n  const typeDefs = ast.definitions.filter(def => def.kind === Kind.OBJECT_TYPE_DEFINITION || def.kind === Kind.INTERFACE_TYPE_DEFINITION || def.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION || def.kind === Kind.UNION_TYPE_DEFINITION || def.kind === Kind.ENUM_TYPE_DEFINITION || def.kind === Kind.SCALAR_TYPE_DEFINITION);\n  return { ...ast,\n    definitions: typeDefs\n  };\n}\n\nfunction extractDirectiveDefinitions(ast) {\n  const directiveDefs = ast.definitions.filter(def => def.kind === Kind.DIRECTIVE_DEFINITION);\n  return { ...ast,\n    definitions: directiveDefs\n  };\n}\n\nfunction extractSchemaDefinition(ast) {\n  const schemaDefs = ast.definitions.filter(def => def.kind === Kind.SCHEMA_DEFINITION);\n  return schemaDefs.length ? schemaDefs[schemaDefs.length - 1] : null;\n}\n\nfunction extractSchemaExtensions(ast) {\n  const schemaExtensions = ast.definitions.filter(def => def.kind === Kind.SCHEMA_EXTENSION);\n  return schemaExtensions;\n}\n\nfunction extractTypeExtensionDefinitions(ast) {\n  const extensionDefs = ast.definitions.filter(def => def.kind === Kind.OBJECT_TYPE_EXTENSION || def.kind === Kind.INTERFACE_TYPE_EXTENSION || def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION || def.kind === Kind.UNION_TYPE_EXTENSION || def.kind === Kind.ENUM_TYPE_EXTENSION || def.kind === Kind.SCALAR_TYPE_EXTENSION);\n  return { ...ast,\n    definitions: extensionDefs\n  };\n}\n\nconst backcompatOptions = {\n  commentDescriptions: true\n};\n\nfunction typeFromAST(node) {\n  switch (node.kind) {\n    case Kind.OBJECT_TYPE_DEFINITION:\n      return makeObjectType(node);\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n      return makeInterfaceType(node);\n\n    case Kind.ENUM_TYPE_DEFINITION:\n      return makeEnumType(node);\n\n    case Kind.UNION_TYPE_DEFINITION:\n      return makeUnionType(node);\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n      return makeScalarType(node);\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n      return makeInputObjectType(node);\n\n    case Kind.DIRECTIVE_DEFINITION:\n      return makeDirective(node);\n\n    default:\n      return null;\n  }\n}\n\nfunction makeObjectType(node) {\n  const config = {\n    name: node.name.value,\n    description: getDescription(node, backcompatOptions),\n    interfaces: () => node.interfaces.map(iface => createNamedStub(iface.name.value, 'interface')),\n    fields: () => makeFields(node.fields),\n    astNode: node\n  };\n  return new GraphQLObjectType(config);\n}\n\nfunction makeInterfaceType(node) {\n  var _a;\n\n  const config = {\n    name: node.name.value,\n    description: getDescription(node, backcompatOptions),\n    interfaces: (_a = node.interfaces) === null || _a === void 0 ? void 0 : _a.map(iface => createNamedStub(iface.name.value, 'interface')),\n    fields: () => makeFields(node.fields),\n    astNode: node\n  };\n  return new GraphQLInterfaceType(config);\n}\n\nfunction makeEnumType(node) {\n  const values = node.values.reduce((prev, value) => ({ ...prev,\n    [value.name.value]: {\n      description: getDescription(value, backcompatOptions),\n      deprecationReason: getDeprecationReason(value),\n      astNode: value\n    }\n  }), {});\n  return new GraphQLEnumType({\n    name: node.name.value,\n    description: getDescription(node, backcompatOptions),\n    values,\n    astNode: node\n  });\n}\n\nfunction makeUnionType(node) {\n  return new GraphQLUnionType({\n    name: node.name.value,\n    description: getDescription(node, backcompatOptions),\n    types: () => node.types.map(type => createNamedStub(type.name.value, 'object')),\n    astNode: node\n  });\n}\n\nfunction makeScalarType(node) {\n  return new GraphQLScalarType({\n    name: node.name.value,\n    description: getDescription(node, backcompatOptions),\n    astNode: node,\n    // TODO: serialize default property setting can be dropped once\n    // upstream graphql-js TypeScript typings are updated, likely in v16\n    serialize: value => value\n  });\n}\n\nfunction makeInputObjectType(node) {\n  return new GraphQLInputObjectType({\n    name: node.name.value,\n    description: getDescription(node, backcompatOptions),\n    fields: () => makeValues(node.fields),\n    astNode: node\n  });\n}\n\nfunction makeFields(nodes) {\n  return nodes.reduce((prev, node) => ({ ...prev,\n    [node.name.value]: {\n      type: createStub(node.type, 'output'),\n      description: getDescription(node, backcompatOptions),\n      args: makeValues(node.arguments),\n      deprecationReason: getDeprecationReason(node),\n      astNode: node\n    }\n  }), {});\n}\n\nfunction makeValues(nodes) {\n  return nodes.reduce((prev, node) => ({ ...prev,\n    [node.name.value]: {\n      type: createStub(node.type, 'input'),\n      defaultValue: node.defaultValue !== undefined ? valueFromASTUntyped(node.defaultValue) : undefined,\n      description: getDescription(node, backcompatOptions),\n      astNode: node\n    }\n  }), {});\n}\n\nfunction makeDirective(node) {\n  const locations = [];\n  node.locations.forEach(location => {\n    if (location.value in DirectiveLocation) {\n      locations.push(location.value);\n    }\n  });\n  return new GraphQLDirective({\n    name: node.name.value,\n    description: node.description != null ? node.description.value : null,\n    locations,\n    isRepeatable: node.repeatable,\n    args: makeValues(node.arguments),\n    astNode: node\n  });\n} // graphql < v13 does not export getDescription\n\n\nfunction getDescription(node, options) {\n  if (node.description != null) {\n    return node.description.value;\n  }\n\n  if (options.commentDescriptions) {\n    const rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue(`\\n${rawValue}`);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  const loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  const comments = [];\n  let token = loc.startToken.prev;\n\n  while (token != null && token.kind === TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    const value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  const lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  const commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (let i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\n\n\nfunction getBlockStringIndentation(lines) {\n  let commonIndent = null;\n\n  for (let i = 1; i < lines.length; i++) {\n    const line = lines[i];\n    const indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  let i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n\nfunction getDeprecationReason(node) {\n  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n\nfunction mergeCandidates(typeName, candidates, typeMergingOptions) {\n  const initialCandidateType = candidates[0].type;\n\n  if (candidates.some(candidate => candidate.type.constructor !== initialCandidateType.constructor)) {\n    throw new Error(`Cannot merge different type categories into common type ${typeName}.`);\n  }\n\n  if (isObjectType(initialCandidateType)) {\n    return mergeObjectTypeCandidates(typeName, candidates, typeMergingOptions);\n  } else if (isInputObjectType(initialCandidateType)) {\n    return mergeInputObjectTypeCandidates(typeName, candidates, typeMergingOptions);\n  } else if (isInterfaceType(initialCandidateType)) {\n    return mergeInterfaceTypeCandidates(typeName, candidates, typeMergingOptions);\n  } else if (isUnionType(initialCandidateType)) {\n    return mergeUnionTypeCandidates(typeName, candidates, typeMergingOptions);\n  } else if (isEnumType(initialCandidateType)) {\n    return mergeEnumTypeCandidates(typeName, candidates, typeMergingOptions);\n  } else if (isScalarType(initialCandidateType)) {\n    return mergeScalarTypeCandidates(typeName, candidates, typeMergingOptions);\n  } else {\n    // not reachable.\n    throw new Error(`Type ${typeName} has unknown GraphQL type.`);\n  }\n}\n\nfunction mergeObjectTypeCandidates(typeName, candidates, typeMergingOptions) {\n  const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n  const fields = fieldConfigMapFromTypeCandidates(candidates, typeMergingOptions);\n  const typeConfigs = candidates.map(candidate => candidate.type.toConfig());\n  const interfaceMap = typeConfigs.map(typeConfig => typeConfig.interfaces).reduce((acc, interfaces) => {\n    if (interfaces != null) {\n      interfaces.forEach(iface => {\n        acc[iface.name] = iface;\n      });\n    }\n\n    return acc;\n  }, Object.create(null));\n  const interfaces = Object.keys(interfaceMap).map(interfaceName => interfaceMap[interfaceName]);\n  const astNodes = pluck('astNode', candidates);\n  const astNode = astNodes.slice(1).reduce((acc, astNode) => mergeType(astNode, acc), astNodes[0]);\n  const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n  const extensions = Object.assign({}, ...pluck('extensions', candidates));\n  const typeConfig = {\n    name: typeName,\n    description,\n    fields,\n    interfaces,\n    astNode,\n    extensionASTNodes,\n    extensions\n  };\n  return new GraphQLObjectType(typeConfig);\n}\n\nfunction mergeInputObjectTypeCandidates(typeName, candidates, typeMergingOptions) {\n  const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n  const fields = inputFieldConfigMapFromTypeCandidates(candidates, typeMergingOptions);\n  const astNodes = pluck('astNode', candidates);\n  const astNode = astNodes.slice(1).reduce((acc, astNode) => mergeInputType(astNode, acc), astNodes[0]);\n  const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n  const extensions = Object.assign({}, ...pluck('extensions', candidates));\n  const typeConfig = {\n    name: typeName,\n    description,\n    fields,\n    astNode,\n    extensionASTNodes,\n    extensions\n  };\n  return new GraphQLInputObjectType(typeConfig);\n}\n\nfunction pluck(typeProperty, candidates) {\n  return candidates.map(candidate => candidate.type[typeProperty]).filter(value => value != null);\n}\n\nfunction mergeInterfaceTypeCandidates(typeName, candidates, typeMergingOptions) {\n  const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n  const fields = fieldConfigMapFromTypeCandidates(candidates, typeMergingOptions);\n  const typeConfigs = candidates.map(candidate => candidate.type.toConfig());\n  const interfaceMap = typeConfigs.map(typeConfig => typeConfig.interfaces).reduce((acc, interfaces) => {\n    if (interfaces != null) {\n      interfaces.forEach(iface => {\n        acc[iface.name] = iface;\n      });\n    }\n\n    return acc;\n  }, Object.create(null));\n  const interfaces = Object.keys(interfaceMap).map(interfaceName => interfaceMap[interfaceName]);\n  const astNodes = pluck('astNode', candidates);\n  const astNode = astNodes.slice(1).reduce((acc, astNode) => mergeInterface(astNode, acc, {}), astNodes[0]);\n  const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n  const extensions = Object.assign({}, ...pluck('extensions', candidates));\n  const typeConfig = {\n    name: typeName,\n    description,\n    fields,\n    interfaces,\n    astNode,\n    extensionASTNodes,\n    extensions\n  };\n  return new GraphQLInterfaceType(typeConfig);\n}\n\nfunction mergeUnionTypeCandidates(typeName, candidates, typeMergingOptions) {\n  const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n  const typeConfigs = candidates.map(candidate => candidate.type.toConfig());\n  const typeMap = typeConfigs.reduce((acc, typeConfig) => {\n    typeConfig.types.forEach(type => {\n      acc[type.name] = type;\n    });\n    return acc;\n  }, Object.create(null));\n  const types = Object.keys(typeMap).map(typeName => typeMap[typeName]);\n  const astNodes = pluck('astNode', candidates);\n  const astNode = astNodes.slice(1).reduce((acc, astNode) => mergeUnion(astNode, acc), astNodes[0]);\n  const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n  const extensions = Object.assign({}, ...pluck('extensions', candidates));\n  const typeConfig = {\n    name: typeName,\n    description,\n    types,\n    astNode,\n    extensionASTNodes,\n    extensions\n  };\n  return new GraphQLUnionType(typeConfig);\n}\n\nfunction mergeEnumTypeCandidates(typeName, candidates, typeMergingOptions) {\n  const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n  const typeConfigs = candidates.map(candidate => candidate.type.toConfig());\n  const values = typeConfigs.reduce((acc, typeConfig) => ({ ...acc,\n    ...typeConfig.values\n  }), {});\n  const astNodes = pluck('astNode', candidates);\n  const astNode = astNodes.slice(1).reduce((acc, astNode) => mergeEnum(astNode, acc), astNodes[0]);\n  const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n  const extensions = Object.assign({}, ...pluck('extensions', candidates));\n  const typeConfig = {\n    name: typeName,\n    description,\n    values,\n    astNode,\n    extensionASTNodes,\n    extensions\n  };\n  return new GraphQLEnumType(typeConfig);\n}\n\nfunction mergeScalarTypeCandidates(typeName, candidates, typeMergingOptions) {\n  const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n  const serializeFns = pluck('serialize', candidates);\n  const serialize = serializeFns[serializeFns.length - 1];\n  const parseValueFns = pluck('parseValue', candidates);\n  const parseValue = parseValueFns[parseValueFns.length - 1];\n  const parseLiteralFns = pluck('parseLiteral', candidates);\n  const parseLiteral = parseLiteralFns[parseLiteralFns.length - 1];\n  const astNodes = pluck('astNode', candidates);\n  const astNode = astNodes.slice(1).reduce((acc, astNode) => mergeScalarTypeDefinitionNodes(acc, astNode), astNodes[0]);\n  const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n  const extensions = Object.assign({}, ...pluck('extensions', candidates));\n  const typeConfig = {\n    name: typeName,\n    description,\n    serialize,\n    parseValue,\n    parseLiteral,\n    astNode,\n    extensionASTNodes,\n    extensions\n  };\n  return new GraphQLScalarType(typeConfig);\n}\n\nfunction mergeTypeDescriptions(candidates, typeMergingOptions) {\n  var _a;\n\n  const typeDescriptionsMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.typeDescriptionsMerger) !== null && _a !== void 0 ? _a : defaultTypeDescriptionMerger;\n  return typeDescriptionsMerger(candidates);\n}\n\nfunction defaultTypeDescriptionMerger(candidates) {\n  return candidates[candidates.length - 1].type.description;\n}\n\nfunction fieldConfigMapFromTypeCandidates(candidates, typeMergingOptions) {\n  const fieldConfigCandidatesMap = Object.create(null);\n  candidates.forEach(candidate => {\n    const fieldMap = candidate.type.getFields();\n    Object.keys(fieldMap).forEach(fieldName => {\n      const fieldConfigCandidate = {\n        fieldConfig: fieldToFieldConfig(fieldMap[fieldName]),\n        fieldName,\n        type: candidate.type,\n        subschema: candidate.subschema,\n        transformedSchema: candidate.transformedSchema\n      };\n\n      if (fieldName in fieldConfigCandidatesMap) {\n        fieldConfigCandidatesMap[fieldName].push(fieldConfigCandidate);\n      } else {\n        fieldConfigCandidatesMap[fieldName] = [fieldConfigCandidate];\n      }\n    });\n  });\n  const fieldConfigMap = Object.create(null);\n  Object.keys(fieldConfigCandidatesMap).forEach(fieldName => {\n    fieldConfigMap[fieldName] = mergeFieldConfigs(fieldConfigCandidatesMap[fieldName], typeMergingOptions);\n  });\n  return fieldConfigMap;\n}\n\nfunction mergeFieldConfigs(candidates, typeMergingOptions) {\n  var _a;\n\n  const fieldConfigMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.fieldConfigMerger) !== null && _a !== void 0 ? _a : defaultFieldConfigMerger;\n  return fieldConfigMerger(candidates);\n}\n\nfunction defaultFieldConfigMerger(candidates) {\n  return candidates[candidates.length - 1].fieldConfig;\n}\n\nfunction inputFieldConfigMapFromTypeCandidates(candidates, typeMergingOptions) {\n  const inputFieldConfigCandidatesMap = Object.create(null);\n  candidates.forEach(candidate => {\n    const inputFieldMap = candidate.type.getFields();\n    Object.keys(inputFieldMap).forEach(fieldName => {\n      const inputFieldConfigCandidate = {\n        inputFieldConfig: inputFieldToFieldConfig(inputFieldMap[fieldName]),\n        fieldName,\n        type: candidate.type,\n        subschema: candidate.subschema,\n        transformedSchema: candidate.transformedSchema\n      };\n\n      if (fieldName in inputFieldConfigCandidatesMap) {\n        inputFieldConfigCandidatesMap[fieldName].push(inputFieldConfigCandidate);\n      } else {\n        inputFieldConfigCandidatesMap[fieldName] = [inputFieldConfigCandidate];\n      }\n    });\n  });\n  const inputFieldConfigMap = Object.create(null);\n  Object.keys(inputFieldConfigCandidatesMap).forEach(fieldName => {\n    inputFieldConfigMap[fieldName] = mergeInputFieldConfigs(inputFieldConfigCandidatesMap[fieldName], typeMergingOptions);\n  });\n  return inputFieldConfigMap;\n}\n\nfunction mergeInputFieldConfigs(candidates, typeMergingOptions) {\n  var _a;\n\n  const inputFieldConfigMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.inputFieldConfigMerger) !== null && _a !== void 0 ? _a : defaultInputFieldConfigMerger;\n  return inputFieldConfigMerger(candidates);\n}\n\nfunction defaultInputFieldConfigMerger(candidates) {\n  return candidates[candidates.length - 1].inputFieldConfig;\n}\n\nfunction mergeScalarTypeDefinitionNodes(targetNode, sourceNode) {\n  var _a, _b, _c;\n\n  return { ...targetNode,\n    description: (_a = sourceNode.description) !== null && _a !== void 0 ? _a : targetNode.description,\n    directives: ((_b = targetNode.directives) !== null && _b !== void 0 ? _b : []).concat((_c = sourceNode.directives) !== null && _c !== void 0 ? _c : [])\n  };\n}\n\nfunction isDocumentNode(schemaLikeObject) {\n  return schemaLikeObject.kind !== undefined;\n}\n\nfunction buildTypeCandidates({\n  schemaLikeObjects,\n  transformedSchemas,\n  extensions,\n  directiveMap,\n  schemaDefs,\n  operationTypeNames,\n  mergeDirectives\n}) {\n  const typeCandidates = Object.create(null);\n  let schemaDef;\n  let schemaExtensions = [];\n  schemaLikeObjects.forEach(schemaLikeObject => {\n    if (isDocumentNode(schemaLikeObject)) {\n      schemaDef = extractSchemaDefinition(schemaLikeObject);\n      schemaExtensions = schemaExtensions.concat(extractSchemaExtensions(schemaLikeObject));\n    }\n  });\n  schemaDefs.schemaDef = schemaDef;\n  schemaDefs.schemaExtensions = schemaExtensions;\n  setOperationTypeNames(schemaDefs, operationTypeNames);\n  schemaLikeObjects.forEach(schemaLikeObject => {\n    if (isSchema(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {\n      const schema = wrapSchema(schemaLikeObject);\n      transformedSchemas.set(schemaLikeObject, schema);\n      const operationTypes = {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType()\n      };\n      Object.keys(operationTypes).forEach(operationType => {\n        if (operationTypes[operationType] != null) {\n          addTypeCandidate(typeCandidates, operationTypeNames[operationType], {\n            type: operationTypes[operationType],\n            subschema: schemaLikeObject,\n            transformedSchema: schema\n          });\n        }\n      });\n\n      if (mergeDirectives) {\n        schema.getDirectives().forEach(directive => {\n          directiveMap[directive.name] = directive;\n        });\n      }\n\n      const originalTypeMap = schema.getTypeMap();\n      Object.keys(originalTypeMap).forEach(typeName => {\n        const type = originalTypeMap[typeName];\n\n        if (isNamedType(type) && getNamedType(type).name.slice(0, 2) !== '__' && type !== operationTypes.query && type !== operationTypes.mutation && type !== operationTypes.subscription) {\n          addTypeCandidate(typeCandidates, type.name, {\n            type,\n            subschema: schemaLikeObject,\n            transformedSchema: schema\n          });\n        }\n      });\n    } else if (isDocumentNode(schemaLikeObject)) {\n      const typesDocument = extractTypeDefinitions(schemaLikeObject);\n      typesDocument.definitions.forEach(def => {\n        const type = typeFromAST(def);\n\n        if (type != null) {\n          addTypeCandidate(typeCandidates, type.name, {\n            type\n          });\n        }\n      });\n      const directivesDocument = extractDirectiveDefinitions(schemaLikeObject);\n      directivesDocument.definitions.forEach(def => {\n        const directive = typeFromAST(def);\n        directiveMap[directive.name] = directive;\n      });\n      const extensionsDocument = extractTypeExtensionDefinitions(schemaLikeObject);\n\n      if (extensionsDocument.definitions.length > 0) {\n        extensions.push(extensionsDocument);\n      }\n    } else if (isNamedType(schemaLikeObject)) {\n      addTypeCandidate(typeCandidates, schemaLikeObject.name, {\n        type: schemaLikeObject\n      });\n    } else {\n      throw new Error(`Invalid object ${schemaLikeObject}`);\n    }\n  });\n  return typeCandidates;\n}\n\nfunction setOperationTypeNames({\n  schemaDef,\n  schemaExtensions\n}, operationTypeNames) {\n  const allNodes = schemaExtensions.slice();\n\n  if (schemaDef != null) {\n    allNodes.unshift(schemaDef);\n  }\n\n  allNodes.forEach(node => {\n    if (node.operationTypes != null) {\n      node.operationTypes.forEach(operationType => {\n        operationTypeNames[operationType.operation] = operationType.type.name.value;\n      });\n    }\n  });\n}\n\nfunction addTypeCandidate(typeCandidates, name, typeCandidate) {\n  if (!(name in typeCandidates)) {\n    typeCandidates[name] = [];\n  }\n\n  typeCandidates[name].push(typeCandidate);\n}\n\nfunction buildTypeMap({\n  typeCandidates,\n  stitchingInfo,\n  operationTypeNames,\n  onTypeConflict,\n  mergeTypes,\n  typeMergingOptions\n}) {\n  const typeMap = Object.create(null);\n  Object.keys(typeCandidates).forEach(typeName => {\n    if (typeName === operationTypeNames.query || typeName === operationTypeNames.mutation || typeName === operationTypeNames.subscription || mergeTypes === true && !typeCandidates[typeName].some(candidate => isSpecifiedScalarType(candidate.type)) || typeof mergeTypes === 'function' && mergeTypes(typeCandidates[typeName], typeName) || Array.isArray(mergeTypes) && mergeTypes.includes(typeName) || stitchingInfo != null && typeName in stitchingInfo.mergedTypes) {\n      typeMap[typeName] = mergeCandidates(typeName, typeCandidates[typeName], typeMergingOptions);\n    } else {\n      const candidateSelector = onTypeConflict != null ? onTypeConflictToCandidateSelector(onTypeConflict) : cands => cands[cands.length - 1];\n      typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;\n    }\n  });\n  return typeMap;\n}\n\nfunction onTypeConflictToCandidateSelector(onTypeConflict) {\n  return cands => cands.reduce((prev, next) => {\n    const type = onTypeConflict(prev.type, next.type, {\n      left: {\n        schema: prev.transformedSchema\n      },\n      right: {\n        schema: next.transformedSchema\n      }\n    });\n\n    if (prev.type === type) {\n      return prev;\n    } else if (next.type === type) {\n      return next;\n    }\n\n    return {\n      schemaName: 'unknown',\n      type\n    };\n  });\n}\n\nfunction createStitchingInfo(transformedSchemas, typeCandidates, mergeTypes) {\n  const mergedTypes = createMergedTypes(typeCandidates, mergeTypes);\n  const selectionSetsByField = Object.create(null);\n  Object.entries(mergedTypes).forEach(([typeName, mergedTypeInfo]) => {\n    if (mergedTypeInfo.selectionSets == null && mergedTypeInfo.fieldSelectionSets == null) {\n      return;\n    }\n\n    selectionSetsByField[typeName] = Object.create(null);\n    mergedTypeInfo.selectionSets.forEach((selectionSet, subschemaConfig) => {\n      const schema = subschemaConfig.schema;\n      const type = schema.getType(typeName);\n      const fields = type.getFields();\n      Object.keys(fields).forEach(fieldName => {\n        const field = fields[fieldName];\n        const fieldType = getNamedType(field.type);\n\n        if (selectionSet && isLeafType(fieldType) && selectionSetContainsTopLevelField(selectionSet, fieldName)) {\n          return;\n        }\n\n        if (selectionSetsByField[typeName][fieldName] == null) {\n          selectionSetsByField[typeName][fieldName] = {\n            kind: Kind.SELECTION_SET,\n            selections: [parseSelectionSet('{ __typename }').selections[0]]\n          };\n        }\n\n        selectionSetsByField[typeName][fieldName].selections = selectionSetsByField[typeName][fieldName].selections.concat(selectionSet.selections);\n      });\n    });\n    mergedTypeInfo.fieldSelectionSets.forEach(selectionSetFieldMap => {\n      Object.keys(selectionSetFieldMap).forEach(fieldName => {\n        if (selectionSetsByField[typeName][fieldName] == null) {\n          selectionSetsByField[typeName][fieldName] = {\n            kind: Kind.SELECTION_SET,\n            selections: [parseSelectionSet('{ __typename }').selections[0]]\n          };\n        }\n\n        selectionSetsByField[typeName][fieldName].selections = selectionSetsByField[typeName][fieldName].selections.concat(selectionSetFieldMap[fieldName].selections);\n      });\n    });\n  });\n  return {\n    transformedSchemas,\n    fragmentsByField: undefined,\n    selectionSetsByField,\n    dynamicSelectionSetsByField: undefined,\n    mergedTypes\n  };\n}\n\nfunction createMergedTypes(typeCandidates, mergeTypes) {\n  const mergedTypes = Object.create(null);\n  Object.keys(typeCandidates).forEach(typeName => {\n    if (typeCandidates[typeName].length > 1 && (isObjectType(typeCandidates[typeName][0].type) || isInterfaceType(typeCandidates[typeName][0].type))) {\n      const typeCandidatesWithMergedTypeConfig = typeCandidates[typeName].filter(typeCandidate => typeCandidate.subschema != null && isSubschemaConfig(typeCandidate.subschema) && typeCandidate.subschema.merge != null && typeName in typeCandidate.subschema.merge);\n\n      if (mergeTypes === true || typeof mergeTypes === 'function' && mergeTypes(typeCandidates[typeName], typeName) || Array.isArray(mergeTypes) && mergeTypes.includes(typeName) || typeCandidatesWithMergedTypeConfig.length) {\n        const targetSubschemas = [];\n        const typeMaps = new Map();\n        const supportedBySubschemas = Object.create({});\n        const selectionSets = new Map();\n        const fieldSelectionSets = new Map();\n        typeCandidates[typeName].forEach(typeCandidate => {\n          var _a;\n\n          const subschema = typeCandidate.subschema;\n\n          if (subschema == null) {\n            return;\n          }\n\n          typeMaps.set(subschema, typeCandidate.transformedSchema.getTypeMap());\n\n          if (!isSubschemaConfig(subschema)) {\n            return;\n          }\n\n          const mergedTypeConfig = (_a = subschema === null || subschema === void 0 ? void 0 : subschema.merge) === null || _a === void 0 ? void 0 : _a[typeName];\n\n          if (mergedTypeConfig == null) {\n            return;\n          }\n\n          if (mergedTypeConfig.selectionSet) {\n            const selectionSet = parseSelectionSet(mergedTypeConfig.selectionSet);\n            selectionSets.set(subschema, selectionSet);\n          }\n\n          if (mergedTypeConfig.fields) {\n            const parsedFieldSelectionSets = Object.create(null);\n            Object.keys(mergedTypeConfig.fields).forEach(fieldName => {\n              if (mergedTypeConfig.fields[fieldName].selectionSet) {\n                const rawFieldSelectionSet = mergedTypeConfig.fields[fieldName].selectionSet;\n                parsedFieldSelectionSets[fieldName] = parseSelectionSet(rawFieldSelectionSet);\n              }\n            });\n            fieldSelectionSets.set(subschema, parsedFieldSelectionSets);\n          }\n\n          if (mergedTypeConfig.resolve != null) {\n            targetSubschemas.push(subschema);\n          } else if (mergedTypeConfig.key != null) {\n            mergedTypeConfig.resolve = (originalResult, context, info, subschema, selectionSet) => {\n              var _a;\n\n              return batchDelegateToSchema({\n                schema: subschema,\n                operation: 'query',\n                fieldName: mergedTypeConfig.fieldName,\n                key: mergedTypeConfig.key(originalResult),\n                argsFromKeys: (_a = mergedTypeConfig.argsFromKeys) !== null && _a !== void 0 ? _a : mergedTypeConfig.args,\n                valuesFromResults: mergedTypeConfig.valuesFromResults,\n                selectionSet,\n                context,\n                info,\n                skipTypeMerging: true\n              });\n            };\n\n            targetSubschemas.push(subschema);\n          } else if (mergedTypeConfig.fieldName != null) {\n            mergedTypeConfig.resolve = (originalResult, context, info, subschema, selectionSet) => delegateToSchema({\n              schema: subschema,\n              operation: 'query',\n              fieldName: mergedTypeConfig.fieldName,\n              returnType: getNamedType(info.returnType),\n              args: mergedTypeConfig.args(originalResult),\n              selectionSet,\n              context,\n              info,\n              skipTypeMerging: true\n            });\n\n            targetSubschemas.push(subschema);\n          }\n\n          if (mergedTypeConfig.resolve == null) {\n            return;\n          }\n\n          const type = typeCandidate.transformedSchema.getType(typeName);\n          const fieldMap = type.getFields();\n          const selectionSet = selectionSets.get(subschema);\n          Object.keys(fieldMap).forEach(fieldName => {\n            const field = fieldMap[fieldName];\n            const fieldType = getNamedType(field.type);\n\n            if (selectionSet && isLeafType(fieldType) && selectionSetContainsTopLevelField(selectionSet, fieldName)) {\n              return;\n            }\n\n            if (!(fieldName in supportedBySubschemas)) {\n              supportedBySubschemas[fieldName] = [];\n            }\n\n            supportedBySubschemas[fieldName].push(subschema);\n          });\n        });\n        const sourceSubschemas = typeCandidates[typeName].filter(typeCandidate => typeCandidate.subschema != null).map(typeCandidate => typeCandidate.subschema);\n        const targetSubschemasBySubschema = new Map();\n        sourceSubschemas.forEach(subschema => {\n          const filteredSubschemas = targetSubschemas.filter(s => s !== subschema);\n\n          if (filteredSubschemas.length) {\n            targetSubschemasBySubschema.set(subschema, filteredSubschemas);\n          }\n        });\n        mergedTypes[typeName] = {\n          typeName,\n          targetSubschemas: targetSubschemasBySubschema,\n          typeMaps,\n          selectionSets,\n          fieldSelectionSets,\n          uniqueFields: Object.create({}),\n          nonUniqueFields: Object.create({})\n        };\n        Object.keys(supportedBySubschemas).forEach(fieldName => {\n          if (supportedBySubschemas[fieldName].length === 1) {\n            mergedTypes[typeName].uniqueFields[fieldName] = supportedBySubschemas[fieldName][0];\n          } else {\n            mergedTypes[typeName].nonUniqueFields[fieldName] = supportedBySubschemas[fieldName];\n          }\n        });\n      }\n    }\n  });\n  return mergedTypes;\n}\n\nfunction completeStitchingInfo(stitchingInfo, resolvers) {\n  const selectionSetsByField = stitchingInfo.selectionSetsByField;\n  const dynamicSelectionSetsByField = Object.create(null);\n  const rawFragments = [];\n  Object.keys(resolvers).forEach(typeName => {\n    const type = resolvers[typeName];\n\n    if (isScalarType(type)) {\n      return;\n    }\n\n    Object.keys(type).forEach(fieldName => {\n      const field = type[fieldName];\n\n      if (field.selectionSet) {\n        if (typeof field.selectionSet === 'function') {\n          if (!(typeName in dynamicSelectionSetsByField)) {\n            dynamicSelectionSetsByField[typeName] = Object.create(null);\n          }\n\n          if (!(fieldName in dynamicSelectionSetsByField[typeName])) {\n            dynamicSelectionSetsByField[typeName][fieldName] = [];\n          }\n\n          dynamicSelectionSetsByField[typeName][fieldName].push(field.selectionSet);\n        } else {\n          const selectionSet = parseSelectionSet(field.selectionSet);\n\n          if (!(typeName in selectionSetsByField)) {\n            selectionSetsByField[typeName] = Object.create(null);\n          }\n\n          if (!(fieldName in selectionSetsByField[typeName])) {\n            selectionSetsByField[typeName][fieldName] = {\n              kind: Kind.SELECTION_SET,\n              selections: []\n            };\n          }\n\n          selectionSetsByField[typeName][fieldName].selections = selectionSetsByField[typeName][fieldName].selections.concat(selectionSet.selections);\n        }\n      }\n\n      if (field.fragment) {\n        rawFragments.push({\n          field: fieldName,\n          fragment: field.fragment\n        });\n      }\n    });\n  });\n  Object.keys(selectionSetsByField).forEach(typeName => {\n    const typeSelectionSets = selectionSetsByField[typeName];\n    Object.keys(typeSelectionSets).forEach(fieldName => {\n      const consolidatedSelections = new Map();\n      const selectionSet = typeSelectionSets[fieldName];\n      selectionSet.selections.forEach(selection => {\n        consolidatedSelections.set(print(selection), selection);\n      });\n      selectionSet.selections = Array.from(consolidatedSelections.values());\n    });\n  });\n  const parsedFragments = Object.create(null);\n  rawFragments.forEach(({\n    field,\n    fragment\n  }) => {\n    const parsedFragment = parseFragmentToInlineFragment(fragment);\n    const actualTypeName = parsedFragment.typeCondition.name.value;\n\n    if (!(actualTypeName in parsedFragments)) {\n      parsedFragments[actualTypeName] = Object.create(null);\n    }\n\n    if (!(field in parsedFragments[actualTypeName])) {\n      parsedFragments[actualTypeName][field] = [];\n    }\n\n    parsedFragments[actualTypeName][field].push(parsedFragment);\n  });\n  const fragmentsByField = Object.create(null);\n  Object.keys(parsedFragments).forEach(typeName => {\n    Object.keys(parsedFragments[typeName]).forEach(field => {\n      if (!(typeName in fragmentsByField)) {\n        fragmentsByField[typeName] = Object.create(null);\n      }\n\n      fragmentsByField[typeName][field] = concatInlineFragments(typeName, parsedFragments[typeName][field]);\n    });\n  });\n  stitchingInfo.selectionSetsByField = selectionSetsByField;\n  stitchingInfo.dynamicSelectionSetsByField = dynamicSelectionSetsByField;\n  stitchingInfo.fragmentsByField = fragmentsByField;\n  return stitchingInfo;\n}\n\nfunction addStitchingInfo(stitchedSchema, stitchingInfo) {\n  return new GraphQLSchema({ ...stitchedSchema.toConfig(),\n    extensions: { ...stitchedSchema.extensions,\n      stitchingInfo\n    }\n  });\n}\n\nfunction selectionSetContainsTopLevelField(selectionSet, fieldName) {\n  return selectionSet.selections.some(selection => selection.kind === Kind.FIELD && selection.name.value === fieldName);\n}\n\nfunction stitchSchemas({\n  subschemas = [],\n  types = [],\n  typeDefs,\n  schemas = [],\n  onTypeConflict,\n  mergeDirectives,\n  mergeTypes = false,\n  typeMergingOptions,\n  resolvers = {},\n  schemaDirectives,\n  inheritResolversFromInterfaces = false,\n  logger,\n  allowUndefinedInResolve = true,\n  resolverValidationOptions = {},\n  directiveResolvers,\n  schemaTransforms = [],\n  parseOptions = {},\n  pruningOptions\n}) {\n  if (typeof resolverValidationOptions !== 'object') {\n    throw new Error('Expected `resolverValidationOptions` to be an object');\n  }\n\n  let schemaLikeObjects = [];\n  subschemas.forEach(subschemaOrSubschemaArray => {\n    if (Array.isArray(subschemaOrSubschemaArray)) {\n      schemaLikeObjects = schemaLikeObjects.concat(subschemaOrSubschemaArray);\n    } else {\n      schemaLikeObjects.push(subschemaOrSubschemaArray);\n    }\n  });\n  schemas.forEach(schemaLikeObject => {\n    if (!isSchema(schemaLikeObject) && !isSubschemaConfig(schemaLikeObject) && typeof schemaLikeObject !== 'string' && !isDocumentNode$1(schemaLikeObject) && !Array.isArray(schemaLikeObject)) {\n      throw new Error('Invalid schema passed');\n    }\n  });\n  schemas.forEach(schemaLikeObject => {\n    if (isSchema(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {\n      schemaLikeObjects.push(schemaLikeObject);\n    }\n  });\n\n  if (typeDefs && !Array.isArray(typeDefs) || Array.isArray(typeDefs) && typeDefs.length) {\n    schemaLikeObjects.push(buildDocumentFromTypeDefinitions(typeDefs, parseOptions));\n  }\n\n  schemas.forEach(schemaLikeObject => {\n    if (typeof schemaLikeObject === 'string' || isDocumentNode$1(schemaLikeObject)) {\n      schemaLikeObjects.push(buildDocumentFromTypeDefinitions(schemaLikeObject, parseOptions));\n    }\n  });\n\n  if (types != null) {\n    schemaLikeObjects = schemaLikeObjects.concat(types);\n  }\n\n  schemas.forEach(schemaLikeObject => {\n    if (Array.isArray(schemaLikeObject)) {\n      schemaLikeObjects = schemaLikeObjects.concat(schemaLikeObject);\n    }\n  });\n  const transformedSchemas = new Map();\n  const extensions = [];\n  const directives = [];\n  const directiveMap = specifiedDirectives.reduce((acc, directive) => {\n    acc[directive.name] = directive;\n    return acc;\n  }, Object.create(null));\n  const schemaDefs = Object.create(null);\n  const operationTypeNames = {\n    query: 'Query',\n    mutation: 'Mutation',\n    subscription: 'Subscription'\n  };\n  const typeCandidates = buildTypeCandidates({\n    schemaLikeObjects,\n    transformedSchemas,\n    extensions,\n    directiveMap,\n    schemaDefs,\n    operationTypeNames,\n    mergeDirectives\n  });\n  Object.keys(directiveMap).forEach(directiveName => {\n    directives.push(directiveMap[directiveName]);\n  });\n  let stitchingInfo = createStitchingInfo(transformedSchemas, typeCandidates, mergeTypes);\n  const typeMap = buildTypeMap({\n    typeCandidates,\n    stitchingInfo,\n    operationTypeNames,\n    onTypeConflict,\n    mergeTypes,\n    typeMergingOptions\n  });\n  const {\n    typeMap: newTypeMap,\n    directives: newDirectives\n  } = rewireTypes(typeMap, directives, {\n    skipPruning: true\n  });\n  let schema = new GraphQLSchema({\n    query: newTypeMap[operationTypeNames.query],\n    mutation: newTypeMap[operationTypeNames.mutation],\n    subscription: newTypeMap[operationTypeNames.subscription],\n    types: Object.keys(newTypeMap).map(key => newTypeMap[key]),\n    directives: newDirectives,\n    astNode: schemaDefs.schemaDef,\n    extensionASTNodes: schemaDefs.schemaExtensions,\n    extensions: null\n  });\n  extensions.forEach(extension => {\n    schema = extendSchema(schema, extension, {\n      commentDescriptions: true\n    });\n  }); // We allow passing in an array of resolver maps, in which case we merge them\n\n  const resolverMap = Array.isArray(resolvers) ? resolvers.reduce(mergeDeep, {}) : resolvers;\n  const finalResolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, resolverMap) : resolverMap;\n  stitchingInfo = completeStitchingInfo(stitchingInfo, finalResolvers);\n  schema = addResolversToSchema({\n    schema,\n    resolvers: finalResolvers,\n    resolverValidationOptions,\n    inheritResolversFromInterfaces: false\n  });\n  assertResolversPresent(schema, resolverValidationOptions);\n  schema = addStitchingInfo(schema, stitchingInfo);\n\n  if (!allowUndefinedInResolve) {\n    schema = addCatchUndefinedToSchema(schema);\n  }\n\n  if (logger != null) {\n    schema = addErrorLoggingToSchema(schema, logger);\n  }\n\n  if (typeof finalResolvers['__schema'] === 'function') {\n    // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n    // not doing that now, because I'd have to rewrite a lot of tests.\n    schema = addSchemaLevelResolver(schema, finalResolvers['__schema']);\n  }\n\n  schemaTransforms.forEach(schemaTransform => {\n    schema = schemaTransform(schema);\n  });\n\n  if (directiveResolvers != null) {\n    schema = attachDirectiveResolvers(schema, directiveResolvers);\n  }\n\n  if (schemaDirectives != null) {\n    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n  }\n\n  return pruningOptions ? pruneSchema(schema, pruningOptions) : schema;\n}\n\nfunction isDocumentNode$1(object) {\n  return object.kind !== undefined;\n}\n\nconst forwardArgsToSelectionSet = (selectionSet, mapping) => {\n  const selectionSetDef = parseSelectionSet(selectionSet);\n  return field => {\n    const selections = selectionSetDef.selections.map(selectionNode => {\n      if (selectionNode.kind === Kind.FIELD) {\n        if (!mapping) {\n          return { ...selectionNode,\n            arguments: field.arguments.slice()\n          };\n        } else if (selectionNode.name.value in mapping) {\n          const selectionArgs = mapping[selectionNode.name.value];\n          return { ...selectionNode,\n            arguments: field.arguments.filter(arg => selectionArgs.includes(arg.name.value))\n          };\n        }\n      }\n\n      return selectionNode;\n    });\n    return { ...selectionSetDef,\n      selections\n    };\n  };\n};\n\nexport { forwardArgsToSelectionSet, stitchSchemas };","map":{"version":3,"sources":["../../../dist/stitch/src/definitions.js","../../../dist/stitch/src/typeFromAST.js","../../../dist/stitch/src/mergeCandidates.js","../../../dist/stitch/src/typeCandidates.js","../../../dist/stitch/src/stitchingInfo.js","../../../dist/stitch/src/stitchSchemas.js","../../../dist/stitch/src/selectionSetArgs.js"],"names":["isDocumentNode"],"mappings":"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","sourcesContent":["import { Kind } from 'graphql';\nexport function extractTypeDefinitions(ast) {\n    const typeDefs = ast.definitions.filter((def) => def.kind === Kind.OBJECT_TYPE_DEFINITION ||\n        def.kind === Kind.INTERFACE_TYPE_DEFINITION ||\n        def.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ||\n        def.kind === Kind.UNION_TYPE_DEFINITION ||\n        def.kind === Kind.ENUM_TYPE_DEFINITION ||\n        def.kind === Kind.SCALAR_TYPE_DEFINITION);\n    return {\n        ...ast,\n        definitions: typeDefs,\n    };\n}\nexport function extractDirectiveDefinitions(ast) {\n    const directiveDefs = ast.definitions.filter((def) => def.kind === Kind.DIRECTIVE_DEFINITION);\n    return {\n        ...ast,\n        definitions: directiveDefs,\n    };\n}\nexport function extractSchemaDefinition(ast) {\n    const schemaDefs = ast.definitions.filter((def) => def.kind === Kind.SCHEMA_DEFINITION);\n    return schemaDefs.length ? schemaDefs[schemaDefs.length - 1] : null;\n}\nexport function extractSchemaExtensions(ast) {\n    const schemaExtensions = ast.definitions.filter((def) => def.kind === Kind.SCHEMA_EXTENSION);\n    return schemaExtensions;\n}\nexport function extractTypeExtensionDefinitions(ast) {\n    const extensionDefs = ast.definitions.filter((def) => def.kind === Kind.OBJECT_TYPE_EXTENSION ||\n        def.kind === Kind.INTERFACE_TYPE_EXTENSION ||\n        def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION ||\n        def.kind === Kind.UNION_TYPE_EXTENSION ||\n        def.kind === Kind.ENUM_TYPE_EXTENSION ||\n        def.kind === Kind.SCALAR_TYPE_EXTENSION);\n    return {\n        ...ast,\n        definitions: extensionDefs,\n    };\n}\n//# sourceMappingURL=definitions.js.map","import { GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, Kind, GraphQLDirective, DirectiveLocation, TokenKind, valueFromASTUntyped, getDirectiveValues, GraphQLDeprecatedDirective, } from 'graphql';\nimport { createStub, createNamedStub } from '@graphql-tools/utils';\nconst backcompatOptions = { commentDescriptions: true };\nexport default function typeFromAST(node) {\n    switch (node.kind) {\n        case Kind.OBJECT_TYPE_DEFINITION:\n            return makeObjectType(node);\n        case Kind.INTERFACE_TYPE_DEFINITION:\n            return makeInterfaceType(node);\n        case Kind.ENUM_TYPE_DEFINITION:\n            return makeEnumType(node);\n        case Kind.UNION_TYPE_DEFINITION:\n            return makeUnionType(node);\n        case Kind.SCALAR_TYPE_DEFINITION:\n            return makeScalarType(node);\n        case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n            return makeInputObjectType(node);\n        case Kind.DIRECTIVE_DEFINITION:\n            return makeDirective(node);\n        default:\n            return null;\n    }\n}\nfunction makeObjectType(node) {\n    const config = {\n        name: node.name.value,\n        description: getDescription(node, backcompatOptions),\n        interfaces: () => node.interfaces.map(iface => createNamedStub(iface.name.value, 'interface')),\n        fields: () => makeFields(node.fields),\n        astNode: node,\n    };\n    return new GraphQLObjectType(config);\n}\nfunction makeInterfaceType(node) {\n    var _a;\n    const config = {\n        name: node.name.value,\n        description: getDescription(node, backcompatOptions),\n        interfaces: (_a = node.interfaces) === null || _a === void 0 ? void 0 : _a.map(iface => createNamedStub(iface.name.value, 'interface')),\n        fields: () => makeFields(node.fields),\n        astNode: node,\n    };\n    return new GraphQLInterfaceType(config);\n}\nfunction makeEnumType(node) {\n    const values = node.values.reduce((prev, value) => ({\n        ...prev,\n        [value.name.value]: {\n            description: getDescription(value, backcompatOptions),\n            deprecationReason: getDeprecationReason(value),\n            astNode: value,\n        },\n    }), {});\n    return new GraphQLEnumType({\n        name: node.name.value,\n        description: getDescription(node, backcompatOptions),\n        values,\n        astNode: node,\n    });\n}\nfunction makeUnionType(node) {\n    return new GraphQLUnionType({\n        name: node.name.value,\n        description: getDescription(node, backcompatOptions),\n        types: () => node.types.map(type => createNamedStub(type.name.value, 'object')),\n        astNode: node,\n    });\n}\nfunction makeScalarType(node) {\n    return new GraphQLScalarType({\n        name: node.name.value,\n        description: getDescription(node, backcompatOptions),\n        astNode: node,\n        // TODO: serialize default property setting can be dropped once\n        // upstream graphql-js TypeScript typings are updated, likely in v16\n        serialize: value => value,\n    });\n}\nfunction makeInputObjectType(node) {\n    return new GraphQLInputObjectType({\n        name: node.name.value,\n        description: getDescription(node, backcompatOptions),\n        fields: () => makeValues(node.fields),\n        astNode: node,\n    });\n}\nfunction makeFields(nodes) {\n    return nodes.reduce((prev, node) => ({\n        ...prev,\n        [node.name.value]: {\n            type: createStub(node.type, 'output'),\n            description: getDescription(node, backcompatOptions),\n            args: makeValues(node.arguments),\n            deprecationReason: getDeprecationReason(node),\n            astNode: node,\n        },\n    }), {});\n}\nfunction makeValues(nodes) {\n    return nodes.reduce((prev, node) => ({\n        ...prev,\n        [node.name.value]: {\n            type: createStub(node.type, 'input'),\n            defaultValue: node.defaultValue !== undefined ? valueFromASTUntyped(node.defaultValue) : undefined,\n            description: getDescription(node, backcompatOptions),\n            astNode: node,\n        },\n    }), {});\n}\nfunction makeDirective(node) {\n    const locations = [];\n    node.locations.forEach(location => {\n        if (location.value in DirectiveLocation) {\n            locations.push(location.value);\n        }\n    });\n    return new GraphQLDirective({\n        name: node.name.value,\n        description: node.description != null ? node.description.value : null,\n        locations,\n        isRepeatable: node.repeatable,\n        args: makeValues(node.arguments),\n        astNode: node,\n    });\n}\n// graphql < v13 does not export getDescription\nfunction getDescription(node, options) {\n    if (node.description != null) {\n        return node.description.value;\n    }\n    if (options.commentDescriptions) {\n        const rawValue = getLeadingCommentBlock(node);\n        if (rawValue !== undefined) {\n            return dedentBlockStringValue(`\\n${rawValue}`);\n        }\n    }\n}\nfunction getLeadingCommentBlock(node) {\n    const loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    const comments = [];\n    let token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === TokenKind.COMMENT &&\n        token.next != null &&\n        token.prev != null &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        const value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nfunction dedentBlockStringValue(rawString) {\n    // Expand a block string's raw value into independent lines.\n    const lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n    // Remove common indentation from all lines but first.\n    const commonIndent = getBlockStringIndentation(lines);\n    if (commonIndent !== 0) {\n        for (let i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].slice(commonIndent);\n        }\n    }\n    // Remove leading and trailing blank lines.\n    while (lines.length > 0 && isBlank(lines[0])) {\n        lines.shift();\n    }\n    while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n        lines.pop();\n    }\n    // Return a string of the lines joined with U+000A.\n    return lines.join('\\n');\n}\n/**\n * @internal\n */\nexport function getBlockStringIndentation(lines) {\n    let commonIndent = null;\n    for (let i = 1; i < lines.length; i++) {\n        const line = lines[i];\n        const indent = leadingWhitespace(line);\n        if (indent === line.length) {\n            continue; // skip empty lines\n        }\n        if (commonIndent === null || indent < commonIndent) {\n            commonIndent = indent;\n            if (commonIndent === 0) {\n                break;\n            }\n        }\n    }\n    return commonIndent === null ? 0 : commonIndent;\n}\nfunction leadingWhitespace(str) {\n    let i = 0;\n    while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n        i++;\n    }\n    return i;\n}\nfunction isBlank(str) {\n    return leadingWhitespace(str) === str.length;\n}\nfunction getDeprecationReason(node) {\n    const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);\n    return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;\n}\n//# sourceMappingURL=typeFromAST.js.map","import { GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, isScalarType, isObjectType, isInterfaceType, isUnionType, isEnumType, isInputObjectType, GraphQLInputObjectType, GraphQLScalarType, } from 'graphql';\nimport { mergeType, mergeInputType, mergeInterface, mergeUnion, mergeEnum } from '@graphql-tools/merge';\nimport { fieldToFieldConfig, inputFieldToFieldConfig } from '@graphql-tools/utils';\nexport function mergeCandidates(typeName, candidates, typeMergingOptions) {\n    const initialCandidateType = candidates[0].type;\n    if (candidates.some(candidate => candidate.type.constructor !== initialCandidateType.constructor)) {\n        throw new Error(`Cannot merge different type categories into common type ${typeName}.`);\n    }\n    if (isObjectType(initialCandidateType)) {\n        return mergeObjectTypeCandidates(typeName, candidates, typeMergingOptions);\n    }\n    else if (isInputObjectType(initialCandidateType)) {\n        return mergeInputObjectTypeCandidates(typeName, candidates, typeMergingOptions);\n    }\n    else if (isInterfaceType(initialCandidateType)) {\n        return mergeInterfaceTypeCandidates(typeName, candidates, typeMergingOptions);\n    }\n    else if (isUnionType(initialCandidateType)) {\n        return mergeUnionTypeCandidates(typeName, candidates, typeMergingOptions);\n    }\n    else if (isEnumType(initialCandidateType)) {\n        return mergeEnumTypeCandidates(typeName, candidates, typeMergingOptions);\n    }\n    else if (isScalarType(initialCandidateType)) {\n        return mergeScalarTypeCandidates(typeName, candidates, typeMergingOptions);\n    }\n    else {\n        // not reachable.\n        throw new Error(`Type ${typeName} has unknown GraphQL type.`);\n    }\n}\nfunction mergeObjectTypeCandidates(typeName, candidates, typeMergingOptions) {\n    const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n    const fields = fieldConfigMapFromTypeCandidates(candidates, typeMergingOptions);\n    const typeConfigs = candidates.map(candidate => candidate.type.toConfig());\n    const interfaceMap = typeConfigs\n        .map(typeConfig => typeConfig.interfaces)\n        .reduce((acc, interfaces) => {\n        if (interfaces != null) {\n            interfaces.forEach(iface => {\n                acc[iface.name] = iface;\n            });\n        }\n        return acc;\n    }, Object.create(null));\n    const interfaces = Object.keys(interfaceMap).map(interfaceName => interfaceMap[interfaceName]);\n    const astNodes = pluck('astNode', candidates);\n    const astNode = astNodes\n        .slice(1)\n        .reduce((acc, astNode) => mergeType(astNode, acc), astNodes[0]);\n    const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n    const extensions = Object.assign({}, ...pluck('extensions', candidates));\n    const typeConfig = {\n        name: typeName,\n        description,\n        fields,\n        interfaces,\n        astNode,\n        extensionASTNodes,\n        extensions,\n    };\n    return new GraphQLObjectType(typeConfig);\n}\nfunction mergeInputObjectTypeCandidates(typeName, candidates, typeMergingOptions) {\n    const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n    const fields = inputFieldConfigMapFromTypeCandidates(candidates, typeMergingOptions);\n    const astNodes = pluck('astNode', candidates);\n    const astNode = astNodes\n        .slice(1)\n        .reduce((acc, astNode) => mergeInputType(astNode, acc), astNodes[0]);\n    const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n    const extensions = Object.assign({}, ...pluck('extensions', candidates));\n    const typeConfig = {\n        name: typeName,\n        description,\n        fields,\n        astNode,\n        extensionASTNodes,\n        extensions,\n    };\n    return new GraphQLInputObjectType(typeConfig);\n}\nfunction pluck(typeProperty, candidates) {\n    return candidates.map(candidate => candidate.type[typeProperty]).filter(value => value != null);\n}\nfunction mergeInterfaceTypeCandidates(typeName, candidates, typeMergingOptions) {\n    const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n    const fields = fieldConfigMapFromTypeCandidates(candidates, typeMergingOptions);\n    const typeConfigs = candidates.map(candidate => candidate.type.toConfig());\n    const interfaceMap = typeConfigs\n        .map(typeConfig => typeConfig.interfaces)\n        .reduce((acc, interfaces) => {\n        if (interfaces != null) {\n            interfaces.forEach(iface => {\n                acc[iface.name] = iface;\n            });\n        }\n        return acc;\n    }, Object.create(null));\n    const interfaces = Object.keys(interfaceMap).map(interfaceName => interfaceMap[interfaceName]);\n    const astNodes = pluck('astNode', candidates);\n    const astNode = astNodes\n        .slice(1)\n        .reduce((acc, astNode) => mergeInterface(astNode, acc, {}), astNodes[0]);\n    const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n    const extensions = Object.assign({}, ...pluck('extensions', candidates));\n    const typeConfig = {\n        name: typeName,\n        description,\n        fields,\n        interfaces,\n        astNode,\n        extensionASTNodes,\n        extensions,\n    };\n    return new GraphQLInterfaceType(typeConfig);\n}\nfunction mergeUnionTypeCandidates(typeName, candidates, typeMergingOptions) {\n    const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n    const typeConfigs = candidates.map(candidate => candidate.type.toConfig());\n    const typeMap = typeConfigs.reduce((acc, typeConfig) => {\n        typeConfig.types.forEach(type => {\n            acc[type.name] = type;\n        });\n        return acc;\n    }, Object.create(null));\n    const types = Object.keys(typeMap).map(typeName => typeMap[typeName]);\n    const astNodes = pluck('astNode', candidates);\n    const astNode = astNodes\n        .slice(1)\n        .reduce((acc, astNode) => mergeUnion(astNode, acc), astNodes[0]);\n    const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n    const extensions = Object.assign({}, ...pluck('extensions', candidates));\n    const typeConfig = {\n        name: typeName,\n        description,\n        types,\n        astNode,\n        extensionASTNodes,\n        extensions,\n    };\n    return new GraphQLUnionType(typeConfig);\n}\nfunction mergeEnumTypeCandidates(typeName, candidates, typeMergingOptions) {\n    const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n    const typeConfigs = candidates.map(candidate => candidate.type.toConfig());\n    const values = typeConfigs.reduce((acc, typeConfig) => ({\n        ...acc,\n        ...typeConfig.values,\n    }), {});\n    const astNodes = pluck('astNode', candidates);\n    const astNode = astNodes\n        .slice(1)\n        .reduce((acc, astNode) => mergeEnum(astNode, acc), astNodes[0]);\n    const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n    const extensions = Object.assign({}, ...pluck('extensions', candidates));\n    const typeConfig = {\n        name: typeName,\n        description,\n        values,\n        astNode,\n        extensionASTNodes,\n        extensions,\n    };\n    return new GraphQLEnumType(typeConfig);\n}\nfunction mergeScalarTypeCandidates(typeName, candidates, typeMergingOptions) {\n    const description = mergeTypeDescriptions(candidates, typeMergingOptions);\n    const serializeFns = pluck('serialize', candidates);\n    const serialize = serializeFns[serializeFns.length - 1];\n    const parseValueFns = pluck('parseValue', candidates);\n    const parseValue = parseValueFns[parseValueFns.length - 1];\n    const parseLiteralFns = pluck('parseLiteral', candidates);\n    const parseLiteral = parseLiteralFns[parseLiteralFns.length - 1];\n    const astNodes = pluck('astNode', candidates);\n    const astNode = astNodes\n        .slice(1)\n        .reduce((acc, astNode) => mergeScalarTypeDefinitionNodes(acc, astNode), astNodes[0]);\n    const extensionASTNodes = [].concat(pluck('extensionASTNodes', candidates));\n    const extensions = Object.assign({}, ...pluck('extensions', candidates));\n    const typeConfig = {\n        name: typeName,\n        description,\n        serialize,\n        parseValue,\n        parseLiteral,\n        astNode,\n        extensionASTNodes,\n        extensions,\n    };\n    return new GraphQLScalarType(typeConfig);\n}\nfunction mergeTypeDescriptions(candidates, typeMergingOptions) {\n    var _a;\n    const typeDescriptionsMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.typeDescriptionsMerger) !== null && _a !== void 0 ? _a : defaultTypeDescriptionMerger;\n    return typeDescriptionsMerger(candidates);\n}\nfunction defaultTypeDescriptionMerger(candidates) {\n    return candidates[candidates.length - 1].type.description;\n}\nfunction fieldConfigMapFromTypeCandidates(candidates, typeMergingOptions) {\n    const fieldConfigCandidatesMap = Object.create(null);\n    candidates.forEach(candidate => {\n        const fieldMap = candidate.type.getFields();\n        Object.keys(fieldMap).forEach(fieldName => {\n            const fieldConfigCandidate = {\n                fieldConfig: fieldToFieldConfig(fieldMap[fieldName]),\n                fieldName,\n                type: candidate.type,\n                subschema: candidate.subschema,\n                transformedSchema: candidate.transformedSchema,\n            };\n            if (fieldName in fieldConfigCandidatesMap) {\n                fieldConfigCandidatesMap[fieldName].push(fieldConfigCandidate);\n            }\n            else {\n                fieldConfigCandidatesMap[fieldName] = [fieldConfigCandidate];\n            }\n        });\n    });\n    const fieldConfigMap = Object.create(null);\n    Object.keys(fieldConfigCandidatesMap).forEach(fieldName => {\n        fieldConfigMap[fieldName] = mergeFieldConfigs(fieldConfigCandidatesMap[fieldName], typeMergingOptions);\n    });\n    return fieldConfigMap;\n}\nfunction mergeFieldConfigs(candidates, typeMergingOptions) {\n    var _a;\n    const fieldConfigMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.fieldConfigMerger) !== null && _a !== void 0 ? _a : defaultFieldConfigMerger;\n    return fieldConfigMerger(candidates);\n}\nfunction defaultFieldConfigMerger(candidates) {\n    return candidates[candidates.length - 1].fieldConfig;\n}\nfunction inputFieldConfigMapFromTypeCandidates(candidates, typeMergingOptions) {\n    const inputFieldConfigCandidatesMap = Object.create(null);\n    candidates.forEach(candidate => {\n        const inputFieldMap = candidate.type.getFields();\n        Object.keys(inputFieldMap).forEach(fieldName => {\n            const inputFieldConfigCandidate = {\n                inputFieldConfig: inputFieldToFieldConfig(inputFieldMap[fieldName]),\n                fieldName,\n                type: candidate.type,\n                subschema: candidate.subschema,\n                transformedSchema: candidate.transformedSchema,\n            };\n            if (fieldName in inputFieldConfigCandidatesMap) {\n                inputFieldConfigCandidatesMap[fieldName].push(inputFieldConfigCandidate);\n            }\n            else {\n                inputFieldConfigCandidatesMap[fieldName] = [inputFieldConfigCandidate];\n            }\n        });\n    });\n    const inputFieldConfigMap = Object.create(null);\n    Object.keys(inputFieldConfigCandidatesMap).forEach(fieldName => {\n        inputFieldConfigMap[fieldName] = mergeInputFieldConfigs(inputFieldConfigCandidatesMap[fieldName], typeMergingOptions);\n    });\n    return inputFieldConfigMap;\n}\nfunction mergeInputFieldConfigs(candidates, typeMergingOptions) {\n    var _a;\n    const inputFieldConfigMerger = (_a = typeMergingOptions === null || typeMergingOptions === void 0 ? void 0 : typeMergingOptions.inputFieldConfigMerger) !== null && _a !== void 0 ? _a : defaultInputFieldConfigMerger;\n    return inputFieldConfigMerger(candidates);\n}\nfunction defaultInputFieldConfigMerger(candidates) {\n    return candidates[candidates.length - 1].inputFieldConfig;\n}\nfunction mergeScalarTypeDefinitionNodes(targetNode, sourceNode) {\n    var _a, _b, _c;\n    return {\n        ...targetNode,\n        description: (_a = sourceNode.description) !== null && _a !== void 0 ? _a : targetNode.description,\n        directives: ((_b = targetNode.directives) !== null && _b !== void 0 ? _b : []).concat((_c = sourceNode.directives) !== null && _c !== void 0 ? _c : []),\n    };\n}\n//# sourceMappingURL=mergeCandidates.js.map","import { getNamedType, isNamedType, isSchema, isSpecifiedScalarType, } from 'graphql';\nimport { wrapSchema } from '@graphql-tools/wrap';\nimport { isSubschemaConfig } from '@graphql-tools/delegate';\nimport { extractTypeDefinitions, extractTypeExtensionDefinitions, extractDirectiveDefinitions, extractSchemaDefinition, extractSchemaExtensions, } from './definitions';\nimport typeFromAST from './typeFromAST';\nimport { mergeCandidates } from './mergeCandidates';\nfunction isDocumentNode(schemaLikeObject) {\n    return schemaLikeObject.kind !== undefined;\n}\nexport function buildTypeCandidates({ schemaLikeObjects, transformedSchemas, extensions, directiveMap, schemaDefs, operationTypeNames, mergeDirectives, }) {\n    const typeCandidates = Object.create(null);\n    let schemaDef;\n    let schemaExtensions = [];\n    schemaLikeObjects.forEach(schemaLikeObject => {\n        if (isDocumentNode(schemaLikeObject)) {\n            schemaDef = extractSchemaDefinition(schemaLikeObject);\n            schemaExtensions = schemaExtensions.concat(extractSchemaExtensions(schemaLikeObject));\n        }\n    });\n    schemaDefs.schemaDef = schemaDef;\n    schemaDefs.schemaExtensions = schemaExtensions;\n    setOperationTypeNames(schemaDefs, operationTypeNames);\n    schemaLikeObjects.forEach(schemaLikeObject => {\n        if (isSchema(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {\n            const schema = wrapSchema(schemaLikeObject);\n            transformedSchemas.set(schemaLikeObject, schema);\n            const operationTypes = {\n                query: schema.getQueryType(),\n                mutation: schema.getMutationType(),\n                subscription: schema.getSubscriptionType(),\n            };\n            Object.keys(operationTypes).forEach(operationType => {\n                if (operationTypes[operationType] != null) {\n                    addTypeCandidate(typeCandidates, operationTypeNames[operationType], {\n                        type: operationTypes[operationType],\n                        subschema: schemaLikeObject,\n                        transformedSchema: schema,\n                    });\n                }\n            });\n            if (mergeDirectives) {\n                schema.getDirectives().forEach(directive => {\n                    directiveMap[directive.name] = directive;\n                });\n            }\n            const originalTypeMap = schema.getTypeMap();\n            Object.keys(originalTypeMap).forEach(typeName => {\n                const type = originalTypeMap[typeName];\n                if (isNamedType(type) &&\n                    getNamedType(type).name.slice(0, 2) !== '__' &&\n                    type !== operationTypes.query &&\n                    type !== operationTypes.mutation &&\n                    type !== operationTypes.subscription) {\n                    addTypeCandidate(typeCandidates, type.name, {\n                        type,\n                        subschema: schemaLikeObject,\n                        transformedSchema: schema,\n                    });\n                }\n            });\n        }\n        else if (isDocumentNode(schemaLikeObject)) {\n            const typesDocument = extractTypeDefinitions(schemaLikeObject);\n            typesDocument.definitions.forEach(def => {\n                const type = typeFromAST(def);\n                if (type != null) {\n                    addTypeCandidate(typeCandidates, type.name, {\n                        type,\n                    });\n                }\n            });\n            const directivesDocument = extractDirectiveDefinitions(schemaLikeObject);\n            directivesDocument.definitions.forEach(def => {\n                const directive = typeFromAST(def);\n                directiveMap[directive.name] = directive;\n            });\n            const extensionsDocument = extractTypeExtensionDefinitions(schemaLikeObject);\n            if (extensionsDocument.definitions.length > 0) {\n                extensions.push(extensionsDocument);\n            }\n        }\n        else if (isNamedType(schemaLikeObject)) {\n            addTypeCandidate(typeCandidates, schemaLikeObject.name, {\n                type: schemaLikeObject,\n            });\n        }\n        else {\n            throw new Error(`Invalid object ${schemaLikeObject}`);\n        }\n    });\n    return typeCandidates;\n}\nfunction setOperationTypeNames({ schemaDef, schemaExtensions, }, operationTypeNames) {\n    const allNodes = schemaExtensions.slice();\n    if (schemaDef != null) {\n        allNodes.unshift(schemaDef);\n    }\n    allNodes.forEach(node => {\n        if (node.operationTypes != null) {\n            node.operationTypes.forEach(operationType => {\n                operationTypeNames[operationType.operation] = operationType.type.name.value;\n            });\n        }\n    });\n}\nfunction addTypeCandidate(typeCandidates, name, typeCandidate) {\n    if (!(name in typeCandidates)) {\n        typeCandidates[name] = [];\n    }\n    typeCandidates[name].push(typeCandidate);\n}\nexport function buildTypeMap({ typeCandidates, stitchingInfo, operationTypeNames, onTypeConflict, mergeTypes, typeMergingOptions, }) {\n    const typeMap = Object.create(null);\n    Object.keys(typeCandidates).forEach(typeName => {\n        if (typeName === operationTypeNames.query ||\n            typeName === operationTypeNames.mutation ||\n            typeName === operationTypeNames.subscription ||\n            (mergeTypes === true && !typeCandidates[typeName].some(candidate => isSpecifiedScalarType(candidate.type))) ||\n            (typeof mergeTypes === 'function' && mergeTypes(typeCandidates[typeName], typeName)) ||\n            (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||\n            (stitchingInfo != null && typeName in stitchingInfo.mergedTypes)) {\n            typeMap[typeName] = mergeCandidates(typeName, typeCandidates[typeName], typeMergingOptions);\n        }\n        else {\n            const candidateSelector = onTypeConflict != null\n                ? onTypeConflictToCandidateSelector(onTypeConflict)\n                : (cands) => cands[cands.length - 1];\n            typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;\n        }\n    });\n    return typeMap;\n}\nfunction onTypeConflictToCandidateSelector(onTypeConflict) {\n    return cands => cands.reduce((prev, next) => {\n        const type = onTypeConflict(prev.type, next.type, {\n            left: {\n                schema: prev.transformedSchema,\n            },\n            right: {\n                schema: next.transformedSchema,\n            },\n        });\n        if (prev.type === type) {\n            return prev;\n        }\n        else if (next.type === type) {\n            return next;\n        }\n        return {\n            schemaName: 'unknown',\n            type,\n        };\n    });\n}\n//# sourceMappingURL=typeCandidates.js.map","import { GraphQLSchema, Kind, isObjectType, isScalarType, getNamedType, print, isInterfaceType, isLeafType, } from 'graphql';\nimport { parseFragmentToInlineFragment, concatInlineFragments, parseSelectionSet, } from '@graphql-tools/utils';\nimport { delegateToSchema, isSubschemaConfig } from '@graphql-tools/delegate';\nimport { batchDelegateToSchema } from '@graphql-tools/batch-delegate';\nexport function createStitchingInfo(transformedSchemas, typeCandidates, mergeTypes) {\n    const mergedTypes = createMergedTypes(typeCandidates, mergeTypes);\n    const selectionSetsByField = Object.create(null);\n    Object.entries(mergedTypes).forEach(([typeName, mergedTypeInfo]) => {\n        if (mergedTypeInfo.selectionSets == null && mergedTypeInfo.fieldSelectionSets == null) {\n            return;\n        }\n        selectionSetsByField[typeName] = Object.create(null);\n        mergedTypeInfo.selectionSets.forEach((selectionSet, subschemaConfig) => {\n            const schema = subschemaConfig.schema;\n            const type = schema.getType(typeName);\n            const fields = type.getFields();\n            Object.keys(fields).forEach(fieldName => {\n                const field = fields[fieldName];\n                const fieldType = getNamedType(field.type);\n                if (selectionSet && isLeafType(fieldType) && selectionSetContainsTopLevelField(selectionSet, fieldName)) {\n                    return;\n                }\n                if (selectionSetsByField[typeName][fieldName] == null) {\n                    selectionSetsByField[typeName][fieldName] = {\n                        kind: Kind.SELECTION_SET,\n                        selections: [parseSelectionSet('{ __typename }').selections[0]],\n                    };\n                }\n                selectionSetsByField[typeName][fieldName].selections = selectionSetsByField[typeName][fieldName].selections.concat(selectionSet.selections);\n            });\n        });\n        mergedTypeInfo.fieldSelectionSets.forEach(selectionSetFieldMap => {\n            Object.keys(selectionSetFieldMap).forEach(fieldName => {\n                if (selectionSetsByField[typeName][fieldName] == null) {\n                    selectionSetsByField[typeName][fieldName] = {\n                        kind: Kind.SELECTION_SET,\n                        selections: [parseSelectionSet('{ __typename }').selections[0]],\n                    };\n                }\n                selectionSetsByField[typeName][fieldName].selections = selectionSetsByField[typeName][fieldName].selections.concat(selectionSetFieldMap[fieldName].selections);\n            });\n        });\n    });\n    return {\n        transformedSchemas,\n        fragmentsByField: undefined,\n        selectionSetsByField,\n        dynamicSelectionSetsByField: undefined,\n        mergedTypes,\n    };\n}\nfunction createMergedTypes(typeCandidates, mergeTypes) {\n    const mergedTypes = Object.create(null);\n    Object.keys(typeCandidates).forEach(typeName => {\n        if (typeCandidates[typeName].length > 1 &&\n            (isObjectType(typeCandidates[typeName][0].type) || isInterfaceType(typeCandidates[typeName][0].type))) {\n            const typeCandidatesWithMergedTypeConfig = typeCandidates[typeName].filter(typeCandidate => typeCandidate.subschema != null &&\n                isSubschemaConfig(typeCandidate.subschema) &&\n                typeCandidate.subschema.merge != null &&\n                typeName in typeCandidate.subschema.merge);\n            if (mergeTypes === true ||\n                (typeof mergeTypes === 'function' && mergeTypes(typeCandidates[typeName], typeName)) ||\n                (Array.isArray(mergeTypes) && mergeTypes.includes(typeName)) ||\n                typeCandidatesWithMergedTypeConfig.length) {\n                const targetSubschemas = [];\n                const typeMaps = new Map();\n                const supportedBySubschemas = Object.create({});\n                const selectionSets = new Map();\n                const fieldSelectionSets = new Map();\n                typeCandidates[typeName].forEach(typeCandidate => {\n                    var _a;\n                    const subschema = typeCandidate.subschema;\n                    if (subschema == null) {\n                        return;\n                    }\n                    typeMaps.set(subschema, typeCandidate.transformedSchema.getTypeMap());\n                    if (!isSubschemaConfig(subschema)) {\n                        return;\n                    }\n                    const mergedTypeConfig = (_a = subschema === null || subschema === void 0 ? void 0 : subschema.merge) === null || _a === void 0 ? void 0 : _a[typeName];\n                    if (mergedTypeConfig == null) {\n                        return;\n                    }\n                    if (mergedTypeConfig.selectionSet) {\n                        const selectionSet = parseSelectionSet(mergedTypeConfig.selectionSet);\n                        selectionSets.set(subschema, selectionSet);\n                    }\n                    if (mergedTypeConfig.fields) {\n                        const parsedFieldSelectionSets = Object.create(null);\n                        Object.keys(mergedTypeConfig.fields).forEach(fieldName => {\n                            if (mergedTypeConfig.fields[fieldName].selectionSet) {\n                                const rawFieldSelectionSet = mergedTypeConfig.fields[fieldName].selectionSet;\n                                parsedFieldSelectionSets[fieldName] = parseSelectionSet(rawFieldSelectionSet);\n                            }\n                        });\n                        fieldSelectionSets.set(subschema, parsedFieldSelectionSets);\n                    }\n                    if (mergedTypeConfig.resolve != null) {\n                        targetSubschemas.push(subschema);\n                    }\n                    else if (mergedTypeConfig.key != null) {\n                        mergedTypeConfig.resolve = (originalResult, context, info, subschema, selectionSet) => {\n                            var _a;\n                            return batchDelegateToSchema({\n                                schema: subschema,\n                                operation: 'query',\n                                fieldName: mergedTypeConfig.fieldName,\n                                key: mergedTypeConfig.key(originalResult),\n                                argsFromKeys: (_a = mergedTypeConfig.argsFromKeys) !== null && _a !== void 0 ? _a : mergedTypeConfig.args,\n                                valuesFromResults: mergedTypeConfig.valuesFromResults,\n                                selectionSet,\n                                context,\n                                info,\n                                skipTypeMerging: true,\n                            });\n                        };\n                        targetSubschemas.push(subschema);\n                    }\n                    else if (mergedTypeConfig.fieldName != null) {\n                        mergedTypeConfig.resolve = (originalResult, context, info, subschema, selectionSet) => delegateToSchema({\n                            schema: subschema,\n                            operation: 'query',\n                            fieldName: mergedTypeConfig.fieldName,\n                            returnType: getNamedType(info.returnType),\n                            args: mergedTypeConfig.args(originalResult),\n                            selectionSet,\n                            context,\n                            info,\n                            skipTypeMerging: true,\n                        });\n                        targetSubschemas.push(subschema);\n                    }\n                    if (mergedTypeConfig.resolve == null) {\n                        return;\n                    }\n                    const type = typeCandidate.transformedSchema.getType(typeName);\n                    const fieldMap = type.getFields();\n                    const selectionSet = selectionSets.get(subschema);\n                    Object.keys(fieldMap).forEach(fieldName => {\n                        const field = fieldMap[fieldName];\n                        const fieldType = getNamedType(field.type);\n                        if (selectionSet && isLeafType(fieldType) && selectionSetContainsTopLevelField(selectionSet, fieldName)) {\n                            return;\n                        }\n                        if (!(fieldName in supportedBySubschemas)) {\n                            supportedBySubschemas[fieldName] = [];\n                        }\n                        supportedBySubschemas[fieldName].push(subschema);\n                    });\n                });\n                const sourceSubschemas = typeCandidates[typeName]\n                    .filter(typeCandidate => typeCandidate.subschema != null)\n                    .map(typeCandidate => typeCandidate.subschema);\n                const targetSubschemasBySubschema = new Map();\n                sourceSubschemas.forEach(subschema => {\n                    const filteredSubschemas = targetSubschemas.filter(s => s !== subschema);\n                    if (filteredSubschemas.length) {\n                        targetSubschemasBySubschema.set(subschema, filteredSubschemas);\n                    }\n                });\n                mergedTypes[typeName] = {\n                    typeName,\n                    targetSubschemas: targetSubschemasBySubschema,\n                    typeMaps,\n                    selectionSets,\n                    fieldSelectionSets,\n                    uniqueFields: Object.create({}),\n                    nonUniqueFields: Object.create({}),\n                };\n                Object.keys(supportedBySubschemas).forEach(fieldName => {\n                    if (supportedBySubschemas[fieldName].length === 1) {\n                        mergedTypes[typeName].uniqueFields[fieldName] = supportedBySubschemas[fieldName][0];\n                    }\n                    else {\n                        mergedTypes[typeName].nonUniqueFields[fieldName] = supportedBySubschemas[fieldName];\n                    }\n                });\n            }\n        }\n    });\n    return mergedTypes;\n}\nexport function completeStitchingInfo(stitchingInfo, resolvers) {\n    const selectionSetsByField = stitchingInfo.selectionSetsByField;\n    const dynamicSelectionSetsByField = Object.create(null);\n    const rawFragments = [];\n    Object.keys(resolvers).forEach(typeName => {\n        const type = resolvers[typeName];\n        if (isScalarType(type)) {\n            return;\n        }\n        Object.keys(type).forEach(fieldName => {\n            const field = type[fieldName];\n            if (field.selectionSet) {\n                if (typeof field.selectionSet === 'function') {\n                    if (!(typeName in dynamicSelectionSetsByField)) {\n                        dynamicSelectionSetsByField[typeName] = Object.create(null);\n                    }\n                    if (!(fieldName in dynamicSelectionSetsByField[typeName])) {\n                        dynamicSelectionSetsByField[typeName][fieldName] = [];\n                    }\n                    dynamicSelectionSetsByField[typeName][fieldName].push(field.selectionSet);\n                }\n                else {\n                    const selectionSet = parseSelectionSet(field.selectionSet);\n                    if (!(typeName in selectionSetsByField)) {\n                        selectionSetsByField[typeName] = Object.create(null);\n                    }\n                    if (!(fieldName in selectionSetsByField[typeName])) {\n                        selectionSetsByField[typeName][fieldName] = {\n                            kind: Kind.SELECTION_SET,\n                            selections: [],\n                        };\n                    }\n                    selectionSetsByField[typeName][fieldName].selections = selectionSetsByField[typeName][fieldName].selections.concat(selectionSet.selections);\n                }\n            }\n            if (field.fragment) {\n                rawFragments.push({\n                    field: fieldName,\n                    fragment: field.fragment,\n                });\n            }\n        });\n    });\n    Object.keys(selectionSetsByField).forEach(typeName => {\n        const typeSelectionSets = selectionSetsByField[typeName];\n        Object.keys(typeSelectionSets).forEach(fieldName => {\n            const consolidatedSelections = new Map();\n            const selectionSet = typeSelectionSets[fieldName];\n            selectionSet.selections.forEach(selection => {\n                consolidatedSelections.set(print(selection), selection);\n            });\n            selectionSet.selections = Array.from(consolidatedSelections.values());\n        });\n    });\n    const parsedFragments = Object.create(null);\n    rawFragments.forEach(({ field, fragment }) => {\n        const parsedFragment = parseFragmentToInlineFragment(fragment);\n        const actualTypeName = parsedFragment.typeCondition.name.value;\n        if (!(actualTypeName in parsedFragments)) {\n            parsedFragments[actualTypeName] = Object.create(null);\n        }\n        if (!(field in parsedFragments[actualTypeName])) {\n            parsedFragments[actualTypeName][field] = [];\n        }\n        parsedFragments[actualTypeName][field].push(parsedFragment);\n    });\n    const fragmentsByField = Object.create(null);\n    Object.keys(parsedFragments).forEach(typeName => {\n        Object.keys(parsedFragments[typeName]).forEach(field => {\n            if (!(typeName in fragmentsByField)) {\n                fragmentsByField[typeName] = Object.create(null);\n            }\n            fragmentsByField[typeName][field] = concatInlineFragments(typeName, parsedFragments[typeName][field]);\n        });\n    });\n    stitchingInfo.selectionSetsByField = selectionSetsByField;\n    stitchingInfo.dynamicSelectionSetsByField = dynamicSelectionSetsByField;\n    stitchingInfo.fragmentsByField = fragmentsByField;\n    return stitchingInfo;\n}\nexport function addStitchingInfo(stitchedSchema, stitchingInfo) {\n    return new GraphQLSchema({\n        ...stitchedSchema.toConfig(),\n        extensions: {\n            ...stitchedSchema.extensions,\n            stitchingInfo,\n        },\n    });\n}\nexport function selectionSetContainsTopLevelField(selectionSet, fieldName) {\n    return selectionSet.selections.some(selection => selection.kind === Kind.FIELD && selection.name.value === fieldName);\n}\n//# sourceMappingURL=stitchingInfo.js.map","import { GraphQLSchema, specifiedDirectives, extendSchema, isSchema, } from 'graphql';\nimport { SchemaDirectiveVisitor, mergeDeep, rewireTypes, pruneSchema } from '@graphql-tools/utils';\nimport { addResolversToSchema, addSchemaLevelResolver, addErrorLoggingToSchema, addCatchUndefinedToSchema, assertResolversPresent, attachDirectiveResolvers, buildDocumentFromTypeDefinitions, extendResolversFromInterfaces, } from '@graphql-tools/schema';\nimport { buildTypeCandidates, buildTypeMap } from './typeCandidates';\nimport { createStitchingInfo, completeStitchingInfo, addStitchingInfo } from './stitchingInfo';\nimport { isSubschemaConfig } from '@graphql-tools/delegate';\nexport function stitchSchemas({ subschemas = [], types = [], typeDefs, schemas = [], onTypeConflict, mergeDirectives, mergeTypes = false, typeMergingOptions, resolvers = {}, schemaDirectives, inheritResolversFromInterfaces = false, logger, allowUndefinedInResolve = true, resolverValidationOptions = {}, directiveResolvers, schemaTransforms = [], parseOptions = {}, pruningOptions, }) {\n    if (typeof resolverValidationOptions !== 'object') {\n        throw new Error('Expected `resolverValidationOptions` to be an object');\n    }\n    let schemaLikeObjects = [];\n    subschemas.forEach(subschemaOrSubschemaArray => {\n        if (Array.isArray(subschemaOrSubschemaArray)) {\n            schemaLikeObjects = schemaLikeObjects.concat(subschemaOrSubschemaArray);\n        }\n        else {\n            schemaLikeObjects.push(subschemaOrSubschemaArray);\n        }\n    });\n    schemas.forEach(schemaLikeObject => {\n        if (!isSchema(schemaLikeObject) &&\n            !isSubschemaConfig(schemaLikeObject) &&\n            typeof schemaLikeObject !== 'string' &&\n            !isDocumentNode(schemaLikeObject) &&\n            !Array.isArray(schemaLikeObject)) {\n            throw new Error('Invalid schema passed');\n        }\n    });\n    schemas.forEach(schemaLikeObject => {\n        if (isSchema(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {\n            schemaLikeObjects.push(schemaLikeObject);\n        }\n    });\n    if ((typeDefs && !Array.isArray(typeDefs)) || (Array.isArray(typeDefs) && typeDefs.length)) {\n        schemaLikeObjects.push(buildDocumentFromTypeDefinitions(typeDefs, parseOptions));\n    }\n    schemas.forEach(schemaLikeObject => {\n        if (typeof schemaLikeObject === 'string' || isDocumentNode(schemaLikeObject)) {\n            schemaLikeObjects.push(buildDocumentFromTypeDefinitions(schemaLikeObject, parseOptions));\n        }\n    });\n    if (types != null) {\n        schemaLikeObjects = schemaLikeObjects.concat(types);\n    }\n    schemas.forEach(schemaLikeObject => {\n        if (Array.isArray(schemaLikeObject)) {\n            schemaLikeObjects = schemaLikeObjects.concat(schemaLikeObject);\n        }\n    });\n    const transformedSchemas = new Map();\n    const extensions = [];\n    const directives = [];\n    const directiveMap = specifiedDirectives.reduce((acc, directive) => {\n        acc[directive.name] = directive;\n        return acc;\n    }, Object.create(null));\n    const schemaDefs = Object.create(null);\n    const operationTypeNames = {\n        query: 'Query',\n        mutation: 'Mutation',\n        subscription: 'Subscription',\n    };\n    const typeCandidates = buildTypeCandidates({\n        schemaLikeObjects,\n        transformedSchemas,\n        extensions,\n        directiveMap,\n        schemaDefs,\n        operationTypeNames,\n        mergeDirectives,\n    });\n    Object.keys(directiveMap).forEach(directiveName => {\n        directives.push(directiveMap[directiveName]);\n    });\n    let stitchingInfo = createStitchingInfo(transformedSchemas, typeCandidates, mergeTypes);\n    const typeMap = buildTypeMap({\n        typeCandidates,\n        stitchingInfo,\n        operationTypeNames,\n        onTypeConflict,\n        mergeTypes,\n        typeMergingOptions,\n    });\n    const { typeMap: newTypeMap, directives: newDirectives } = rewireTypes(typeMap, directives, { skipPruning: true });\n    let schema = new GraphQLSchema({\n        query: newTypeMap[operationTypeNames.query],\n        mutation: newTypeMap[operationTypeNames.mutation],\n        subscription: newTypeMap[operationTypeNames.subscription],\n        types: Object.keys(newTypeMap).map(key => newTypeMap[key]),\n        directives: newDirectives,\n        astNode: schemaDefs.schemaDef,\n        extensionASTNodes: schemaDefs.schemaExtensions,\n        extensions: null,\n    });\n    extensions.forEach(extension => {\n        schema = extendSchema(schema, extension, {\n            commentDescriptions: true,\n        });\n    });\n    // We allow passing in an array of resolver maps, in which case we merge them\n    const resolverMap = Array.isArray(resolvers) ? resolvers.reduce(mergeDeep, {}) : resolvers;\n    const finalResolvers = inheritResolversFromInterfaces\n        ? extendResolversFromInterfaces(schema, resolverMap)\n        : resolverMap;\n    stitchingInfo = completeStitchingInfo(stitchingInfo, finalResolvers);\n    schema = addResolversToSchema({\n        schema,\n        resolvers: finalResolvers,\n        resolverValidationOptions,\n        inheritResolversFromInterfaces: false,\n    });\n    assertResolversPresent(schema, resolverValidationOptions);\n    schema = addStitchingInfo(schema, stitchingInfo);\n    if (!allowUndefinedInResolve) {\n        schema = addCatchUndefinedToSchema(schema);\n    }\n    if (logger != null) {\n        schema = addErrorLoggingToSchema(schema, logger);\n    }\n    if (typeof finalResolvers['__schema'] === 'function') {\n        // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n        // not doing that now, because I'd have to rewrite a lot of tests.\n        schema = addSchemaLevelResolver(schema, finalResolvers['__schema']);\n    }\n    schemaTransforms.forEach(schemaTransform => {\n        schema = schemaTransform(schema);\n    });\n    if (directiveResolvers != null) {\n        schema = attachDirectiveResolvers(schema, directiveResolvers);\n    }\n    if (schemaDirectives != null) {\n        SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n    }\n    return pruningOptions ? pruneSchema(schema, pruningOptions) : schema;\n}\nexport function isDocumentNode(object) {\n    return object.kind !== undefined;\n}\n//# sourceMappingURL=stitchSchemas.js.map","import { parseSelectionSet } from '@graphql-tools/utils';\nimport { Kind } from 'graphql';\nexport const forwardArgsToSelectionSet = (selectionSet, mapping) => {\n    const selectionSetDef = parseSelectionSet(selectionSet);\n    return (field) => {\n        const selections = selectionSetDef.selections.map((selectionNode) => {\n            if (selectionNode.kind === Kind.FIELD) {\n                if (!mapping) {\n                    return { ...selectionNode, arguments: field.arguments.slice() };\n                }\n                else if (selectionNode.name.value in mapping) {\n                    const selectionArgs = mapping[selectionNode.name.value];\n                    return {\n                        ...selectionNode,\n                        arguments: field.arguments.filter((arg) => selectionArgs.includes(arg.name.value)),\n                    };\n                }\n            }\n            return selectionNode;\n        });\n        return { ...selectionSetDef, selections };\n    };\n};\n//# sourceMappingURL=selectionSetArgs.js.map"]},"metadata":{},"sourceType":"module"}