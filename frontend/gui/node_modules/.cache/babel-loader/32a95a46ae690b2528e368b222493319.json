{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar Profiler = require('./GraphQLCompilerProfiler');\n\nvar orList = require('../util/orList');\n\nvar partitionArray = require('../util/partitionArray');\n\nvar _require = require('../util/DefaultHandleKey'),\n    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;\n\nvar _require2 = require('./CompilerError'),\n    createCompilerError = _require2.createCompilerError,\n    createUserError = _require2.createUserError,\n    eachWithCombinedError = _require2.eachWithCombinedError;\n\nvar _require3 = require('./SchemaUtils'),\n    isExecutableDefinitionAST = _require3.isExecutableDefinitionAST;\n\nvar _require4 = require('./getFieldDefinition'),\n    getFieldDefinitionLegacy = _require4.getFieldDefinitionLegacy;\n\nvar _require5 = require('graphql'),\n    parseGraphQL = _require5.parse,\n    parseType = _require5.parseType,\n    print = _require5.print,\n    Source = _require5.Source;\n\nvar ARGUMENT_DEFINITIONS = 'argumentDefinitions';\nvar ARGUMENTS = 'arguments';\nvar DEPRECATED_UNCHECKED_ARGUMENTS = 'uncheckedArguments_DEPRECATED';\nvar DIRECTIVE_WHITELIST = new Set([ARGUMENT_DEFINITIONS, DEPRECATED_UNCHECKED_ARGUMENTS, ARGUMENTS]);\n/**\n * @internal\n *\n * This directive is not intended for use by developers directly. To set a field\n * handle in product code use a compiler plugin.\n */\n\nvar CLIENT_FIELD = '__clientField';\nvar CLIENT_FIELD_HANDLE = 'handle';\nvar CLIENT_FIELD_KEY = 'key';\nvar CLIENT_FIELD_FILTERS = 'filters';\nvar INCLUDE = 'include';\nvar SKIP = 'skip';\nvar IF = 'if';\n/**\n * Transforms GraphQL text into Relay Compiler's internal, strongly-typed\n * intermediate representation (IR).\n */\n\nfunction parse(schema, text, filename) {\n  var ast = parseGraphQL(new Source(text, filename));\n  var parser = new RelayParser(schema.extend(ast), ast.definitions);\n  return parser.transform();\n}\n/**\n * Transforms untyped GraphQL parse trees (ASTs) into Relay Compiler's\n * internal, strongly-typed intermediate representation (IR).\n */\n\n\nfunction transform(schema, definitions) {\n  return Profiler.run('RelayParser.transform', function () {\n    var parser = new RelayParser(schema, definitions);\n    return parser.transform();\n  });\n}\n/**\n * @private\n */\n\n\nvar RelayParser = /*#__PURE__*/function () {\n  function RelayParser(schema, definitions) {\n    var _this = this;\n\n    this._definitions = new Map(); // leaving this configurable to make it easy to experiment w changing later\n\n    this._getFieldDefinition = getFieldDefinitionLegacy;\n    this._schema = schema;\n    var duplicated = new Set();\n    definitions.forEach(function (def) {\n      if (isExecutableDefinitionAST(def)) {\n        var name = getName(def);\n\n        if (_this._definitions.has(name)) {\n          duplicated.add(name);\n          return;\n        }\n\n        _this._definitions.set(name, def);\n      }\n    });\n\n    if (duplicated.size) {\n      throw createUserError('RelayParser: Encountered duplicate definitions for one or more ' + 'documents: each document must have a unique name. Duplicated documents:\\n' + Array.from(duplicated, function (name) {\n        return \"- \".concat(name);\n      }).join('\\n'));\n    }\n  }\n\n  var _proto = RelayParser.prototype;\n\n  _proto.transform = function transform() {\n    var _this2 = this;\n\n    var nodes = [];\n    var entries = new Map(); // Construct a mapping of name to definition ast + variable definitions.\n    // This allows the subsequent AST -> IR tranformation to reference the\n    // defined arguments of referenced fragments.\n\n    eachWithCombinedError(this._definitions, function (_ref) {\n      var name = _ref[0],\n          definition = _ref[1];\n\n      var variableDefinitions = _this2._buildArgumentDefinitions(definition);\n\n      entries.set(name, {\n        definition: definition,\n        variableDefinitions: variableDefinitions\n      });\n    }); // Convert the ASTs to IR.\n\n    eachWithCombinedError(entries.values(), function (_ref2) {\n      var definition = _ref2.definition,\n          variableDefinitions = _ref2.variableDefinitions;\n      var node = parseDefinition(_this2._schema, _this2._getFieldDefinition, entries, definition, variableDefinitions);\n      nodes.push(node);\n    });\n    return nodes;\n  }\n  /**\n   * Constructs a mapping of variable names to definitions for the given\n   * operation/fragment definition.\n   */\n  ;\n\n  _proto._buildArgumentDefinitions = function _buildArgumentDefinitions(definition) {\n    switch (definition.kind) {\n      case 'OperationDefinition':\n        return this._buildOperationArgumentDefinitions(definition);\n\n      case 'FragmentDefinition':\n        return this._buildFragmentArgumentDefinitions(definition);\n\n      default:\n        definition;\n        throw createCompilerError(\"Unexpected ast kind '\".concat(definition.kind, \"'.\"), [definition]);\n    }\n  }\n  /**\n   * Constructs a mapping of variable names to definitions using the\n   * variables defined in `@argumentDefinitions`.\n   */\n  ;\n\n  _proto._buildFragmentArgumentDefinitions = function _buildFragmentArgumentDefinitions(fragment) {\n    var _this3 = this;\n\n    var variableDirectives = (fragment.directives || []).filter(function (directive) {\n      return getName(directive) === ARGUMENT_DEFINITIONS;\n    });\n\n    if (!variableDirectives.length) {\n      return new Map();\n    }\n\n    if (variableDirectives.length !== 1) {\n      throw createUserError(\"Directive @\".concat(ARGUMENT_DEFINITIONS, \" may be defined at most once per \") + 'fragment.', null, variableDirectives);\n    }\n\n    var variableDirective = variableDirectives[0]; // work, below accesses all report arguments could still be null/undefined.\n\n    var args = variableDirective.arguments;\n\n    if (variableDirective == null || !Array.isArray(args)) {\n      return new Map();\n    }\n\n    if (!args.length) {\n      throw createUserError(\"Directive @\".concat(ARGUMENT_DEFINITIONS, \" requires arguments: remove the \") + 'directive to skip defining local variables for this fragment.', null, [variableDirective]);\n    }\n\n    var variables = new Map();\n    args.forEach(function (arg) {\n      var _defaultValue$value;\n\n      var argName = getName(arg);\n      var previousVariable = variables.get(argName);\n\n      if (previousVariable != null) {\n        throw createUserError(\"Duplicate definition for variable '$\".concat(argName, \"'.\"), null, [previousVariable.ast, arg]);\n      }\n\n      if (arg.value.kind !== 'ObjectValue') {\n        throw createUserError(\"Expected definition for variable '$\".concat(argName, \"' to be an object \") + \"with the shape: '{type: string, defaultValue?: mixed}.\", null, [arg.value]);\n      }\n\n      var defaultValueNode;\n      var typeString;\n      arg.value.fields.forEach(function (field) {\n        var name = getName(field);\n\n        if (name === 'type') {\n          typeString = transformLiteralValue(field.value, field);\n        } else if (name === 'defaultValue') {\n          defaultValueNode = field.value;\n        } else {\n          throw createUserError(\"Expected definition for variable '$\".concat(argName, \"' to be an object \") + \"with the shape: '{type: string, defaultValue?: mixed}.\", null, [arg.value]);\n        }\n      });\n\n      if (typeof typeString !== 'string') {\n        throw createUserError(\"Expected definition for variable '$\".concat(argName, \"' to be an object \") + \"with the shape: '{type: string, defaultValue?: mixed}.\", null, [arg.value]);\n      }\n\n      var typeFromAST = _this3._schema.getTypeFromAST(parseType(typeString));\n\n      if (typeFromAST == null) {\n        throw createUserError(\"Unknown type \\\"\".concat(typeString, \"\\\" referenced in the argument definitions.\"), null, [arg]);\n      }\n\n      var type = _this3._schema.asInputType(typeFromAST);\n\n      if (type == null) {\n        throw createUserError(\"Expected type \\\"\".concat(typeString, \"\\\" to be an input type in the \\\"\").concat(arg.name.value, \"\\\" argument definitions.\"), null, [arg.value]);\n      }\n\n      var defaultValue = defaultValueNode != null ? transformValue(_this3._schema, defaultValueNode, type, function (variableAst) {\n        throw createUserError(\"Expected 'defaultValue' to be a literal, got a variable.\", null, [variableAst]);\n      }) : null;\n\n      if (defaultValue != null && defaultValue.kind !== 'Literal') {\n        throw createUserError(\"Expected 'defaultValue' to be a literal, got a variable.\", [defaultValue.loc]);\n      }\n\n      variables.set(argName, {\n        ast: arg,\n        defaultValue: (_defaultValue$value = defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.value) !== null && _defaultValue$value !== void 0 ? _defaultValue$value : null,\n        defined: true,\n        name: argName,\n        type: type\n      });\n    });\n    return variables;\n  }\n  /**\n   * Constructs a mapping of variable names to definitions using the\n   * standard GraphQL syntax for variable definitions.\n   */\n  ;\n\n  _proto._buildOperationArgumentDefinitions = function _buildOperationArgumentDefinitions(operation) {\n    var schema = this._schema;\n    var variableDefinitions = new Map();\n    (operation.variableDefinitions || []).forEach(function (def) {\n      var name = getName(def.variable);\n      var typeFromAST = schema.getTypeFromAST(def.type);\n\n      if (typeFromAST == null) {\n        throw createUserError(\"Unknown type: '\".concat(getTypeName(def.type), \"'.\"), null, [def.type]);\n      }\n\n      var type = schema.asInputType(typeFromAST);\n\n      if (type == null) {\n        throw createUserError(\"Expected type \\\"\".concat(getTypeName(def.type), \"\\\" to be an input type.\"), null, [def.type]);\n      }\n\n      var defaultValue = def.defaultValue ? transformLiteralValue(def.defaultValue, def) : null;\n      var previousDefinition = variableDefinitions.get(name);\n\n      if (previousDefinition != null) {\n        throw createUserError(\"Duplicate definition for variable '$\".concat(name, \"'.\"), null, [previousDefinition.ast, def]);\n      }\n\n      variableDefinitions.set(name, {\n        ast: def,\n        defaultValue: defaultValue,\n        defined: true,\n        name: name,\n        type: type\n      });\n    });\n    return variableDefinitions;\n  };\n\n  return RelayParser;\n}();\n/**\n * @private\n */\n\n\nfunction parseDefinition(schema, getFieldDefinition, entries, definition, variableDefinitions) {\n  var parser = new GraphQLDefinitionParser(schema, getFieldDefinition, entries, definition, variableDefinitions);\n  return parser.transform();\n}\n/**\n * @private\n */\n\n\nvar GraphQLDefinitionParser = /*#__PURE__*/function () {\n  function GraphQLDefinitionParser(schema, getFieldDefinition, entries, definition, variableDefinitions) {\n    this._definition = definition;\n    this._entries = entries;\n    this._getFieldDefinition = getFieldDefinition;\n    this._schema = schema;\n    this._variableDefinitions = variableDefinitions;\n    this._unknownVariables = new Map();\n  }\n\n  var _proto2 = GraphQLDefinitionParser.prototype;\n\n  _proto2.transform = function transform() {\n    var definition = this._definition;\n\n    switch (definition.kind) {\n      case 'OperationDefinition':\n        return this._transformOperation(definition);\n\n      case 'FragmentDefinition':\n        return this._transformFragment(definition);\n\n      default:\n        definition;\n        throw createCompilerError(\"Unsupported definition type \".concat(definition.kind), [definition]);\n    }\n  };\n\n  _proto2._recordAndVerifyVariableReference = function _recordAndVerifyVariableReference(variable, name, usedAsType) {\n    // Special case for variables used in @arguments where we currently\n    // aren't guaranteed to be able to resolve the type.\n    if (usedAsType == null) {\n      if (!this._variableDefinitions.has(name) && !this._unknownVariables.has(name)) {\n        this._unknownVariables.set(name, {\n          ast: variable,\n          type: null\n        });\n      }\n\n      return;\n    }\n\n    var variableDefinition = this._variableDefinitions.get(name);\n\n    if (variableDefinition != null) {\n      // If the variable is defined, all usages must be compatible\n      var effectiveType = variableDefinition.type;\n\n      if (variableDefinition.defaultValue != null) {\n        // If a default value is defined then it is guaranteed to be used\n        // at runtime such that the effective type of the variable is non-null\n        effectiveType = this._schema.getNonNullType(this._schema.getNullableType(effectiveType));\n      }\n\n      if (!this._schema.isTypeSubTypeOf(effectiveType, usedAsType)) {\n        throw createUserError(\"Variable '$\".concat(name, \"' was defined as type '\").concat(String(variableDefinition.type), \"' but used in a location expecting the type '\").concat(String(usedAsType), \"'\"), null, [variableDefinition.ast, variable]);\n      }\n    } else {\n      var previous = this._unknownVariables.get(name);\n\n      if (!previous || !previous.type) {\n        // No previous usage, current type is strongest\n        this._unknownVariables.set(name, {\n          ast: variable,\n          type: usedAsType\n        });\n      } else {\n        var previousVariable = previous.ast,\n            previousType = previous.type;\n\n        if (!(this._schema.isTypeSubTypeOf(usedAsType, previousType) || this._schema.isTypeSubTypeOf(previousType, usedAsType))) {\n          throw createUserError(\"Variable '$\".concat(name, \"' was used in locations expecting the conflicting types '\").concat(String(previousType), \"' and '\").concat(String(usedAsType), \"'.\"), null, [previousVariable, variable]);\n        } // If the new used type has stronger requirements, use that type as reference,\n        // otherwise keep referencing the previous type\n\n\n        if (this._schema.isTypeSubTypeOf(usedAsType, previousType)) {\n          this._unknownVariables.set(name, {\n            ast: variable,\n            type: usedAsType\n          });\n        }\n      }\n    }\n  };\n\n  _proto2._getDirectiveLocations = function _getDirectiveLocations() {\n    if (!this._directiveLocations) {\n      var directiveDefs = this._schema.getDirectives();\n\n      this._directiveLocations = new Map();\n\n      var _iterator = _createForOfIteratorHelper(directiveDefs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var def = _step.value;\n\n          this._directiveLocations.set(def.name, def.locations);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return this._directiveLocations;\n  };\n\n  _proto2._validateDirectivesLocation = function _validateDirectivesLocation(directives, allowedLocaction) {\n    if (!directives || !directives.length) {\n      return;\n    }\n\n    var directiveLocs = this._getDirectiveLocations();\n\n    var mismatches = directives.filter(function (directive) {\n      var name = getName(directive);\n\n      if (DIRECTIVE_WHITELIST.has(name)) {\n        return false;\n      }\n\n      var locs = directiveLocs.get(name);\n\n      if (locs == null) {\n        throw createUserError(\"Unknown directive '\".concat(name, \"'.\"), null, [directive]);\n      }\n\n      return !locs.some(function (loc) {\n        return loc === allowedLocaction;\n      });\n    });\n\n    if (mismatches.length) {\n      var invalidDirectives = mismatches.map(function (directive) {\n        return '@' + getName(directive);\n      }).join(', ');\n      throw createUserError(\"Invalid directives \".concat(invalidDirectives, \" found on \").concat(allowedLocaction, \".\"), null, mismatches);\n    }\n  };\n\n  _proto2._transformFragment = function _transformFragment(fragment) {\n    var directives = this._transformDirectives((fragment.directives || []).filter(function (directive) {\n      return getName(directive) !== ARGUMENT_DEFINITIONS;\n    }), 'FRAGMENT_DEFINITION');\n\n    var typeFromAST = this._schema.getTypeFromAST(fragment.typeCondition);\n\n    if (typeFromAST == null) {\n      throw createUserError(\"Fragment \\\"\".concat(fragment.name.value, \"\\\" cannot condition on unknown \") + \"type \\\"\".concat(String(fragment.typeCondition.name.value), \"\\\".\"), null, [fragment.typeCondition]);\n    }\n\n    var type = this._schema.asCompositeType(typeFromAST);\n\n    if (type == null) {\n      throw createUserError(\"Fragment \\\"\".concat(fragment.name.value, \"\\\" cannot condition on non composite \") + \"type \\\"\".concat(String(type), \"\\\".\"), null, [fragment.typeCondition]);\n    }\n\n    var selections = this._transformSelections(fragment.selectionSet, type, fragment.typeCondition);\n\n    var argumentDefinitions = (0, _toConsumableArray2[\"default\"])(buildArgumentDefinitions(this._variableDefinitions));\n\n    var _iterator2 = _createForOfIteratorHelper(this._unknownVariables),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _step2.value,\n            name = _step2$value[0],\n            variableReference = _step2$value[1];\n        argumentDefinitions.push({\n          kind: 'RootArgumentDefinition',\n          loc: buildLocation(variableReference.ast.loc),\n          name: name,\n          type: variableReference.type\n        });\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return {\n      kind: 'Fragment',\n      directives: directives,\n      loc: buildLocation(fragment.loc),\n      metadata: null,\n      name: getName(fragment),\n      selections: selections,\n      type: type,\n      // $FlowFixMe[incompatible-return] - could be null\n      argumentDefinitions: argumentDefinitions\n    };\n  };\n\n  _proto2._getLocationFromOperation = function _getLocationFromOperation(definition) {\n    switch (definition.operation) {\n      case 'query':\n        return 'QUERY';\n\n      case 'mutation':\n        return 'MUTATION';\n\n      case 'subscription':\n        return 'SUBSCRIPTION';\n\n      default:\n        definition.operation;\n        throw createCompilerError(\"Unknown operation type '\".concat(definition.operation, \"'.\"), null, [definition]);\n    }\n  };\n\n  _proto2._transformOperation = function _transformOperation(definition) {\n    var name = getName(definition);\n\n    var directives = this._transformDirectives(definition.directives || [], this._getLocationFromOperation(definition));\n\n    var type;\n    var operation;\n    var schema = this._schema;\n\n    switch (definition.operation) {\n      case 'query':\n        operation = 'query';\n        type = schema.expectQueryType();\n        break;\n\n      case 'mutation':\n        operation = 'mutation';\n        type = schema.expectMutationType();\n        break;\n\n      case 'subscription':\n        operation = 'subscription';\n        type = schema.expectSubscriptionType();\n        break;\n\n      default:\n        definition.operation;\n        throw createCompilerError(\"Unknown operation type '\".concat(definition.operation, \"'.\"), null, [definition]);\n    }\n\n    if (!definition.selectionSet) {\n      throw createUserError('Expected operation to have selections.', null, [definition]);\n    }\n\n    var selections = this._transformSelections(definition.selectionSet, type);\n\n    var argumentDefinitions = buildArgumentDefinitions(this._variableDefinitions);\n\n    if (this._unknownVariables.size !== 0) {\n      throw createUserError(\"Query '\".concat(name, \"' references undefined variables.\"), null, Array.from(this._unknownVariables.values(), function (variableReference) {\n        return variableReference.ast;\n      }));\n    }\n\n    return {\n      kind: 'Root',\n      operation: operation,\n      loc: buildLocation(definition.loc),\n      metadata: null,\n      name: name,\n      argumentDefinitions: argumentDefinitions,\n      directives: directives,\n      selections: selections,\n      type: type\n    };\n  };\n\n  _proto2._transformSelections = function _transformSelections(selectionSet, parentType, parentTypeAST) {\n    var _this4 = this;\n\n    return selectionSet.selections.map(function (selection) {\n      var node;\n\n      if (selection.kind === 'Field') {\n        node = _this4._transformField(selection, parentType);\n      } else if (selection.kind === 'FragmentSpread') {\n        node = _this4._transformFragmentSpread(selection, parentType, parentTypeAST);\n      } else if (selection.kind === 'InlineFragment') {\n        node = _this4._transformInlineFragment(selection, parentType, parentTypeAST);\n      } else {\n        selection.kind;\n        throw createCompilerError(\"Unknown ast kind '\".concat(selection.kind, \"'.\"), [selection]);\n      }\n\n      var _this4$_splitConditio = _this4._splitConditions(node.directives),\n          conditions = _this4$_splitConditio[0],\n          directives = _this4$_splitConditio[1];\n\n      var conditionalNodes = applyConditions(conditions, // $FlowFixMe[incompatible-call]\n      [_objectSpread({}, node, {\n        directives: directives\n      })]);\n\n      if (conditionalNodes.length !== 1) {\n        throw createCompilerError('Expected exactly one condition node.', null, selection.directives);\n      }\n\n      return conditionalNodes[0];\n    });\n  };\n\n  _proto2._transformInlineFragment = function _transformInlineFragment(fragment, parentType, parentTypeAST) {\n    var schema = this._schema;\n    var typeCondition = fragment.typeCondition != null ? schema.getTypeFromAST(fragment.typeCondition) : parentType;\n\n    if (typeCondition == null) {\n      var _fragment$typeConditi;\n\n      throw createUserError('Inline fragments can only be on object, interface or union types' + \", got unknown type '\".concat(getTypeName(fragment.typeCondition), \"'.\"), null, [(_fragment$typeConditi = fragment.typeCondition) !== null && _fragment$typeConditi !== void 0 ? _fragment$typeConditi : fragment]);\n    }\n\n    var typeConditionName = schema.getTypeString(typeCondition);\n    typeCondition = schema.asCompositeType(typeCondition);\n\n    if (typeCondition == null) {\n      var _fragment$typeConditi2;\n\n      throw createUserError('Inline fragments can only be on object, interface or union types' + \", got '\".concat(typeConditionName, \"'.\"), null, [(_fragment$typeConditi2 = fragment.typeCondition) !== null && _fragment$typeConditi2 !== void 0 ? _fragment$typeConditi2 : fragment]);\n    }\n\n    var rawParentType = this._schema.assertCompositeType(this._schema.getRawType(parentType));\n\n    checkFragmentSpreadTypeCompatibility(this._schema, typeCondition, rawParentType, null, fragment.typeCondition, parentTypeAST);\n\n    var directives = this._transformDirectives(fragment.directives || [], 'INLINE_FRAGMENT');\n\n    var selections = this._transformSelections(fragment.selectionSet, typeCondition, fragment.typeCondition);\n\n    return {\n      kind: 'InlineFragment',\n      directives: directives,\n      loc: buildLocation(fragment.loc),\n      metadata: null,\n      selections: selections,\n      typeCondition: typeCondition\n    };\n  };\n\n  _proto2._transformFragmentSpread = function _transformFragmentSpread(fragmentSpread, parentType, parentTypeAST) {\n    var _this5 = this;\n\n    var fragmentName = getName(fragmentSpread);\n\n    var _partitionArray = partitionArray(fragmentSpread.directives || [], function (directive) {\n      var name = getName(directive);\n      return name === ARGUMENTS || name === DEPRECATED_UNCHECKED_ARGUMENTS;\n    }),\n        argumentDirectives = _partitionArray[0],\n        otherDirectives = _partitionArray[1];\n\n    if (argumentDirectives.length > 1) {\n      throw createUserError(\"Directive @\".concat(ARGUMENTS, \" may be used at most once per a fragment spread.\"), null, argumentDirectives);\n    }\n\n    var fragmentDefinition = this._entries.get(fragmentName);\n\n    if (fragmentDefinition == null) {\n      throw createUserError(\"Unknown fragment '\".concat(fragmentName, \"'.\"), null, [fragmentSpread.name]);\n    }\n\n    var fragmentTypeNode = getFragmentType(fragmentDefinition.definition);\n\n    var fragmentType = this._schema.assertCompositeType(this._schema.expectTypeFromAST(fragmentTypeNode));\n\n    var rawParentType = this._schema.assertCompositeType(this._schema.getRawType(parentType));\n\n    checkFragmentSpreadTypeCompatibility(this._schema, fragmentType, rawParentType, fragmentSpread.name.value, fragmentSpread, parentTypeAST);\n    var fragmentArgumentDefinitions = fragmentDefinition.variableDefinitions;\n    var argumentsDirective = argumentDirectives[0];\n    var args;\n\n    if (argumentsDirective != null) {\n      var isDeprecatedUncheckedArguments = getName(argumentsDirective) === DEPRECATED_UNCHECKED_ARGUMENTS;\n      var hasInvalidArgument = false;\n      args = (argumentsDirective.arguments || []).map(function (arg) {\n        var _argumentDefinition$t;\n\n        var argName = getName(arg);\n        var argValue = arg.value;\n        var argumentDefinition = fragmentArgumentDefinitions.get(argName);\n        var argumentType = (_argumentDefinition$t = argumentDefinition === null || argumentDefinition === void 0 ? void 0 : argumentDefinition.type) !== null && _argumentDefinition$t !== void 0 ? _argumentDefinition$t : null;\n\n        if (argValue.kind === 'Variable') {\n          if (argumentDefinition == null && !isDeprecatedUncheckedArguments) {\n            throw createUserError(\"Variable @\".concat(ARGUMENTS, \" values are only supported when the \") + \"argument is defined with @\".concat(ARGUMENT_DEFINITIONS, \". Check \") + \"the definition of fragment '\".concat(fragmentName, \"'.\"), null, [arg.value, fragmentDefinition.definition]);\n          }\n\n          hasInvalidArgument = hasInvalidArgument || argumentDefinition == null; // TODO: check the type of the variable and use the type\n\n          return {\n            kind: 'Argument',\n            loc: buildLocation(arg.loc),\n            name: argName,\n            value: _this5._transformVariable(argValue, null),\n            type: null\n          };\n        } else {\n          if (argumentType == null) {\n            throw createUserError(\"Literal @\".concat(ARGUMENTS, \" values are only supported when the \") + \"argument is defined with @\".concat(ARGUMENT_DEFINITIONS, \". Check \") + \"the definition of fragment '\".concat(fragmentName, \"'.\"), null, [arg.value, fragmentDefinition.definition]);\n          }\n\n          var value = _this5._transformValue(argValue, argumentType);\n\n          return {\n            kind: 'Argument',\n            loc: buildLocation(arg.loc),\n            name: argName,\n            value: value,\n            type: argumentType\n          };\n        }\n      });\n\n      if (isDeprecatedUncheckedArguments && !hasInvalidArgument) {\n        throw createUserError(\"Invalid use of @\".concat(DEPRECATED_UNCHECKED_ARGUMENTS, \": all arguments \") + \"are defined, use @\".concat(ARGUMENTS, \" instead.\"), null, [argumentsDirective]);\n      }\n    }\n\n    var directives = this._transformDirectives(otherDirectives, 'FRAGMENT_SPREAD');\n\n    return {\n      kind: 'FragmentSpread',\n      args: args || [],\n      metadata: null,\n      loc: buildLocation(fragmentSpread.loc),\n      name: fragmentName,\n      directives: directives\n    };\n  };\n\n  _proto2._transformField = function _transformField(field, parentType) {\n    var _field$alias$value, _field$alias;\n\n    var schema = this._schema;\n    var name = getName(field);\n\n    var fieldDef = this._getFieldDefinition(schema, parentType, name, field);\n\n    if (fieldDef == null) {\n      throw createUserError(\"Unknown field '\".concat(name, \"' on type '\").concat(schema.getTypeString(parentType), \"'.\"), null, [field]);\n    }\n\n    var alias = (_field$alias$value = (_field$alias = field.alias) === null || _field$alias === void 0 ? void 0 : _field$alias.value) !== null && _field$alias$value !== void 0 ? _field$alias$value : name;\n\n    var args = this._transformArguments(field.arguments || [], schema.getFieldArgs(fieldDef), fieldDef);\n\n    var _partitionArray2 = partitionArray(field.directives || [], function (directive) {\n      return getName(directive) !== CLIENT_FIELD;\n    }),\n        otherDirectives = _partitionArray2[0],\n        clientFieldDirectives = _partitionArray2[1];\n\n    var directives = this._transformDirectives(otherDirectives, 'FIELD');\n\n    var type = schema.getFieldType(fieldDef);\n\n    var handles = this._transformHandle(name, args, clientFieldDirectives);\n\n    if (schema.isLeafType(schema.getRawType(type))) {\n      if (field.selectionSet && field.selectionSet.selections && field.selectionSet.selections.length) {\n        throw createUserError(\"Expected no selections for scalar field '\".concat(name, \"'.\"), null, [field]);\n      }\n\n      return {\n        kind: 'ScalarField',\n        alias: alias,\n        args: args,\n        directives: directives,\n        handles: handles,\n        loc: buildLocation(field.loc),\n        metadata: null,\n        name: name,\n        type: schema.assertScalarFieldType(type)\n      };\n    } else {\n      var selections = field.selectionSet ? this._transformSelections(field.selectionSet, type) : null;\n\n      if (selections == null || selections.length === 0) {\n        throw createUserError(\"Expected at least one selection for non-scalar field '\".concat(name, \"' on type '\").concat(schema.getTypeString(type), \"'.\"), null, [field]);\n      }\n\n      return {\n        kind: 'LinkedField',\n        alias: alias,\n        args: args,\n        connection: false,\n        directives: directives,\n        handles: handles,\n        loc: buildLocation(field.loc),\n        metadata: null,\n        name: name,\n        selections: selections,\n        type: schema.assertLinkedFieldType(type)\n      };\n    }\n  };\n\n  _proto2._transformHandle = function _transformHandle(fieldName, fieldArgs, clientFieldDirectives) {\n    var handles = null;\n    clientFieldDirectives.forEach(function (clientFieldDirective) {\n      var handleArgument = (clientFieldDirective.arguments || []).find(function (arg) {\n        return getName(arg) === CLIENT_FIELD_HANDLE;\n      });\n\n      if (handleArgument) {\n        var name = null;\n        var key = DEFAULT_HANDLE_KEY;\n        var filters = null;\n        var maybeHandle = transformLiteralValue(handleArgument.value, handleArgument);\n\n        if (typeof maybeHandle !== 'string') {\n          throw createUserError(\"Expected a string literal argument for the @\".concat(CLIENT_FIELD, \" directive.\"), null, [handleArgument.value]);\n        }\n\n        name = maybeHandle;\n        var keyArgument = (clientFieldDirective.arguments || []).find(function (arg) {\n          return getName(arg) === CLIENT_FIELD_KEY;\n        });\n\n        if (keyArgument) {\n          var maybeKey = transformLiteralValue(keyArgument.value, keyArgument);\n\n          if (typeof maybeKey !== 'string') {\n            throw createUserError(\"Expected a string literal argument for the @\".concat(CLIENT_FIELD, \" directive.\"), null, [keyArgument.value]);\n          }\n\n          key = maybeKey;\n        }\n\n        var filtersArgument = (clientFieldDirective.arguments || []).find(function (arg) {\n          return getName(arg) === CLIENT_FIELD_FILTERS;\n        });\n\n        if (filtersArgument) {\n          var maybeFilters = transformLiteralValue(filtersArgument.value, filtersArgument);\n\n          if (!(Array.isArray(maybeFilters) && maybeFilters.every(function (filter) {\n            return typeof filter === 'string' && fieldArgs.some(function (fieldArg) {\n              return fieldArg.name === filter;\n            });\n          }))) {\n            throw createUserError(\"Expected an array of argument names on field '\".concat(fieldName, \"'.\"), null, [filtersArgument.value]);\n          } // $FlowFixMe[incompatible-cast]\n\n\n          filters = maybeFilters;\n        }\n\n        var dynamicKeyArgument = (clientFieldDirective.arguments || []).find(function (arg) {\n          return getName(arg) === 'dynamicKey_UNSTABLE';\n        });\n\n        if (dynamicKeyArgument != null) {\n          throw createUserError('Dynamic keys are only supported with @connection.', null, [dynamicKeyArgument.value]);\n        }\n\n        handles = handles || [];\n        handles.push({\n          name: name,\n          key: key,\n          filters: filters,\n          dynamicKey: null\n        });\n      }\n    });\n    return handles;\n  };\n\n  _proto2._transformDirectives = function _transformDirectives(directives, location) {\n    var _this6 = this;\n\n    this._validateDirectivesLocation(directives, location);\n\n    return directives.map(function (directive) {\n      var name = getName(directive);\n\n      var directiveDef = _this6._schema.getDirective(name);\n\n      if (directiveDef == null) {\n        throw createUserError(\"Unknown directive '\".concat(name, \"'.\"), null, [directive]);\n      }\n\n      var args = _this6._transformArguments(directive.arguments || [], directiveDef.args.map(function (item) {\n        return {\n          name: item.name,\n          type: item.type,\n          defaultValue: item.defaultValue\n        };\n      }), null, name);\n\n      return {\n        kind: 'Directive',\n        loc: buildLocation(directive.loc),\n        name: name,\n        args: args\n      };\n    });\n  };\n\n  _proto2._transformArguments = function _transformArguments(args, argumentDefinitions, field, directiveName) {\n    var _this7 = this;\n\n    return args.map(function (arg) {\n      var argName = getName(arg);\n      var argDef = argumentDefinitions.find(function (def) {\n        return def.name === argName;\n      });\n\n      if (argDef == null) {\n        var message = \"Unknown argument '\".concat(argName, \"'\") + (field ? \" on field '\".concat(_this7._schema.getFieldName(field), \"'\") + \" of type '\".concat(_this7._schema.getTypeString(_this7._schema.getFieldParentType(field)), \"'.\") : directiveName != null ? \" on directive '@\".concat(directiveName, \"'.\") : '.');\n        throw createUserError(message, null, [arg]);\n      }\n\n      var value = _this7._transformValue(arg.value, argDef.type);\n\n      return {\n        kind: 'Argument',\n        loc: buildLocation(arg.loc),\n        name: argName,\n        value: value,\n        type: argDef.type\n      };\n    });\n  };\n\n  _proto2._splitConditions = function _splitConditions(mixedDirectives) {\n    var _partitionArray3 = partitionArray(mixedDirectives, function (directive) {\n      return directive.name === INCLUDE || directive.name === SKIP;\n    }),\n        conditionDirectives = _partitionArray3[0],\n        otherDirectives = _partitionArray3[1];\n\n    var conditions = conditionDirectives.map(function (directive) {\n      var passingValue = directive.name === INCLUDE;\n      var arg = directive.args[0];\n\n      if (arg == null || arg.name !== IF) {\n        throw createUserError(\"Expected an 'if' argument to @\".concat(directive.name, \".\"), [directive.loc]);\n      }\n\n      if (!(arg.value.kind === 'Variable' || arg.value.kind === 'Literal')) {\n        throw createUserError(\"Expected the 'if' argument to @\".concat(directive.name, \" to be a variable or literal.\"), [directive.loc]);\n      }\n\n      return {\n        kind: 'Condition',\n        condition: arg.value,\n        loc: directive.loc,\n        passingValue: passingValue,\n        selections: []\n      };\n    });\n    var sortedConditions = conditions.sort(function (a, b) {\n      if (a.condition.kind === 'Variable' && b.condition.kind === 'Variable') {\n        return a.condition.variableName < b.condition.variableName ? -1 : a.condition.variableName > b.condition.variableName ? 1 : 0;\n      } else {\n        // sort literals earlier, variables later\n        return a.condition.kind === 'Variable' ? 1 : b.condition.kind === 'Variable' ? -1 : 0;\n      }\n    });\n    return [sortedConditions, otherDirectives];\n  };\n\n  _proto2._transformVariable = function _transformVariable(ast, usedAsType) {\n    var variableName = getName(ast);\n\n    this._recordAndVerifyVariableReference(ast, variableName, usedAsType);\n\n    return {\n      kind: 'Variable',\n      loc: buildLocation(ast.loc),\n      variableName: variableName,\n      type: usedAsType\n    };\n  };\n\n  _proto2._transformValue = function _transformValue(ast, type) {\n    var _this8 = this;\n\n    return transformValue(this._schema, ast, type, function (variableAst, variableType) {\n      return _this8._transformVariable(variableAst, variableType);\n    });\n  };\n\n  return GraphQLDefinitionParser;\n}();\n/**\n * Transforms and validates argument values according to the expected\n * type.\n */\n\n\nfunction transformValue(schema, ast, type, transformVariable) {\n  if (ast.kind === 'Variable') {\n    // Special case variables since there is no value to parse\n    return transformVariable(ast, type);\n  } else if (ast.kind === 'NullValue') {\n    // Special case null literals since there is no value to parse\n    if (schema.isNonNull(type)) {\n      throw createUserError(\"Expected a value matching type '\".concat(String(type), \"'.\"), null, [ast]);\n    }\n\n    return {\n      kind: 'Literal',\n      loc: buildLocation(ast.loc),\n      value: null\n    };\n  } else {\n    return transformNonNullLiteral(schema, ast, type, transformVariable);\n  }\n}\n/**\n * Transforms and validates non-null literal (non-variable) values\n * according to the expected type.\n */\n\n\nfunction transformNonNullLiteral(schema, ast, type, transformVariable) {\n  // Transform the value based on the type without a non-null wrapper.\n  // Note that error messages should still use the original `type`\n  // since that accurately describes to the user what the expected\n  // type is (using nullableType would suggest that `null` is legal\n  // even when it may not be, for example).\n  var nullableType = schema.getNullableType(type);\n\n  if (schema.isList(nullableType)) {\n    if (ast.kind !== 'ListValue') {\n      // Parse singular (non-list) values flowing into a list type\n      // as scalars, ie without wrapping them in an array.\n      if (!schema.isInputType(schema.getListItemType(nullableType))) {\n        throw createUserError(\"Expected type \".concat(schema.getTypeString(nullableType), \" to be an input type.\"), null, [ast]);\n      }\n\n      return transformValue(schema, ast, schema.assertInputType(schema.getListItemType(nullableType)), transformVariable);\n    }\n\n    var itemType = schema.assertInputType(schema.getListItemType(nullableType));\n    var literalList = [];\n    var items = [];\n    var areAllItemsScalar = true;\n    ast.values.forEach(function (item) {\n      var itemValue = transformValue(schema, item, itemType, transformVariable);\n\n      if (itemValue.kind === 'Literal') {\n        literalList.push(itemValue.value);\n      }\n\n      items.push(itemValue);\n      areAllItemsScalar = areAllItemsScalar && itemValue.kind === 'Literal';\n    });\n\n    if (areAllItemsScalar) {\n      return {\n        kind: 'Literal',\n        loc: buildLocation(ast.loc),\n        value: literalList\n      };\n    } else {\n      return {\n        kind: 'ListValue',\n        loc: buildLocation(ast.loc),\n        items: items\n      };\n    }\n  } else if (schema.isInputObject(nullableType)) {\n    if (ast.kind !== 'ObjectValue') {\n      throw createUserError(\"Expected a value matching type '\".concat(schema.getTypeString(type), \"'.\"), null, [ast]);\n    }\n\n    var literalObject = {};\n    var fields = [];\n    var areAllFieldsScalar = true;\n    var inputType = schema.assertInputObjectType(nullableType);\n    var requiredFieldNames = new Set(schema.getFields(inputType).filter(function (field) {\n      return schema.isNonNull(schema.getFieldType(field));\n    }).map(function (field) {\n      return schema.getFieldName(field);\n    }));\n    var seenFields = new Map();\n    ast.fields.forEach(function (field) {\n      var fieldName = getName(field);\n      var seenField = seenFields.get(fieldName);\n\n      if (seenField) {\n        throw createUserError(\"Duplicated field name '\".concat(fieldName, \"' in the input object.\"), null, [field, seenField]);\n      }\n\n      var fieldID = schema.getFieldByName(inputType, fieldName);\n\n      if (!fieldID) {\n        throw createUserError(\"Unknown field '\".concat(fieldName, \"' on type '\").concat(schema.getTypeString(inputType), \"'.\"), null, [field]);\n      }\n\n      var fieldConfig = schema.getFieldConfig(fieldID);\n      var fieldType = schema.assertInputType(fieldConfig.type);\n      var fieldValue = transformValue(schema, field.value, fieldType, transformVariable);\n\n      if (fieldValue.kind === 'Literal') {\n        literalObject[field.name.value] = fieldValue.value;\n      }\n\n      fields.push({\n        kind: 'ObjectFieldValue',\n        loc: buildLocation(field.loc),\n        name: fieldName,\n        value: fieldValue\n      });\n      seenFields.set(fieldName, field);\n      requiredFieldNames[\"delete\"](fieldName);\n      areAllFieldsScalar = areAllFieldsScalar && fieldValue.kind === 'Literal';\n    });\n\n    if (requiredFieldNames.size > 0) {\n      var requiredFieldStr = Array.from(requiredFieldNames).map(function (item) {\n        return \"'\".concat(item, \"'\");\n      }).join(', ');\n      throw createUserError(\"Missing non-optional field\".concat(requiredFieldNames.size > 1 ? 's:' : '', \" \").concat(requiredFieldStr, \" for input type '\").concat(schema.getTypeString(inputType), \"'.\"), null, [ast]);\n    }\n\n    if (areAllFieldsScalar) {\n      return {\n        kind: 'Literal',\n        loc: buildLocation(ast.loc),\n        value: literalObject\n      };\n    } else {\n      return {\n        kind: 'ObjectValue',\n        loc: buildLocation(ast.loc),\n        fields: fields\n      };\n    }\n  } else if (schema.isId(nullableType)) {\n    // GraphQLID's parseLiteral() always returns the string value. However\n    // the int/string distinction may be important at runtime, so this\n    // transform parses int/string literals into the corresponding JS types.\n    if (ast.kind === 'IntValue') {\n      return {\n        kind: 'Literal',\n        loc: buildLocation(ast.loc),\n        value: parseInt(ast.value, 10)\n      };\n    } else if (ast.kind === 'StringValue') {\n      return {\n        kind: 'Literal',\n        loc: buildLocation(ast.loc),\n        value: ast.value\n      };\n    } else {\n      throw createUserError(\"Invalid value, expected a value matching type '\".concat(schema.getTypeString(type), \"'.\"), null, [ast]);\n    }\n  } else if (schema.isEnum(nullableType)) {\n    var enumType = schema.assertEnumType(nullableType);\n    var value = schema.parseLiteral(enumType, ast);\n\n    if (value == null) {\n      var suggestions = schema.getEnumValues(enumType); // parseLiteral() should return a non-null JavaScript value\n      // if the ast value is valid for the type.\n\n      throw createUserError(\"Expected a value matching type '\".concat(schema.getTypeString(type), \"'. Possible values: \").concat(orList(suggestions), \"?'\"), null, [ast]);\n    }\n\n    return {\n      kind: 'Literal',\n      loc: buildLocation(ast.loc),\n      value: value\n    };\n  } else if (schema.isScalar(nullableType)) {\n    var _value = schema.parseLiteral(schema.assertScalarType(nullableType), ast);\n\n    if (_value == null) {\n      // parseLiteral() should return a non-null JavaScript value\n      // if the ast value is valid for the type.\n      throw createUserError(\"Expected a value matching type '\".concat(schema.getTypeString(type), \"'.\"), null, [ast]);\n    }\n\n    return {\n      kind: 'Literal',\n      loc: buildLocation(ast.loc),\n      value: _value\n    };\n  } else {\n    throw createCompilerError(\"Unsupported type '\".concat(schema.getTypeString(type), \"' for input value, expected a GraphQLList, \") + 'GraphQLInputObjectType, GraphQLEnumType, or GraphQLScalarType.', null, [ast]);\n  }\n}\n/**\n * @private\n */\n\n\nfunction transformLiteralValue(ast, context) {\n  switch (ast.kind) {\n    case 'IntValue':\n      return parseInt(ast.value, 10);\n\n    case 'FloatValue':\n      return parseFloat(ast.value);\n\n    case 'StringValue':\n      return ast.value;\n\n    case 'BooleanValue':\n      // Note: duplicated because Flow does not understand fall-through cases\n      return ast.value;\n\n    case 'EnumValue':\n      // Note: duplicated because Flow does not understand fall-through cases\n      return ast.value;\n\n    case 'ListValue':\n      return ast.values.map(function (item) {\n        return transformLiteralValue(item, context);\n      });\n\n    case 'NullValue':\n      return null;\n\n    case 'ObjectValue':\n      {\n        var objectValue = {};\n        ast.fields.forEach(function (field) {\n          var fieldName = getName(field);\n          var value = transformLiteralValue(field.value, context);\n          objectValue[fieldName] = value;\n        });\n        return objectValue;\n      }\n\n    case 'Variable':\n      throw createUserError('Unexpected variable where a literal (static) value is required.', null, [ast, context]);\n\n    default:\n      ast.kind;\n      throw createCompilerError(\"Unknown ast kind '\".concat(ast.kind, \"'.\"), [ast]);\n  }\n}\n/**\n * @private\n */\n\n\nfunction buildArgumentDefinitions(variables) {\n  return Array.from(variables.values(), function (_ref3) {\n    var ast = _ref3.ast,\n        name = _ref3.name,\n        defaultValue = _ref3.defaultValue,\n        type = _ref3.type;\n    return {\n      kind: 'LocalArgumentDefinition',\n      loc: buildLocation(ast.loc),\n      name: name,\n      type: type,\n      defaultValue: defaultValue\n    };\n  });\n}\n/**\n * @private\n */\n\n\nfunction buildLocation(loc) {\n  if (loc == null) {\n    return {\n      kind: 'Unknown'\n    };\n  }\n\n  return {\n    kind: 'Source',\n    start: loc.start,\n    end: loc.end,\n    source: loc.source\n  };\n}\n/**\n * @private\n */\n\n\nfunction applyConditions(conditions, selections) {\n  var nextSelections = selections;\n  conditions.forEach(function (condition) {\n    nextSelections = [_objectSpread({}, condition, {\n      selections: nextSelections\n    })];\n  });\n  return nextSelections;\n}\n/**\n * @private\n */\n\n\nfunction getName(ast) {\n  var _ast$name;\n\n  var name = (_ast$name = ast.name) === null || _ast$name === void 0 ? void 0 : _ast$name.value;\n\n  if (typeof name !== 'string') {\n    throw createCompilerError(\"Expected ast node to have a 'name'.\", null, [ast]);\n  }\n\n  return name;\n}\n\nfunction getTypeName(ast) {\n  return ast ? print(ast) : 'Undefined Type Name';\n}\n/**\n * @private\n */\n\n\nfunction getFragmentType(ast) {\n  if (ast.kind === 'FragmentDefinition') {\n    return ast.typeCondition;\n  }\n\n  throw createCompilerError('Expected ast node to be a FragmentDefinition node.', null, [ast]);\n}\n\nfunction checkFragmentSpreadTypeCompatibility(schema, fragmentType, parentType, fragmentName, fragmentTypeAST, parentTypeAST) {\n  if (!schema.doTypesOverlap(fragmentType, schema.assertCompositeType(parentType))) {\n    var nodes = [];\n\n    if (parentTypeAST) {\n      nodes.push(parentTypeAST);\n    }\n\n    if (fragmentTypeAST) {\n      nodes.push(fragmentTypeAST);\n    }\n\n    var possibleConcreteTypes = schema.isAbstractType(parentType) ? Array.from(schema.getPossibleTypes(schema.assertAbstractType(parentType))) : [];\n    var suggestedTypesMessage = '';\n\n    if (possibleConcreteTypes.length !== 0) {\n      suggestedTypesMessage = \" Possible concrete types include \".concat(possibleConcreteTypes.sort().slice(0, 3).map(function (type) {\n        return \"'\".concat(schema.getTypeString(type), \"'\");\n      }).join(', '), \", etc.\");\n    }\n\n    throw createUserError((fragmentName != null ? \"Fragment '\".concat(fragmentName, \"' cannot be spread here as objects of \") : 'Fragment cannot be spread here as objects of ') + \"type '\".concat(schema.getTypeString(parentType), \"' \") + \"can never be of type '\".concat(schema.getTypeString(fragmentType), \"'.\") + suggestedTypesMessage, null, nodes);\n  }\n}\n\nmodule.exports = {\n  parse: parse,\n  transform: transform\n};","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/relay-compiler/lib/core/RelayParser.js"],"names":["_interopRequireDefault","require","_defineProperty2","_toConsumableArray2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_createForOfIteratorHelper","o","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","F","s","n","done","value","e","_e","f","TypeError","it","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","Profiler","orList","partitionArray","_require","DEFAULT_HANDLE_KEY","_require2","createCompilerError","createUserError","eachWithCombinedError","_require3","isExecutableDefinitionAST","_require4","getFieldDefinitionLegacy","_require5","parseGraphQL","parse","parseType","print","Source","ARGUMENT_DEFINITIONS","ARGUMENTS","DEPRECATED_UNCHECKED_ARGUMENTS","DIRECTIVE_WHITELIST","Set","CLIENT_FIELD","CLIENT_FIELD_HANDLE","CLIENT_FIELD_KEY","CLIENT_FIELD_FILTERS","INCLUDE","SKIP","IF","schema","text","filename","ast","parser","RelayParser","extend","definitions","transform","run","_this","_definitions","Map","_getFieldDefinition","_schema","duplicated","def","getName","has","add","set","size","concat","join","_proto","_this2","nodes","entries","_ref","definition","variableDefinitions","_buildArgumentDefinitions","values","_ref2","node","parseDefinition","kind","_buildOperationArgumentDefinitions","_buildFragmentArgumentDefinitions","fragment","_this3","variableDirectives","directives","directive","variableDirective","args","variables","arg","_defaultValue$value","argName","previousVariable","get","defaultValueNode","typeString","fields","field","transformLiteralValue","typeFromAST","getTypeFromAST","type","asInputType","defaultValue","transformValue","variableAst","loc","defined","operation","variable","getTypeName","previousDefinition","getFieldDefinition","GraphQLDefinitionParser","_definition","_entries","_variableDefinitions","_unknownVariables","_proto2","_transformOperation","_transformFragment","_recordAndVerifyVariableReference","usedAsType","variableDefinition","effectiveType","getNonNullType","getNullableType","isTypeSubTypeOf","String","previous","previousType","_getDirectiveLocations","_directiveLocations","directiveDefs","getDirectives","_iterator","_step","locations","_validateDirectivesLocation","allowedLocaction","directiveLocs","mismatches","locs","some","invalidDirectives","map","_transformDirectives","typeCondition","asCompositeType","selections","_transformSelections","selectionSet","argumentDefinitions","buildArgumentDefinitions","_iterator2","_step2","_step2$value","variableReference","buildLocation","metadata","_getLocationFromOperation","expectQueryType","expectMutationType","expectSubscriptionType","parentType","parentTypeAST","_this4","selection","_transformField","_transformFragmentSpread","_transformInlineFragment","_this4$_splitConditio","_splitConditions","conditions","conditionalNodes","applyConditions","_fragment$typeConditi","typeConditionName","getTypeString","_fragment$typeConditi2","rawParentType","assertCompositeType","getRawType","checkFragmentSpreadTypeCompatibility","fragmentSpread","_this5","fragmentName","_partitionArray","argumentDirectives","otherDirectives","fragmentDefinition","fragmentTypeNode","getFragmentType","fragmentType","expectTypeFromAST","fragmentArgumentDefinitions","argumentsDirective","isDeprecatedUncheckedArguments","hasInvalidArgument","_argumentDefinition$t","argValue","argumentDefinition","argumentType","_transformVariable","_transformValue","_field$alias$value","_field$alias","fieldDef","alias","_transformArguments","getFieldArgs","_partitionArray2","clientFieldDirectives","getFieldType","handles","_transformHandle","isLeafType","assertScalarFieldType","connection","assertLinkedFieldType","fieldName","fieldArgs","clientFieldDirective","handleArgument","find","filters","maybeHandle","keyArgument","maybeKey","filtersArgument","maybeFilters","every","fieldArg","dynamicKeyArgument","dynamicKey","location","_this6","directiveDef","getDirective","item","directiveName","_this7","argDef","message","getFieldName","getFieldParentType","mixedDirectives","_partitionArray3","conditionDirectives","passingValue","condition","sortedConditions","sort","a","b","variableName","_this8","variableType","transformVariable","isNonNull","transformNonNullLiteral","nullableType","isList","isInputType","getListItemType","assertInputType","itemType","literalList","items","areAllItemsScalar","itemValue","isInputObject","literalObject","areAllFieldsScalar","inputType","assertInputObjectType","requiredFieldNames","getFields","seenFields","seenField","fieldID","getFieldByName","fieldConfig","getFieldConfig","fieldType","fieldValue","requiredFieldStr","isId","parseInt","isEnum","enumType","assertEnumType","parseLiteral","suggestions","getEnumValues","isScalar","_value","assertScalarType","context","parseFloat","objectValue","_ref3","start","end","nextSelections","_ast$name","fragmentTypeAST","doTypesOverlap","possibleConcreteTypes","isAbstractType","getPossibleTypes","assertAbstractType","suggestedTypesMessage","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar Profiler = require('./GraphQLCompilerProfiler');\n\nvar orList = require('../util/orList');\n\nvar partitionArray = require('../util/partitionArray');\n\nvar _require = require('../util/DefaultHandleKey'),\n    DEFAULT_HANDLE_KEY = _require.DEFAULT_HANDLE_KEY;\n\nvar _require2 = require('./CompilerError'),\n    createCompilerError = _require2.createCompilerError,\n    createUserError = _require2.createUserError,\n    eachWithCombinedError = _require2.eachWithCombinedError;\n\nvar _require3 = require('./SchemaUtils'),\n    isExecutableDefinitionAST = _require3.isExecutableDefinitionAST;\n\nvar _require4 = require('./getFieldDefinition'),\n    getFieldDefinitionLegacy = _require4.getFieldDefinitionLegacy;\n\nvar _require5 = require('graphql'),\n    parseGraphQL = _require5.parse,\n    parseType = _require5.parseType,\n    print = _require5.print,\n    Source = _require5.Source;\n\nvar ARGUMENT_DEFINITIONS = 'argumentDefinitions';\nvar ARGUMENTS = 'arguments';\nvar DEPRECATED_UNCHECKED_ARGUMENTS = 'uncheckedArguments_DEPRECATED';\nvar DIRECTIVE_WHITELIST = new Set([ARGUMENT_DEFINITIONS, DEPRECATED_UNCHECKED_ARGUMENTS, ARGUMENTS]);\n/**\n * @internal\n *\n * This directive is not intended for use by developers directly. To set a field\n * handle in product code use a compiler plugin.\n */\n\nvar CLIENT_FIELD = '__clientField';\nvar CLIENT_FIELD_HANDLE = 'handle';\nvar CLIENT_FIELD_KEY = 'key';\nvar CLIENT_FIELD_FILTERS = 'filters';\nvar INCLUDE = 'include';\nvar SKIP = 'skip';\nvar IF = 'if';\n/**\n * Transforms GraphQL text into Relay Compiler's internal, strongly-typed\n * intermediate representation (IR).\n */\n\nfunction parse(schema, text, filename) {\n  var ast = parseGraphQL(new Source(text, filename));\n  var parser = new RelayParser(schema.extend(ast), ast.definitions);\n  return parser.transform();\n}\n/**\n * Transforms untyped GraphQL parse trees (ASTs) into Relay Compiler's\n * internal, strongly-typed intermediate representation (IR).\n */\n\n\nfunction transform(schema, definitions) {\n  return Profiler.run('RelayParser.transform', function () {\n    var parser = new RelayParser(schema, definitions);\n    return parser.transform();\n  });\n}\n/**\n * @private\n */\n\n\nvar RelayParser = /*#__PURE__*/function () {\n  function RelayParser(schema, definitions) {\n    var _this = this;\n\n    this._definitions = new Map(); // leaving this configurable to make it easy to experiment w changing later\n\n    this._getFieldDefinition = getFieldDefinitionLegacy;\n    this._schema = schema;\n    var duplicated = new Set();\n    definitions.forEach(function (def) {\n      if (isExecutableDefinitionAST(def)) {\n        var name = getName(def);\n\n        if (_this._definitions.has(name)) {\n          duplicated.add(name);\n          return;\n        }\n\n        _this._definitions.set(name, def);\n      }\n    });\n\n    if (duplicated.size) {\n      throw createUserError('RelayParser: Encountered duplicate definitions for one or more ' + 'documents: each document must have a unique name. Duplicated documents:\\n' + Array.from(duplicated, function (name) {\n        return \"- \".concat(name);\n      }).join('\\n'));\n    }\n  }\n\n  var _proto = RelayParser.prototype;\n\n  _proto.transform = function transform() {\n    var _this2 = this;\n\n    var nodes = [];\n    var entries = new Map(); // Construct a mapping of name to definition ast + variable definitions.\n    // This allows the subsequent AST -> IR tranformation to reference the\n    // defined arguments of referenced fragments.\n\n    eachWithCombinedError(this._definitions, function (_ref) {\n      var name = _ref[0],\n          definition = _ref[1];\n\n      var variableDefinitions = _this2._buildArgumentDefinitions(definition);\n\n      entries.set(name, {\n        definition: definition,\n        variableDefinitions: variableDefinitions\n      });\n    }); // Convert the ASTs to IR.\n\n    eachWithCombinedError(entries.values(), function (_ref2) {\n      var definition = _ref2.definition,\n          variableDefinitions = _ref2.variableDefinitions;\n      var node = parseDefinition(_this2._schema, _this2._getFieldDefinition, entries, definition, variableDefinitions);\n      nodes.push(node);\n    });\n    return nodes;\n  }\n  /**\n   * Constructs a mapping of variable names to definitions for the given\n   * operation/fragment definition.\n   */\n  ;\n\n  _proto._buildArgumentDefinitions = function _buildArgumentDefinitions(definition) {\n    switch (definition.kind) {\n      case 'OperationDefinition':\n        return this._buildOperationArgumentDefinitions(definition);\n\n      case 'FragmentDefinition':\n        return this._buildFragmentArgumentDefinitions(definition);\n\n      default:\n        definition;\n        throw createCompilerError(\"Unexpected ast kind '\".concat(definition.kind, \"'.\"), [definition]);\n    }\n  }\n  /**\n   * Constructs a mapping of variable names to definitions using the\n   * variables defined in `@argumentDefinitions`.\n   */\n  ;\n\n  _proto._buildFragmentArgumentDefinitions = function _buildFragmentArgumentDefinitions(fragment) {\n    var _this3 = this;\n\n    var variableDirectives = (fragment.directives || []).filter(function (directive) {\n      return getName(directive) === ARGUMENT_DEFINITIONS;\n    });\n\n    if (!variableDirectives.length) {\n      return new Map();\n    }\n\n    if (variableDirectives.length !== 1) {\n      throw createUserError(\"Directive @\".concat(ARGUMENT_DEFINITIONS, \" may be defined at most once per \") + 'fragment.', null, variableDirectives);\n    }\n\n    var variableDirective = variableDirectives[0]; // work, below accesses all report arguments could still be null/undefined.\n\n    var args = variableDirective.arguments;\n\n    if (variableDirective == null || !Array.isArray(args)) {\n      return new Map();\n    }\n\n    if (!args.length) {\n      throw createUserError(\"Directive @\".concat(ARGUMENT_DEFINITIONS, \" requires arguments: remove the \") + 'directive to skip defining local variables for this fragment.', null, [variableDirective]);\n    }\n\n    var variables = new Map();\n    args.forEach(function (arg) {\n      var _defaultValue$value;\n\n      var argName = getName(arg);\n      var previousVariable = variables.get(argName);\n\n      if (previousVariable != null) {\n        throw createUserError(\"Duplicate definition for variable '$\".concat(argName, \"'.\"), null, [previousVariable.ast, arg]);\n      }\n\n      if (arg.value.kind !== 'ObjectValue') {\n        throw createUserError(\"Expected definition for variable '$\".concat(argName, \"' to be an object \") + \"with the shape: '{type: string, defaultValue?: mixed}.\", null, [arg.value]);\n      }\n\n      var defaultValueNode;\n      var typeString;\n      arg.value.fields.forEach(function (field) {\n        var name = getName(field);\n\n        if (name === 'type') {\n          typeString = transformLiteralValue(field.value, field);\n        } else if (name === 'defaultValue') {\n          defaultValueNode = field.value;\n        } else {\n          throw createUserError(\"Expected definition for variable '$\".concat(argName, \"' to be an object \") + \"with the shape: '{type: string, defaultValue?: mixed}.\", null, [arg.value]);\n        }\n      });\n\n      if (typeof typeString !== 'string') {\n        throw createUserError(\"Expected definition for variable '$\".concat(argName, \"' to be an object \") + \"with the shape: '{type: string, defaultValue?: mixed}.\", null, [arg.value]);\n      }\n\n      var typeFromAST = _this3._schema.getTypeFromAST(parseType(typeString));\n\n      if (typeFromAST == null) {\n        throw createUserError(\"Unknown type \\\"\".concat(typeString, \"\\\" referenced in the argument definitions.\"), null, [arg]);\n      }\n\n      var type = _this3._schema.asInputType(typeFromAST);\n\n      if (type == null) {\n        throw createUserError(\"Expected type \\\"\".concat(typeString, \"\\\" to be an input type in the \\\"\").concat(arg.name.value, \"\\\" argument definitions.\"), null, [arg.value]);\n      }\n\n      var defaultValue = defaultValueNode != null ? transformValue(_this3._schema, defaultValueNode, type, function (variableAst) {\n        throw createUserError(\"Expected 'defaultValue' to be a literal, got a variable.\", null, [variableAst]);\n      }) : null;\n\n      if (defaultValue != null && defaultValue.kind !== 'Literal') {\n        throw createUserError(\"Expected 'defaultValue' to be a literal, got a variable.\", [defaultValue.loc]);\n      }\n\n      variables.set(argName, {\n        ast: arg,\n        defaultValue: (_defaultValue$value = defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.value) !== null && _defaultValue$value !== void 0 ? _defaultValue$value : null,\n        defined: true,\n        name: argName,\n        type: type\n      });\n    });\n    return variables;\n  }\n  /**\n   * Constructs a mapping of variable names to definitions using the\n   * standard GraphQL syntax for variable definitions.\n   */\n  ;\n\n  _proto._buildOperationArgumentDefinitions = function _buildOperationArgumentDefinitions(operation) {\n    var schema = this._schema;\n    var variableDefinitions = new Map();\n    (operation.variableDefinitions || []).forEach(function (def) {\n      var name = getName(def.variable);\n      var typeFromAST = schema.getTypeFromAST(def.type);\n\n      if (typeFromAST == null) {\n        throw createUserError(\"Unknown type: '\".concat(getTypeName(def.type), \"'.\"), null, [def.type]);\n      }\n\n      var type = schema.asInputType(typeFromAST);\n\n      if (type == null) {\n        throw createUserError(\"Expected type \\\"\".concat(getTypeName(def.type), \"\\\" to be an input type.\"), null, [def.type]);\n      }\n\n      var defaultValue = def.defaultValue ? transformLiteralValue(def.defaultValue, def) : null;\n      var previousDefinition = variableDefinitions.get(name);\n\n      if (previousDefinition != null) {\n        throw createUserError(\"Duplicate definition for variable '$\".concat(name, \"'.\"), null, [previousDefinition.ast, def]);\n      }\n\n      variableDefinitions.set(name, {\n        ast: def,\n        defaultValue: defaultValue,\n        defined: true,\n        name: name,\n        type: type\n      });\n    });\n    return variableDefinitions;\n  };\n\n  return RelayParser;\n}();\n/**\n * @private\n */\n\n\nfunction parseDefinition(schema, getFieldDefinition, entries, definition, variableDefinitions) {\n  var parser = new GraphQLDefinitionParser(schema, getFieldDefinition, entries, definition, variableDefinitions);\n  return parser.transform();\n}\n/**\n * @private\n */\n\n\nvar GraphQLDefinitionParser = /*#__PURE__*/function () {\n  function GraphQLDefinitionParser(schema, getFieldDefinition, entries, definition, variableDefinitions) {\n    this._definition = definition;\n    this._entries = entries;\n    this._getFieldDefinition = getFieldDefinition;\n    this._schema = schema;\n    this._variableDefinitions = variableDefinitions;\n    this._unknownVariables = new Map();\n  }\n\n  var _proto2 = GraphQLDefinitionParser.prototype;\n\n  _proto2.transform = function transform() {\n    var definition = this._definition;\n\n    switch (definition.kind) {\n      case 'OperationDefinition':\n        return this._transformOperation(definition);\n\n      case 'FragmentDefinition':\n        return this._transformFragment(definition);\n\n      default:\n        definition;\n        throw createCompilerError(\"Unsupported definition type \".concat(definition.kind), [definition]);\n    }\n  };\n\n  _proto2._recordAndVerifyVariableReference = function _recordAndVerifyVariableReference(variable, name, usedAsType) {\n    // Special case for variables used in @arguments where we currently\n    // aren't guaranteed to be able to resolve the type.\n    if (usedAsType == null) {\n      if (!this._variableDefinitions.has(name) && !this._unknownVariables.has(name)) {\n        this._unknownVariables.set(name, {\n          ast: variable,\n          type: null\n        });\n      }\n\n      return;\n    }\n\n    var variableDefinition = this._variableDefinitions.get(name);\n\n    if (variableDefinition != null) {\n      // If the variable is defined, all usages must be compatible\n      var effectiveType = variableDefinition.type;\n\n      if (variableDefinition.defaultValue != null) {\n        // If a default value is defined then it is guaranteed to be used\n        // at runtime such that the effective type of the variable is non-null\n        effectiveType = this._schema.getNonNullType(this._schema.getNullableType(effectiveType));\n      }\n\n      if (!this._schema.isTypeSubTypeOf(effectiveType, usedAsType)) {\n        throw createUserError(\"Variable '$\".concat(name, \"' was defined as type '\").concat(String(variableDefinition.type), \"' but used in a location expecting the type '\").concat(String(usedAsType), \"'\"), null, [variableDefinition.ast, variable]);\n      }\n    } else {\n      var previous = this._unknownVariables.get(name);\n\n      if (!previous || !previous.type) {\n        // No previous usage, current type is strongest\n        this._unknownVariables.set(name, {\n          ast: variable,\n          type: usedAsType\n        });\n      } else {\n        var previousVariable = previous.ast,\n            previousType = previous.type;\n\n        if (!(this._schema.isTypeSubTypeOf(usedAsType, previousType) || this._schema.isTypeSubTypeOf(previousType, usedAsType))) {\n          throw createUserError(\"Variable '$\".concat(name, \"' was used in locations expecting the conflicting types '\").concat(String(previousType), \"' and '\").concat(String(usedAsType), \"'.\"), null, [previousVariable, variable]);\n        } // If the new used type has stronger requirements, use that type as reference,\n        // otherwise keep referencing the previous type\n\n\n        if (this._schema.isTypeSubTypeOf(usedAsType, previousType)) {\n          this._unknownVariables.set(name, {\n            ast: variable,\n            type: usedAsType\n          });\n        }\n      }\n    }\n  };\n\n  _proto2._getDirectiveLocations = function _getDirectiveLocations() {\n    if (!this._directiveLocations) {\n      var directiveDefs = this._schema.getDirectives();\n\n      this._directiveLocations = new Map();\n\n      var _iterator = _createForOfIteratorHelper(directiveDefs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var def = _step.value;\n\n          this._directiveLocations.set(def.name, def.locations);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n\n    return this._directiveLocations;\n  };\n\n  _proto2._validateDirectivesLocation = function _validateDirectivesLocation(directives, allowedLocaction) {\n    if (!directives || !directives.length) {\n      return;\n    }\n\n    var directiveLocs = this._getDirectiveLocations();\n\n    var mismatches = directives.filter(function (directive) {\n      var name = getName(directive);\n\n      if (DIRECTIVE_WHITELIST.has(name)) {\n        return false;\n      }\n\n      var locs = directiveLocs.get(name);\n\n      if (locs == null) {\n        throw createUserError(\"Unknown directive '\".concat(name, \"'.\"), null, [directive]);\n      }\n\n      return !locs.some(function (loc) {\n        return loc === allowedLocaction;\n      });\n    });\n\n    if (mismatches.length) {\n      var invalidDirectives = mismatches.map(function (directive) {\n        return '@' + getName(directive);\n      }).join(', ');\n      throw createUserError(\"Invalid directives \".concat(invalidDirectives, \" found on \").concat(allowedLocaction, \".\"), null, mismatches);\n    }\n  };\n\n  _proto2._transformFragment = function _transformFragment(fragment) {\n    var directives = this._transformDirectives((fragment.directives || []).filter(function (directive) {\n      return getName(directive) !== ARGUMENT_DEFINITIONS;\n    }), 'FRAGMENT_DEFINITION');\n\n    var typeFromAST = this._schema.getTypeFromAST(fragment.typeCondition);\n\n    if (typeFromAST == null) {\n      throw createUserError(\"Fragment \\\"\".concat(fragment.name.value, \"\\\" cannot condition on unknown \") + \"type \\\"\".concat(String(fragment.typeCondition.name.value), \"\\\".\"), null, [fragment.typeCondition]);\n    }\n\n    var type = this._schema.asCompositeType(typeFromAST);\n\n    if (type == null) {\n      throw createUserError(\"Fragment \\\"\".concat(fragment.name.value, \"\\\" cannot condition on non composite \") + \"type \\\"\".concat(String(type), \"\\\".\"), null, [fragment.typeCondition]);\n    }\n\n    var selections = this._transformSelections(fragment.selectionSet, type, fragment.typeCondition);\n\n    var argumentDefinitions = (0, _toConsumableArray2[\"default\"])(buildArgumentDefinitions(this._variableDefinitions));\n\n    var _iterator2 = _createForOfIteratorHelper(this._unknownVariables),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _step2.value,\n            name = _step2$value[0],\n            variableReference = _step2$value[1];\n        argumentDefinitions.push({\n          kind: 'RootArgumentDefinition',\n          loc: buildLocation(variableReference.ast.loc),\n          name: name,\n          type: variableReference.type\n        });\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return {\n      kind: 'Fragment',\n      directives: directives,\n      loc: buildLocation(fragment.loc),\n      metadata: null,\n      name: getName(fragment),\n      selections: selections,\n      type: type,\n      // $FlowFixMe[incompatible-return] - could be null\n      argumentDefinitions: argumentDefinitions\n    };\n  };\n\n  _proto2._getLocationFromOperation = function _getLocationFromOperation(definition) {\n    switch (definition.operation) {\n      case 'query':\n        return 'QUERY';\n\n      case 'mutation':\n        return 'MUTATION';\n\n      case 'subscription':\n        return 'SUBSCRIPTION';\n\n      default:\n        definition.operation;\n        throw createCompilerError(\"Unknown operation type '\".concat(definition.operation, \"'.\"), null, [definition]);\n    }\n  };\n\n  _proto2._transformOperation = function _transformOperation(definition) {\n    var name = getName(definition);\n\n    var directives = this._transformDirectives(definition.directives || [], this._getLocationFromOperation(definition));\n\n    var type;\n    var operation;\n    var schema = this._schema;\n\n    switch (definition.operation) {\n      case 'query':\n        operation = 'query';\n        type = schema.expectQueryType();\n        break;\n\n      case 'mutation':\n        operation = 'mutation';\n        type = schema.expectMutationType();\n        break;\n\n      case 'subscription':\n        operation = 'subscription';\n        type = schema.expectSubscriptionType();\n        break;\n\n      default:\n        definition.operation;\n        throw createCompilerError(\"Unknown operation type '\".concat(definition.operation, \"'.\"), null, [definition]);\n    }\n\n    if (!definition.selectionSet) {\n      throw createUserError('Expected operation to have selections.', null, [definition]);\n    }\n\n    var selections = this._transformSelections(definition.selectionSet, type);\n\n    var argumentDefinitions = buildArgumentDefinitions(this._variableDefinitions);\n\n    if (this._unknownVariables.size !== 0) {\n      throw createUserError(\"Query '\".concat(name, \"' references undefined variables.\"), null, Array.from(this._unknownVariables.values(), function (variableReference) {\n        return variableReference.ast;\n      }));\n    }\n\n    return {\n      kind: 'Root',\n      operation: operation,\n      loc: buildLocation(definition.loc),\n      metadata: null,\n      name: name,\n      argumentDefinitions: argumentDefinitions,\n      directives: directives,\n      selections: selections,\n      type: type\n    };\n  };\n\n  _proto2._transformSelections = function _transformSelections(selectionSet, parentType, parentTypeAST) {\n    var _this4 = this;\n\n    return selectionSet.selections.map(function (selection) {\n      var node;\n\n      if (selection.kind === 'Field') {\n        node = _this4._transformField(selection, parentType);\n      } else if (selection.kind === 'FragmentSpread') {\n        node = _this4._transformFragmentSpread(selection, parentType, parentTypeAST);\n      } else if (selection.kind === 'InlineFragment') {\n        node = _this4._transformInlineFragment(selection, parentType, parentTypeAST);\n      } else {\n        selection.kind;\n        throw createCompilerError(\"Unknown ast kind '\".concat(selection.kind, \"'.\"), [selection]);\n      }\n\n      var _this4$_splitConditio = _this4._splitConditions(node.directives),\n          conditions = _this4$_splitConditio[0],\n          directives = _this4$_splitConditio[1];\n\n      var conditionalNodes = applyConditions(conditions, // $FlowFixMe[incompatible-call]\n      [_objectSpread({}, node, {\n        directives: directives\n      })]);\n\n      if (conditionalNodes.length !== 1) {\n        throw createCompilerError('Expected exactly one condition node.', null, selection.directives);\n      }\n\n      return conditionalNodes[0];\n    });\n  };\n\n  _proto2._transformInlineFragment = function _transformInlineFragment(fragment, parentType, parentTypeAST) {\n    var schema = this._schema;\n    var typeCondition = fragment.typeCondition != null ? schema.getTypeFromAST(fragment.typeCondition) : parentType;\n\n    if (typeCondition == null) {\n      var _fragment$typeConditi;\n\n      throw createUserError('Inline fragments can only be on object, interface or union types' + \", got unknown type '\".concat(getTypeName(fragment.typeCondition), \"'.\"), null, [(_fragment$typeConditi = fragment.typeCondition) !== null && _fragment$typeConditi !== void 0 ? _fragment$typeConditi : fragment]);\n    }\n\n    var typeConditionName = schema.getTypeString(typeCondition);\n    typeCondition = schema.asCompositeType(typeCondition);\n\n    if (typeCondition == null) {\n      var _fragment$typeConditi2;\n\n      throw createUserError('Inline fragments can only be on object, interface or union types' + \", got '\".concat(typeConditionName, \"'.\"), null, [(_fragment$typeConditi2 = fragment.typeCondition) !== null && _fragment$typeConditi2 !== void 0 ? _fragment$typeConditi2 : fragment]);\n    }\n\n    var rawParentType = this._schema.assertCompositeType(this._schema.getRawType(parentType));\n\n    checkFragmentSpreadTypeCompatibility(this._schema, typeCondition, rawParentType, null, fragment.typeCondition, parentTypeAST);\n\n    var directives = this._transformDirectives(fragment.directives || [], 'INLINE_FRAGMENT');\n\n    var selections = this._transformSelections(fragment.selectionSet, typeCondition, fragment.typeCondition);\n\n    return {\n      kind: 'InlineFragment',\n      directives: directives,\n      loc: buildLocation(fragment.loc),\n      metadata: null,\n      selections: selections,\n      typeCondition: typeCondition\n    };\n  };\n\n  _proto2._transformFragmentSpread = function _transformFragmentSpread(fragmentSpread, parentType, parentTypeAST) {\n    var _this5 = this;\n\n    var fragmentName = getName(fragmentSpread);\n\n    var _partitionArray = partitionArray(fragmentSpread.directives || [], function (directive) {\n      var name = getName(directive);\n      return name === ARGUMENTS || name === DEPRECATED_UNCHECKED_ARGUMENTS;\n    }),\n        argumentDirectives = _partitionArray[0],\n        otherDirectives = _partitionArray[1];\n\n    if (argumentDirectives.length > 1) {\n      throw createUserError(\"Directive @\".concat(ARGUMENTS, \" may be used at most once per a fragment spread.\"), null, argumentDirectives);\n    }\n\n    var fragmentDefinition = this._entries.get(fragmentName);\n\n    if (fragmentDefinition == null) {\n      throw createUserError(\"Unknown fragment '\".concat(fragmentName, \"'.\"), null, [fragmentSpread.name]);\n    }\n\n    var fragmentTypeNode = getFragmentType(fragmentDefinition.definition);\n\n    var fragmentType = this._schema.assertCompositeType(this._schema.expectTypeFromAST(fragmentTypeNode));\n\n    var rawParentType = this._schema.assertCompositeType(this._schema.getRawType(parentType));\n\n    checkFragmentSpreadTypeCompatibility(this._schema, fragmentType, rawParentType, fragmentSpread.name.value, fragmentSpread, parentTypeAST);\n    var fragmentArgumentDefinitions = fragmentDefinition.variableDefinitions;\n    var argumentsDirective = argumentDirectives[0];\n    var args;\n\n    if (argumentsDirective != null) {\n      var isDeprecatedUncheckedArguments = getName(argumentsDirective) === DEPRECATED_UNCHECKED_ARGUMENTS;\n      var hasInvalidArgument = false;\n      args = (argumentsDirective.arguments || []).map(function (arg) {\n        var _argumentDefinition$t;\n\n        var argName = getName(arg);\n        var argValue = arg.value;\n        var argumentDefinition = fragmentArgumentDefinitions.get(argName);\n        var argumentType = (_argumentDefinition$t = argumentDefinition === null || argumentDefinition === void 0 ? void 0 : argumentDefinition.type) !== null && _argumentDefinition$t !== void 0 ? _argumentDefinition$t : null;\n\n        if (argValue.kind === 'Variable') {\n          if (argumentDefinition == null && !isDeprecatedUncheckedArguments) {\n            throw createUserError(\"Variable @\".concat(ARGUMENTS, \" values are only supported when the \") + \"argument is defined with @\".concat(ARGUMENT_DEFINITIONS, \". Check \") + \"the definition of fragment '\".concat(fragmentName, \"'.\"), null, [arg.value, fragmentDefinition.definition]);\n          }\n\n          hasInvalidArgument = hasInvalidArgument || argumentDefinition == null; // TODO: check the type of the variable and use the type\n\n          return {\n            kind: 'Argument',\n            loc: buildLocation(arg.loc),\n            name: argName,\n            value: _this5._transformVariable(argValue, null),\n            type: null\n          };\n        } else {\n          if (argumentType == null) {\n            throw createUserError(\"Literal @\".concat(ARGUMENTS, \" values are only supported when the \") + \"argument is defined with @\".concat(ARGUMENT_DEFINITIONS, \". Check \") + \"the definition of fragment '\".concat(fragmentName, \"'.\"), null, [arg.value, fragmentDefinition.definition]);\n          }\n\n          var value = _this5._transformValue(argValue, argumentType);\n\n          return {\n            kind: 'Argument',\n            loc: buildLocation(arg.loc),\n            name: argName,\n            value: value,\n            type: argumentType\n          };\n        }\n      });\n\n      if (isDeprecatedUncheckedArguments && !hasInvalidArgument) {\n        throw createUserError(\"Invalid use of @\".concat(DEPRECATED_UNCHECKED_ARGUMENTS, \": all arguments \") + \"are defined, use @\".concat(ARGUMENTS, \" instead.\"), null, [argumentsDirective]);\n      }\n    }\n\n    var directives = this._transformDirectives(otherDirectives, 'FRAGMENT_SPREAD');\n\n    return {\n      kind: 'FragmentSpread',\n      args: args || [],\n      metadata: null,\n      loc: buildLocation(fragmentSpread.loc),\n      name: fragmentName,\n      directives: directives\n    };\n  };\n\n  _proto2._transformField = function _transformField(field, parentType) {\n    var _field$alias$value, _field$alias;\n\n    var schema = this._schema;\n    var name = getName(field);\n\n    var fieldDef = this._getFieldDefinition(schema, parentType, name, field);\n\n    if (fieldDef == null) {\n      throw createUserError(\"Unknown field '\".concat(name, \"' on type '\").concat(schema.getTypeString(parentType), \"'.\"), null, [field]);\n    }\n\n    var alias = (_field$alias$value = (_field$alias = field.alias) === null || _field$alias === void 0 ? void 0 : _field$alias.value) !== null && _field$alias$value !== void 0 ? _field$alias$value : name;\n\n    var args = this._transformArguments(field.arguments || [], schema.getFieldArgs(fieldDef), fieldDef);\n\n    var _partitionArray2 = partitionArray(field.directives || [], function (directive) {\n      return getName(directive) !== CLIENT_FIELD;\n    }),\n        otherDirectives = _partitionArray2[0],\n        clientFieldDirectives = _partitionArray2[1];\n\n    var directives = this._transformDirectives(otherDirectives, 'FIELD');\n\n    var type = schema.getFieldType(fieldDef);\n\n    var handles = this._transformHandle(name, args, clientFieldDirectives);\n\n    if (schema.isLeafType(schema.getRawType(type))) {\n      if (field.selectionSet && field.selectionSet.selections && field.selectionSet.selections.length) {\n        throw createUserError(\"Expected no selections for scalar field '\".concat(name, \"'.\"), null, [field]);\n      }\n\n      return {\n        kind: 'ScalarField',\n        alias: alias,\n        args: args,\n        directives: directives,\n        handles: handles,\n        loc: buildLocation(field.loc),\n        metadata: null,\n        name: name,\n        type: schema.assertScalarFieldType(type)\n      };\n    } else {\n      var selections = field.selectionSet ? this._transformSelections(field.selectionSet, type) : null;\n\n      if (selections == null || selections.length === 0) {\n        throw createUserError(\"Expected at least one selection for non-scalar field '\".concat(name, \"' on type '\").concat(schema.getTypeString(type), \"'.\"), null, [field]);\n      }\n\n      return {\n        kind: 'LinkedField',\n        alias: alias,\n        args: args,\n        connection: false,\n        directives: directives,\n        handles: handles,\n        loc: buildLocation(field.loc),\n        metadata: null,\n        name: name,\n        selections: selections,\n        type: schema.assertLinkedFieldType(type)\n      };\n    }\n  };\n\n  _proto2._transformHandle = function _transformHandle(fieldName, fieldArgs, clientFieldDirectives) {\n    var handles = null;\n    clientFieldDirectives.forEach(function (clientFieldDirective) {\n      var handleArgument = (clientFieldDirective.arguments || []).find(function (arg) {\n        return getName(arg) === CLIENT_FIELD_HANDLE;\n      });\n\n      if (handleArgument) {\n        var name = null;\n        var key = DEFAULT_HANDLE_KEY;\n        var filters = null;\n        var maybeHandle = transformLiteralValue(handleArgument.value, handleArgument);\n\n        if (typeof maybeHandle !== 'string') {\n          throw createUserError(\"Expected a string literal argument for the @\".concat(CLIENT_FIELD, \" directive.\"), null, [handleArgument.value]);\n        }\n\n        name = maybeHandle;\n        var keyArgument = (clientFieldDirective.arguments || []).find(function (arg) {\n          return getName(arg) === CLIENT_FIELD_KEY;\n        });\n\n        if (keyArgument) {\n          var maybeKey = transformLiteralValue(keyArgument.value, keyArgument);\n\n          if (typeof maybeKey !== 'string') {\n            throw createUserError(\"Expected a string literal argument for the @\".concat(CLIENT_FIELD, \" directive.\"), null, [keyArgument.value]);\n          }\n\n          key = maybeKey;\n        }\n\n        var filtersArgument = (clientFieldDirective.arguments || []).find(function (arg) {\n          return getName(arg) === CLIENT_FIELD_FILTERS;\n        });\n\n        if (filtersArgument) {\n          var maybeFilters = transformLiteralValue(filtersArgument.value, filtersArgument);\n\n          if (!(Array.isArray(maybeFilters) && maybeFilters.every(function (filter) {\n            return typeof filter === 'string' && fieldArgs.some(function (fieldArg) {\n              return fieldArg.name === filter;\n            });\n          }))) {\n            throw createUserError(\"Expected an array of argument names on field '\".concat(fieldName, \"'.\"), null, [filtersArgument.value]);\n          } // $FlowFixMe[incompatible-cast]\n\n\n          filters = maybeFilters;\n        }\n\n        var dynamicKeyArgument = (clientFieldDirective.arguments || []).find(function (arg) {\n          return getName(arg) === 'dynamicKey_UNSTABLE';\n        });\n\n        if (dynamicKeyArgument != null) {\n          throw createUserError('Dynamic keys are only supported with @connection.', null, [dynamicKeyArgument.value]);\n        }\n\n        handles = handles || [];\n        handles.push({\n          name: name,\n          key: key,\n          filters: filters,\n          dynamicKey: null\n        });\n      }\n    });\n    return handles;\n  };\n\n  _proto2._transformDirectives = function _transformDirectives(directives, location) {\n    var _this6 = this;\n\n    this._validateDirectivesLocation(directives, location);\n\n    return directives.map(function (directive) {\n      var name = getName(directive);\n\n      var directiveDef = _this6._schema.getDirective(name);\n\n      if (directiveDef == null) {\n        throw createUserError(\"Unknown directive '\".concat(name, \"'.\"), null, [directive]);\n      }\n\n      var args = _this6._transformArguments(directive.arguments || [], directiveDef.args.map(function (item) {\n        return {\n          name: item.name,\n          type: item.type,\n          defaultValue: item.defaultValue\n        };\n      }), null, name);\n\n      return {\n        kind: 'Directive',\n        loc: buildLocation(directive.loc),\n        name: name,\n        args: args\n      };\n    });\n  };\n\n  _proto2._transformArguments = function _transformArguments(args, argumentDefinitions, field, directiveName) {\n    var _this7 = this;\n\n    return args.map(function (arg) {\n      var argName = getName(arg);\n      var argDef = argumentDefinitions.find(function (def) {\n        return def.name === argName;\n      });\n\n      if (argDef == null) {\n        var message = \"Unknown argument '\".concat(argName, \"'\") + (field ? \" on field '\".concat(_this7._schema.getFieldName(field), \"'\") + \" of type '\".concat(_this7._schema.getTypeString(_this7._schema.getFieldParentType(field)), \"'.\") : directiveName != null ? \" on directive '@\".concat(directiveName, \"'.\") : '.');\n        throw createUserError(message, null, [arg]);\n      }\n\n      var value = _this7._transformValue(arg.value, argDef.type);\n\n      return {\n        kind: 'Argument',\n        loc: buildLocation(arg.loc),\n        name: argName,\n        value: value,\n        type: argDef.type\n      };\n    });\n  };\n\n  _proto2._splitConditions = function _splitConditions(mixedDirectives) {\n    var _partitionArray3 = partitionArray(mixedDirectives, function (directive) {\n      return directive.name === INCLUDE || directive.name === SKIP;\n    }),\n        conditionDirectives = _partitionArray3[0],\n        otherDirectives = _partitionArray3[1];\n\n    var conditions = conditionDirectives.map(function (directive) {\n      var passingValue = directive.name === INCLUDE;\n      var arg = directive.args[0];\n\n      if (arg == null || arg.name !== IF) {\n        throw createUserError(\"Expected an 'if' argument to @\".concat(directive.name, \".\"), [directive.loc]);\n      }\n\n      if (!(arg.value.kind === 'Variable' || arg.value.kind === 'Literal')) {\n        throw createUserError(\"Expected the 'if' argument to @\".concat(directive.name, \" to be a variable or literal.\"), [directive.loc]);\n      }\n\n      return {\n        kind: 'Condition',\n        condition: arg.value,\n        loc: directive.loc,\n        passingValue: passingValue,\n        selections: []\n      };\n    });\n    var sortedConditions = conditions.sort(function (a, b) {\n      if (a.condition.kind === 'Variable' && b.condition.kind === 'Variable') {\n        return a.condition.variableName < b.condition.variableName ? -1 : a.condition.variableName > b.condition.variableName ? 1 : 0;\n      } else {\n        // sort literals earlier, variables later\n        return a.condition.kind === 'Variable' ? 1 : b.condition.kind === 'Variable' ? -1 : 0;\n      }\n    });\n    return [sortedConditions, otherDirectives];\n  };\n\n  _proto2._transformVariable = function _transformVariable(ast, usedAsType) {\n    var variableName = getName(ast);\n\n    this._recordAndVerifyVariableReference(ast, variableName, usedAsType);\n\n    return {\n      kind: 'Variable',\n      loc: buildLocation(ast.loc),\n      variableName: variableName,\n      type: usedAsType\n    };\n  };\n\n  _proto2._transformValue = function _transformValue(ast, type) {\n    var _this8 = this;\n\n    return transformValue(this._schema, ast, type, function (variableAst, variableType) {\n      return _this8._transformVariable(variableAst, variableType);\n    });\n  };\n\n  return GraphQLDefinitionParser;\n}();\n/**\n * Transforms and validates argument values according to the expected\n * type.\n */\n\n\nfunction transformValue(schema, ast, type, transformVariable) {\n  if (ast.kind === 'Variable') {\n    // Special case variables since there is no value to parse\n    return transformVariable(ast, type);\n  } else if (ast.kind === 'NullValue') {\n    // Special case null literals since there is no value to parse\n    if (schema.isNonNull(type)) {\n      throw createUserError(\"Expected a value matching type '\".concat(String(type), \"'.\"), null, [ast]);\n    }\n\n    return {\n      kind: 'Literal',\n      loc: buildLocation(ast.loc),\n      value: null\n    };\n  } else {\n    return transformNonNullLiteral(schema, ast, type, transformVariable);\n  }\n}\n/**\n * Transforms and validates non-null literal (non-variable) values\n * according to the expected type.\n */\n\n\nfunction transformNonNullLiteral(schema, ast, type, transformVariable) {\n  // Transform the value based on the type without a non-null wrapper.\n  // Note that error messages should still use the original `type`\n  // since that accurately describes to the user what the expected\n  // type is (using nullableType would suggest that `null` is legal\n  // even when it may not be, for example).\n  var nullableType = schema.getNullableType(type);\n\n  if (schema.isList(nullableType)) {\n    if (ast.kind !== 'ListValue') {\n      // Parse singular (non-list) values flowing into a list type\n      // as scalars, ie without wrapping them in an array.\n      if (!schema.isInputType(schema.getListItemType(nullableType))) {\n        throw createUserError(\"Expected type \".concat(schema.getTypeString(nullableType), \" to be an input type.\"), null, [ast]);\n      }\n\n      return transformValue(schema, ast, schema.assertInputType(schema.getListItemType(nullableType)), transformVariable);\n    }\n\n    var itemType = schema.assertInputType(schema.getListItemType(nullableType));\n    var literalList = [];\n    var items = [];\n    var areAllItemsScalar = true;\n    ast.values.forEach(function (item) {\n      var itemValue = transformValue(schema, item, itemType, transformVariable);\n\n      if (itemValue.kind === 'Literal') {\n        literalList.push(itemValue.value);\n      }\n\n      items.push(itemValue);\n      areAllItemsScalar = areAllItemsScalar && itemValue.kind === 'Literal';\n    });\n\n    if (areAllItemsScalar) {\n      return {\n        kind: 'Literal',\n        loc: buildLocation(ast.loc),\n        value: literalList\n      };\n    } else {\n      return {\n        kind: 'ListValue',\n        loc: buildLocation(ast.loc),\n        items: items\n      };\n    }\n  } else if (schema.isInputObject(nullableType)) {\n    if (ast.kind !== 'ObjectValue') {\n      throw createUserError(\"Expected a value matching type '\".concat(schema.getTypeString(type), \"'.\"), null, [ast]);\n    }\n\n    var literalObject = {};\n    var fields = [];\n    var areAllFieldsScalar = true;\n    var inputType = schema.assertInputObjectType(nullableType);\n    var requiredFieldNames = new Set(schema.getFields(inputType).filter(function (field) {\n      return schema.isNonNull(schema.getFieldType(field));\n    }).map(function (field) {\n      return schema.getFieldName(field);\n    }));\n    var seenFields = new Map();\n    ast.fields.forEach(function (field) {\n      var fieldName = getName(field);\n      var seenField = seenFields.get(fieldName);\n\n      if (seenField) {\n        throw createUserError(\"Duplicated field name '\".concat(fieldName, \"' in the input object.\"), null, [field, seenField]);\n      }\n\n      var fieldID = schema.getFieldByName(inputType, fieldName);\n\n      if (!fieldID) {\n        throw createUserError(\"Unknown field '\".concat(fieldName, \"' on type '\").concat(schema.getTypeString(inputType), \"'.\"), null, [field]);\n      }\n\n      var fieldConfig = schema.getFieldConfig(fieldID);\n      var fieldType = schema.assertInputType(fieldConfig.type);\n      var fieldValue = transformValue(schema, field.value, fieldType, transformVariable);\n\n      if (fieldValue.kind === 'Literal') {\n        literalObject[field.name.value] = fieldValue.value;\n      }\n\n      fields.push({\n        kind: 'ObjectFieldValue',\n        loc: buildLocation(field.loc),\n        name: fieldName,\n        value: fieldValue\n      });\n      seenFields.set(fieldName, field);\n      requiredFieldNames[\"delete\"](fieldName);\n      areAllFieldsScalar = areAllFieldsScalar && fieldValue.kind === 'Literal';\n    });\n\n    if (requiredFieldNames.size > 0) {\n      var requiredFieldStr = Array.from(requiredFieldNames).map(function (item) {\n        return \"'\".concat(item, \"'\");\n      }).join(', ');\n      throw createUserError(\"Missing non-optional field\".concat(requiredFieldNames.size > 1 ? 's:' : '', \" \").concat(requiredFieldStr, \" for input type '\").concat(schema.getTypeString(inputType), \"'.\"), null, [ast]);\n    }\n\n    if (areAllFieldsScalar) {\n      return {\n        kind: 'Literal',\n        loc: buildLocation(ast.loc),\n        value: literalObject\n      };\n    } else {\n      return {\n        kind: 'ObjectValue',\n        loc: buildLocation(ast.loc),\n        fields: fields\n      };\n    }\n  } else if (schema.isId(nullableType)) {\n    // GraphQLID's parseLiteral() always returns the string value. However\n    // the int/string distinction may be important at runtime, so this\n    // transform parses int/string literals into the corresponding JS types.\n    if (ast.kind === 'IntValue') {\n      return {\n        kind: 'Literal',\n        loc: buildLocation(ast.loc),\n        value: parseInt(ast.value, 10)\n      };\n    } else if (ast.kind === 'StringValue') {\n      return {\n        kind: 'Literal',\n        loc: buildLocation(ast.loc),\n        value: ast.value\n      };\n    } else {\n      throw createUserError(\"Invalid value, expected a value matching type '\".concat(schema.getTypeString(type), \"'.\"), null, [ast]);\n    }\n  } else if (schema.isEnum(nullableType)) {\n    var enumType = schema.assertEnumType(nullableType);\n    var value = schema.parseLiteral(enumType, ast);\n\n    if (value == null) {\n      var suggestions = schema.getEnumValues(enumType); // parseLiteral() should return a non-null JavaScript value\n      // if the ast value is valid for the type.\n\n      throw createUserError(\"Expected a value matching type '\".concat(schema.getTypeString(type), \"'. Possible values: \").concat(orList(suggestions), \"?'\"), null, [ast]);\n    }\n\n    return {\n      kind: 'Literal',\n      loc: buildLocation(ast.loc),\n      value: value\n    };\n  } else if (schema.isScalar(nullableType)) {\n    var _value = schema.parseLiteral(schema.assertScalarType(nullableType), ast);\n\n    if (_value == null) {\n      // parseLiteral() should return a non-null JavaScript value\n      // if the ast value is valid for the type.\n      throw createUserError(\"Expected a value matching type '\".concat(schema.getTypeString(type), \"'.\"), null, [ast]);\n    }\n\n    return {\n      kind: 'Literal',\n      loc: buildLocation(ast.loc),\n      value: _value\n    };\n  } else {\n    throw createCompilerError(\"Unsupported type '\".concat(schema.getTypeString(type), \"' for input value, expected a GraphQLList, \") + 'GraphQLInputObjectType, GraphQLEnumType, or GraphQLScalarType.', null, [ast]);\n  }\n}\n/**\n * @private\n */\n\n\nfunction transformLiteralValue(ast, context) {\n  switch (ast.kind) {\n    case 'IntValue':\n      return parseInt(ast.value, 10);\n\n    case 'FloatValue':\n      return parseFloat(ast.value);\n\n    case 'StringValue':\n      return ast.value;\n\n    case 'BooleanValue':\n      // Note: duplicated because Flow does not understand fall-through cases\n      return ast.value;\n\n    case 'EnumValue':\n      // Note: duplicated because Flow does not understand fall-through cases\n      return ast.value;\n\n    case 'ListValue':\n      return ast.values.map(function (item) {\n        return transformLiteralValue(item, context);\n      });\n\n    case 'NullValue':\n      return null;\n\n    case 'ObjectValue':\n      {\n        var objectValue = {};\n        ast.fields.forEach(function (field) {\n          var fieldName = getName(field);\n          var value = transformLiteralValue(field.value, context);\n          objectValue[fieldName] = value;\n        });\n        return objectValue;\n      }\n\n    case 'Variable':\n      throw createUserError('Unexpected variable where a literal (static) value is required.', null, [ast, context]);\n\n    default:\n      ast.kind;\n      throw createCompilerError(\"Unknown ast kind '\".concat(ast.kind, \"'.\"), [ast]);\n  }\n}\n/**\n * @private\n */\n\n\nfunction buildArgumentDefinitions(variables) {\n  return Array.from(variables.values(), function (_ref3) {\n    var ast = _ref3.ast,\n        name = _ref3.name,\n        defaultValue = _ref3.defaultValue,\n        type = _ref3.type;\n    return {\n      kind: 'LocalArgumentDefinition',\n      loc: buildLocation(ast.loc),\n      name: name,\n      type: type,\n      defaultValue: defaultValue\n    };\n  });\n}\n/**\n * @private\n */\n\n\nfunction buildLocation(loc) {\n  if (loc == null) {\n    return {\n      kind: 'Unknown'\n    };\n  }\n\n  return {\n    kind: 'Source',\n    start: loc.start,\n    end: loc.end,\n    source: loc.source\n  };\n}\n/**\n * @private\n */\n\n\nfunction applyConditions(conditions, selections) {\n  var nextSelections = selections;\n  conditions.forEach(function (condition) {\n    nextSelections = [_objectSpread({}, condition, {\n      selections: nextSelections\n    })];\n  });\n  return nextSelections;\n}\n/**\n * @private\n */\n\n\nfunction getName(ast) {\n  var _ast$name;\n\n  var name = (_ast$name = ast.name) === null || _ast$name === void 0 ? void 0 : _ast$name.value;\n\n  if (typeof name !== 'string') {\n    throw createCompilerError(\"Expected ast node to have a 'name'.\", null, [ast]);\n  }\n\n  return name;\n}\n\nfunction getTypeName(ast) {\n  return ast ? print(ast) : 'Undefined Type Name';\n}\n/**\n * @private\n */\n\n\nfunction getFragmentType(ast) {\n  if (ast.kind === 'FragmentDefinition') {\n    return ast.typeCondition;\n  }\n\n  throw createCompilerError('Expected ast node to be a FragmentDefinition node.', null, [ast]);\n}\n\nfunction checkFragmentSpreadTypeCompatibility(schema, fragmentType, parentType, fragmentName, fragmentTypeAST, parentTypeAST) {\n  if (!schema.doTypesOverlap(fragmentType, schema.assertCompositeType(parentType))) {\n    var nodes = [];\n\n    if (parentTypeAST) {\n      nodes.push(parentTypeAST);\n    }\n\n    if (fragmentTypeAST) {\n      nodes.push(fragmentTypeAST);\n    }\n\n    var possibleConcreteTypes = schema.isAbstractType(parentType) ? Array.from(schema.getPossibleTypes(schema.assertAbstractType(parentType))) : [];\n    var suggestedTypesMessage = '';\n\n    if (possibleConcreteTypes.length !== 0) {\n      suggestedTypesMessage = \" Possible concrete types include \".concat(possibleConcreteTypes.sort().slice(0, 3).map(function (type) {\n        return \"'\".concat(schema.getTypeString(type), \"'\");\n      }).join(', '), \", etc.\");\n    }\n\n    throw createUserError((fragmentName != null ? \"Fragment '\".concat(fragmentName, \"' cannot be spread here as objects of \") : 'Fragment cannot be spread here as objects of ') + \"type '\".concat(schema.getTypeString(parentType), \"' \") + \"can never be of type '\".concat(schema.getTypeString(fragmentType), \"'.\") + suggestedTypesMessage, null, nodes);\n  }\n}\n\nmodule.exports = {\n  parse: parse,\n  transform: transform\n};"]},"metadata":{},"sourceType":"script"}