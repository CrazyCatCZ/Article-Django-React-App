{"ast":null,"code":"import { isSchema, parse, buildClientSchema, Kind, print } from 'graphql';\nimport { isValidPath, parseGraphQLSDL, debugLog, asArray, printSchemaWithDirectives } from '@graphql-tools/utils';\nimport { gqlPluckFromCodeString, gqlPluckFromCodeStringSync } from '@graphql-tools/graphql-tag-pluck';\nimport { isAbsolute, resolve } from 'path';\nimport { pathExists, pathExistsSync, readFile, readFileSync } from 'fs-extra';\nimport { cwd } from 'process';\n/**\n * @internal\n */\n\nfunction pick(obj, keys) {\n  for (const key of keys) {\n    if (obj[key]) {\n      return obj[key];\n    }\n  }\n\n  return obj;\n} // checkers\n\n/**\n * @internal\n */\n\n\nfunction isSchemaText(obj) {\n  return typeof obj === 'string';\n}\n/**\n * @internal\n */\n\n\nfunction isWrappedSchemaJson(obj) {\n  const json = obj;\n  return json.data !== undefined && json.data.__schema !== undefined;\n}\n/**\n * @internal\n */\n\n\nfunction isSchemaJson(obj) {\n  const json = obj;\n  return json !== undefined && json.__schema !== undefined;\n}\n/**\n * @internal\n */\n\n\nfunction isSchemaAst(obj) {\n  return obj.kind !== undefined;\n}\n\nconst identifiersToLookFor = ['default', 'schema', 'typeDefs', 'data']; // Pick exports\n\n/**\n * @internal\n */\n\nfunction pickExportFromModule({\n  module,\n  filepath\n}) {\n  ensureModule({\n    module,\n    filepath\n  });\n  return resolveModule(ensureExports({\n    module,\n    filepath\n  }));\n}\n/**\n * @internal\n */\n\n\nfunction pickExportFromModuleSync({\n  module,\n  filepath\n}) {\n  ensureModule({\n    module,\n    filepath\n  });\n  return resolveModuleSync(ensureExports({\n    module,\n    filepath\n  }));\n} // module\n\n\nasync function resolveModule(identifiers) {\n  const exportValue = await pick(await identifiers, identifiersToLookFor);\n  return resolveExport(exportValue);\n}\n\nfunction resolveModuleSync(identifiers) {\n  const exportValue = pick(identifiers, identifiersToLookFor);\n  return resolveExport(exportValue);\n} // validate\n\n\nfunction ensureModule({\n  module,\n  filepath\n}) {\n  if (!module) {\n    throw new Error(`Invalid export from export file ${filepath}: empty export!`);\n  }\n}\n\nfunction ensureExports({\n  module,\n  filepath\n}) {\n  const identifiers = pick(module, identifiersToLookFor);\n\n  if (!identifiers) {\n    throw new Error(`Invalid export from export file ${filepath}: missing default export or 'schema' export!`);\n  }\n\n  return identifiers;\n} // Decide what to do with an exported value\n\n\nfunction resolveExport(fileExport) {\n  try {\n    if (isSchema(fileExport)) {\n      return fileExport;\n    }\n\n    if (isSchemaText(fileExport)) {\n      return parse(fileExport);\n    }\n\n    if (isWrappedSchemaJson(fileExport)) {\n      return buildClientSchema(fileExport.data);\n    }\n\n    if (isSchemaJson(fileExport)) {\n      return buildClientSchema(fileExport);\n    }\n\n    if (isSchemaAst(fileExport)) {\n      return fileExport;\n    }\n\n    return null;\n  } catch (e) {\n    throw new Error('Exported schema must be of type GraphQLSchema, text, AST, or introspection JSON.');\n  }\n}\n/**\n * @internal\n */\n\n\nasync function tryToLoadFromExport(rawFilePath) {\n  try {\n    const filepath = ensureFilepath(rawFilePath);\n    const mod = await import(filepath);\n    return await pickExportFromModule({\n      module: mod,\n      filepath\n    });\n  } catch (e) {\n    throw new Error(`Unable to load from file \"${rawFilePath}\": ${e.message}`);\n  }\n}\n/**\n * @internal\n */\n\n\nfunction tryToLoadFromExportSync(rawFilePath) {\n  try {\n    const filepath = ensureFilepath(rawFilePath);\n\n    const mod = require(filepath);\n\n    return pickExportFromModuleSync({\n      module: mod,\n      filepath\n    });\n  } catch (e) {\n    throw new Error(`Unable to load from file \"${rawFilePath}\": ${e.message}`);\n  }\n}\n/**\n * @internal\n */\n\n\nfunction ensureFilepath(filepath) {\n  if (typeof require !== 'undefined' && require.cache) {\n    filepath = require.resolve(filepath);\n\n    if (require.cache[filepath]) {\n      delete require.cache[filepath];\n    }\n  }\n\n  return filepath;\n}\n\nconst FILE_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx', '.vue'];\n/**\n * This loader loads GraphQL documents and type definitions from code files\n * using `graphql-tag-pluck`.\n *\n * ```js\n * const documents = await loadDocuments('queries/*.js', {\n *   loaders: [\n *     new CodeFileLoader()\n *   ]\n * });\n * ```\n *\n * Supported extensions include: `.ts`, `.tsx`, `.js`, `.jsx`, `.vue`\n */\n\nclass CodeFileLoader {\n  loaderId() {\n    return 'code-file';\n  }\n\n  async canLoad(pointer, options) {\n    if (isValidPath(pointer)) {\n      if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {\n        const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);\n        return pathExists(normalizedFilePath);\n      }\n    }\n\n    return false;\n  }\n\n  canLoadSync(pointer, options) {\n    if (isValidPath(pointer)) {\n      if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {\n        const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);\n        return pathExistsSync(normalizedFilePath);\n      }\n    }\n\n    return false;\n  }\n\n  async load(pointer, options) {\n    const normalizedFilePath = ensureAbsolutePath(pointer, options);\n    const errors = [];\n\n    if (!options.noPluck) {\n      try {\n        const content = await readFile(normalizedFilePath, {\n          encoding: 'utf-8'\n        });\n        const sdl = await gqlPluckFromCodeString(normalizedFilePath, content, options.pluckConfig);\n\n        if (sdl) {\n          return parseSDL({\n            pointer,\n            sdl,\n            options\n          });\n        }\n      } catch (e) {\n        debugLog(`Failed to load schema from code file \"${normalizedFilePath}\": ${e.message}`);\n        errors.push(e);\n      }\n    }\n\n    if (!options.noRequire) {\n      try {\n        if (options && options.require) {\n          await Promise.all(asArray(options.require).map(m => import(m)));\n        }\n\n        const loaded = await tryToLoadFromExport(normalizedFilePath);\n        const source = resolveSource(pointer, loaded, options);\n\n        if (source) {\n          return source;\n        }\n      } catch (e) {\n        errors.push(e);\n      }\n    }\n\n    if (errors.length > 0) {\n      throw errors[0];\n    }\n\n    return null;\n  }\n\n  loadSync(pointer, options) {\n    const normalizedFilePath = ensureAbsolutePath(pointer, options);\n    const errors = [];\n\n    if (!options.noPluck) {\n      try {\n        const content = readFileSync(normalizedFilePath, {\n          encoding: 'utf-8'\n        });\n        const sdl = gqlPluckFromCodeStringSync(normalizedFilePath, content, options.pluckConfig);\n\n        if (sdl) {\n          return parseSDL({\n            pointer,\n            sdl,\n            options\n          });\n        }\n      } catch (e) {\n        debugLog(`Failed to load schema from code file \"${normalizedFilePath}\": ${e.message}`);\n        errors.push(e);\n      }\n    }\n\n    if (!options.noRequire) {\n      try {\n        if (options && options.require) {\n          asArray(options.require).forEach(m => require(m));\n        }\n\n        const loaded = tryToLoadFromExportSync(normalizedFilePath);\n        const source = resolveSource(pointer, loaded, options);\n\n        if (source) {\n          return source;\n        }\n      } catch (e) {\n        errors.push(e);\n      }\n    }\n\n    if (errors.length > 0) {\n      throw errors[0];\n    }\n\n    return null;\n  }\n\n}\n\nfunction parseSDL({\n  pointer,\n  sdl,\n  options\n}) {\n  return parseGraphQLSDL(pointer, sdl, options);\n}\n\nfunction resolveSource(pointer, value, options) {\n  if (isSchema(value)) {\n    return {\n      location: pointer,\n      rawSDL: printSchemaWithDirectives(value, options),\n      schema: value\n    };\n  } else if ((value === null || value === void 0 ? void 0 : value.kind) === Kind.DOCUMENT) {\n    return {\n      location: pointer,\n      rawSDL: print(value),\n      document: value\n    };\n  } else if (typeof value === 'string') {\n    return parseGraphQLSDL(pointer, value, options);\n  }\n\n  return null;\n}\n\nfunction ensureAbsolutePath(pointer, options) {\n  return isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);\n}\n\nexport { CodeFileLoader };","map":{"version":3,"sources":["../../../dist/loaders/code-file/src/helpers.js","../../../dist/loaders/code-file/src/exports.js","../../../dist/loaders/code-file/src/load-from-module.js","../../../dist/loaders/code-file/src/index.js"],"names":[],"mappings":"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","sourcesContent":["/**\n * @internal\n */\nexport function pick(obj, keys) {\n    for (const key of keys) {\n        if (obj[key]) {\n            return obj[key];\n        }\n    }\n    return obj;\n}\n// checkers\n/**\n * @internal\n */\nexport function isSchemaText(obj) {\n    return typeof obj === 'string';\n}\n/**\n * @internal\n */\nexport function isWrappedSchemaJson(obj) {\n    const json = obj;\n    return json.data !== undefined && json.data.__schema !== undefined;\n}\n/**\n * @internal\n */\nexport function isSchemaJson(obj) {\n    const json = obj;\n    return json !== undefined && json.__schema !== undefined;\n}\n/**\n * @internal\n */\nexport function isSchemaAst(obj) {\n    return obj.kind !== undefined;\n}\n//# sourceMappingURL=helpers.js.map","import { parse, buildClientSchema, isSchema } from 'graphql';\nimport { isSchemaAst, isSchemaJson, isSchemaText, isWrappedSchemaJson, pick } from './helpers';\nconst identifiersToLookFor = ['default', 'schema', 'typeDefs', 'data'];\n// Pick exports\n/**\n * @internal\n */\nexport function pickExportFromModule({ module, filepath }) {\n    ensureModule({ module, filepath });\n    return resolveModule(ensureExports({ module, filepath }));\n}\n/**\n * @internal\n */\nexport function pickExportFromModuleSync({ module, filepath }) {\n    ensureModule({ module, filepath });\n    return resolveModuleSync(ensureExports({ module, filepath }));\n}\n// module\nasync function resolveModule(identifiers) {\n    const exportValue = await pick(await identifiers, identifiersToLookFor);\n    return resolveExport(exportValue);\n}\nfunction resolveModuleSync(identifiers) {\n    const exportValue = pick(identifiers, identifiersToLookFor);\n    return resolveExport(exportValue);\n}\n// validate\nfunction ensureModule({ module, filepath }) {\n    if (!module) {\n        throw new Error(`Invalid export from export file ${filepath}: empty export!`);\n    }\n}\nfunction ensureExports({ module, filepath }) {\n    const identifiers = pick(module, identifiersToLookFor);\n    if (!identifiers) {\n        throw new Error(`Invalid export from export file ${filepath}: missing default export or 'schema' export!`);\n    }\n    return identifiers;\n}\n// Decide what to do with an exported value\nfunction resolveExport(fileExport) {\n    try {\n        if (isSchema(fileExport)) {\n            return fileExport;\n        }\n        if (isSchemaText(fileExport)) {\n            return parse(fileExport);\n        }\n        if (isWrappedSchemaJson(fileExport)) {\n            return buildClientSchema(fileExport.data);\n        }\n        if (isSchemaJson(fileExport)) {\n            return buildClientSchema(fileExport);\n        }\n        if (isSchemaAst(fileExport)) {\n            return fileExport;\n        }\n        return null;\n    }\n    catch (e) {\n        throw new Error('Exported schema must be of type GraphQLSchema, text, AST, or introspection JSON.');\n    }\n}\n//# sourceMappingURL=exports.js.map","import { pickExportFromModule, pickExportFromModuleSync } from './exports';\n/**\n * @internal\n */\nexport async function tryToLoadFromExport(rawFilePath) {\n    try {\n        const filepath = ensureFilepath(rawFilePath);\n        const mod = await import(filepath);\n        return await pickExportFromModule({ module: mod, filepath });\n    }\n    catch (e) {\n        throw new Error(`Unable to load from file \"${rawFilePath}\": ${e.message}`);\n    }\n}\n/**\n * @internal\n */\nexport function tryToLoadFromExportSync(rawFilePath) {\n    try {\n        const filepath = ensureFilepath(rawFilePath);\n        const mod = require(filepath);\n        return pickExportFromModuleSync({ module: mod, filepath });\n    }\n    catch (e) {\n        throw new Error(`Unable to load from file \"${rawFilePath}\": ${e.message}`);\n    }\n}\n/**\n * @internal\n */\nfunction ensureFilepath(filepath) {\n    if (typeof require !== 'undefined' && require.cache) {\n        filepath = require.resolve(filepath);\n        if (require.cache[filepath]) {\n            delete require.cache[filepath];\n        }\n    }\n    return filepath;\n}\n//# sourceMappingURL=load-from-module.js.map","import { Kind, isSchema, print } from 'graphql';\nimport { debugLog, asArray, isValidPath, parseGraphQLSDL, printSchemaWithDirectives, } from '@graphql-tools/utils';\nimport { gqlPluckFromCodeString, gqlPluckFromCodeStringSync, } from '@graphql-tools/graphql-tag-pluck';\nimport { tryToLoadFromExport, tryToLoadFromExportSync } from './load-from-module';\nimport { isAbsolute, resolve } from 'path';\nimport { readFileSync, readFile, pathExists, pathExistsSync } from 'fs-extra';\nimport { cwd } from 'process';\nconst FILE_EXTENSIONS = ['.ts', '.tsx', '.js', '.jsx', '.vue'];\n/**\n * This loader loads GraphQL documents and type definitions from code files\n * using `graphql-tag-pluck`.\n *\n * ```js\n * const documents = await loadDocuments('queries/*.js', {\n *   loaders: [\n *     new CodeFileLoader()\n *   ]\n * });\n * ```\n *\n * Supported extensions include: `.ts`, `.tsx`, `.js`, `.jsx`, `.vue`\n */\nexport class CodeFileLoader {\n    loaderId() {\n        return 'code-file';\n    }\n    async canLoad(pointer, options) {\n        if (isValidPath(pointer)) {\n            if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {\n                const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);\n                return pathExists(normalizedFilePath);\n            }\n        }\n        return false;\n    }\n    canLoadSync(pointer, options) {\n        if (isValidPath(pointer)) {\n            if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {\n                const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);\n                return pathExistsSync(normalizedFilePath);\n            }\n        }\n        return false;\n    }\n    async load(pointer, options) {\n        const normalizedFilePath = ensureAbsolutePath(pointer, options);\n        const errors = [];\n        if (!options.noPluck) {\n            try {\n                const content = await readFile(normalizedFilePath, { encoding: 'utf-8' });\n                const sdl = await gqlPluckFromCodeString(normalizedFilePath, content, options.pluckConfig);\n                if (sdl) {\n                    return parseSDL({ pointer, sdl, options });\n                }\n            }\n            catch (e) {\n                debugLog(`Failed to load schema from code file \"${normalizedFilePath}\": ${e.message}`);\n                errors.push(e);\n            }\n        }\n        if (!options.noRequire) {\n            try {\n                if (options && options.require) {\n                    await Promise.all(asArray(options.require).map(m => import(m)));\n                }\n                const loaded = await tryToLoadFromExport(normalizedFilePath);\n                const source = resolveSource(pointer, loaded, options);\n                if (source) {\n                    return source;\n                }\n            }\n            catch (e) {\n                errors.push(e);\n            }\n        }\n        if (errors.length > 0) {\n            throw errors[0];\n        }\n        return null;\n    }\n    loadSync(pointer, options) {\n        const normalizedFilePath = ensureAbsolutePath(pointer, options);\n        const errors = [];\n        if (!options.noPluck) {\n            try {\n                const content = readFileSync(normalizedFilePath, { encoding: 'utf-8' });\n                const sdl = gqlPluckFromCodeStringSync(normalizedFilePath, content, options.pluckConfig);\n                if (sdl) {\n                    return parseSDL({ pointer, sdl, options });\n                }\n            }\n            catch (e) {\n                debugLog(`Failed to load schema from code file \"${normalizedFilePath}\": ${e.message}`);\n                errors.push(e);\n            }\n        }\n        if (!options.noRequire) {\n            try {\n                if (options && options.require) {\n                    asArray(options.require).forEach(m => require(m));\n                }\n                const loaded = tryToLoadFromExportSync(normalizedFilePath);\n                const source = resolveSource(pointer, loaded, options);\n                if (source) {\n                    return source;\n                }\n            }\n            catch (e) {\n                errors.push(e);\n            }\n        }\n        if (errors.length > 0) {\n            throw errors[0];\n        }\n        return null;\n    }\n}\nfunction parseSDL({ pointer, sdl, options }) {\n    return parseGraphQLSDL(pointer, sdl, options);\n}\nfunction resolveSource(pointer, value, options) {\n    if (isSchema(value)) {\n        return {\n            location: pointer,\n            rawSDL: printSchemaWithDirectives(value, options),\n            schema: value,\n        };\n    }\n    else if ((value === null || value === void 0 ? void 0 : value.kind) === Kind.DOCUMENT) {\n        return {\n            location: pointer,\n            rawSDL: print(value),\n            document: value,\n        };\n    }\n    else if (typeof value === 'string') {\n        return parseGraphQLSDL(pointer, value, options);\n    }\n    return null;\n}\nfunction ensureAbsolutePath(pointer, options) {\n    return isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}