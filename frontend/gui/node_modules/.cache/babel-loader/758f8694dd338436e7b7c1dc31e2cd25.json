{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar _require = require('./CompilerError'),\n    createCompilerError = _require.createCompilerError;\n\nvar _require2 = require('./SchemaUtils'),\n    isSchemaDefinitionAST = _require2.isSchemaDefinitionAST;\n\nvar _require3 = require('graphql'),\n    GraphQLFloat = _require3.GraphQLFloat,\n    GraphQLInt = _require3.GraphQLInt,\n    GraphQLBoolean = _require3.GraphQLBoolean,\n    GraphQLString = _require3.GraphQLString,\n    GraphQLID = _require3.GraphQLID,\n    parse = _require3.parse,\n    parseType = _require3.parseType,\n    print = _require3.print,\n    valueFromASTUntyped = _require3.valueFromASTUntyped;\n/**\n * @private\n */\n\n\nvar Type = /*#__PURE__*/function () {\n  function Type(name, isClient) {\n    this.name = name;\n    this.isClient = isClient;\n  }\n\n  var _proto = Type.prototype;\n\n  _proto.toString = function toString() {\n    return this.name;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return String(this);\n  };\n\n  return Type;\n}();\n/**\n * @private\n */\n\n\nvar ScalarType = /*#__PURE__*/function (_Type) {\n  (0, _inheritsLoose2[\"default\"])(ScalarType, _Type);\n\n  function ScalarType() {\n    return _Type.apply(this, arguments) || this;\n  }\n\n  return ScalarType;\n}(Type);\n/**\n * @private\n */\n\n\nvar EnumType = /*#__PURE__*/function (_Type2) {\n  (0, _inheritsLoose2[\"default\"])(EnumType, _Type2);\n\n  function EnumType(name, values, isClient) {\n    var _this;\n\n    _this = _Type2.call(this, name, isClient) || this;\n    _this.values = values;\n    return _this;\n  }\n\n  return EnumType;\n}(Type);\n/**\n * @private\n */\n\n\nvar UnionType = /*#__PURE__*/function (_Type3) {\n  (0, _inheritsLoose2[\"default\"])(UnionType, _Type3);\n\n  function UnionType() {\n    return _Type3.apply(this, arguments) || this;\n  }\n\n  return UnionType;\n}(Type);\n/**\n * @private\n */\n\n\nvar ObjectType = /*#__PURE__*/function (_Type4) {\n  (0, _inheritsLoose2[\"default\"])(ObjectType, _Type4);\n\n  function ObjectType() {\n    return _Type4.apply(this, arguments) || this;\n  }\n\n  return ObjectType;\n}(Type);\n/**\n * @private\n */\n\n\nvar InputObjectType = /*#__PURE__*/function (_Type5) {\n  (0, _inheritsLoose2[\"default\"])(InputObjectType, _Type5);\n\n  function InputObjectType() {\n    return _Type5.apply(this, arguments) || this;\n  }\n\n  return InputObjectType;\n}(Type);\n/**\n * @private\n */\n\n\nvar InterfaceType = /*#__PURE__*/function (_Type6) {\n  (0, _inheritsLoose2[\"default\"])(InterfaceType, _Type6);\n\n  function InterfaceType() {\n    return _Type6.apply(this, arguments) || this;\n  }\n\n  return InterfaceType;\n}(Type);\n/**\n * @private\n */\n\n\nvar List = /*#__PURE__*/function () {\n  function List(type) {\n    this.ofType = type;\n    this._typeString = \"[\".concat(String(this.ofType), \"]\");\n  }\n\n  var _proto2 = List.prototype;\n\n  _proto2.toString = function toString() {\n    return this._typeString;\n  };\n\n  _proto2.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return List;\n}();\n/**\n * @private\n */\n\n\nvar NonNull = /*#__PURE__*/function () {\n  function NonNull(type) {\n    this.ofType = type;\n    this._typeString = \"\".concat(String(this.ofType), \"!\");\n  }\n\n  var _proto3 = NonNull.prototype;\n\n  _proto3.toString = function toString() {\n    return this._typeString;\n  };\n\n  _proto3.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return NonNull;\n}();\n/**\n * @private\n */\n\n\nvar Field = function Field(schema, name, type, belongsTo, args, isClient) {\n  this.name = name;\n  this.type = type;\n  this.belongsTo = belongsTo;\n  this.isClient = isClient;\n  this.args = parseInputArgumentDefinitionsMap(schema, args);\n};\n/**\n * @private\n */\n\n\nfunction unwrap(type) {\n  if (type instanceof NonNull || type instanceof List) {\n    return unwrap(type.ofType);\n  }\n\n  return type;\n}\n/**\n * @private\n */\n\n\nfunction hasConcreteTypeThatImplements(schema, type, interfaceType) {\n  return _isAbstractType(type) && getConcreteTypes(schema, type).some(function (concreteType) {\n    return schema.implementsInterface(schema.assertCompositeType(concreteType), interfaceType);\n  });\n}\n/**\n * @private\n */\n\n\nfunction getConcreteTypes(schema, type) {\n  var concreteTypes = new Set();\n  schema.getPossibleTypes(type).forEach(function (possibleType) {\n    if (_isObject(possibleType)) {\n      concreteTypes.add(possibleType);\n    }\n  });\n  return Array.from(concreteTypes);\n}\n\nvar TYPENAME_FIELD = '__typename';\nvar CLIENT_ID_FIELD = '__id';\nvar QUERY_TYPE_KEY = Symbol('Query');\nvar MUTATION_TYPE_KEY = Symbol('Mutation');\nvar SUBSCRIPTION_TYPE_KEY = Symbol('Subscription');\n\nfunction _isScalar(type) {\n  return type instanceof ScalarType;\n}\n\nfunction _isObject(type) {\n  return type instanceof ObjectType;\n}\n\nfunction _isEnum(type) {\n  return type instanceof EnumType;\n}\n\nfunction _isUnion(type) {\n  return type instanceof UnionType;\n}\n\nfunction _isInputObject(type) {\n  return type instanceof InputObjectType;\n}\n\nfunction _isInterface(type) {\n  return type instanceof InterfaceType;\n}\n\nfunction _isWrapper(type) {\n  return type instanceof List || type instanceof NonNull;\n}\n\nfunction isBaseType(type) {\n  return type instanceof ScalarType || type instanceof ObjectType || type instanceof EnumType || type instanceof UnionType || type instanceof InputObjectType || type instanceof InterfaceType;\n}\n\nfunction _isAbstractType(type) {\n  return type instanceof UnionType || type instanceof InterfaceType;\n}\n\nfunction _isCompositeType(type) {\n  return type instanceof ObjectType || type instanceof UnionType || type instanceof InterfaceType;\n}\n\nfunction _isInputType(type) {\n  return type instanceof InputObjectType || type instanceof ScalarType || type instanceof EnumType;\n}\n\nvar Schema = /*#__PURE__*/function () {\n  /**\n   * @private\n   */\n  function Schema(typeMap) {\n    var _this2 = this;\n\n    this._typeMap = typeMap;\n    this._typeWrappersMap = new Map();\n    this._fieldsMap = new Map();\n    this._typeNameMap = new Map();\n    this._clientIdMap = new Map();\n    this._directiveMap = new Map(typeMap.getDirectives().map(function (directive) {\n      return [directive.name, {\n        locations: directive.locations,\n        args: parseInputArgumentDefinitions(_this2, directive.args),\n        name: directive.name,\n        isClient: directive.isClient\n      }];\n    }));\n  }\n\n  var _proto4 = Schema.prototype;\n\n  _proto4.getTypes = function getTypes() {\n    return this._typeMap.getTypes();\n  };\n\n  _proto4.getTypeFromAST = function getTypeFromAST(typeNode) {\n    if (typeNode.kind === 'NonNullType') {\n      var innerType = this.getTypeFromAST(typeNode.type);\n\n      if (!innerType) {\n        return;\n      }\n\n      if (innerType instanceof NonNull) {\n        throw createCompilerError('Unable to wrap non-nullable type with non-null wrapper.');\n      }\n\n      var cacheKey = \"\".concat(this.getTypeString(innerType), \"!\");\n\n      var type = this._typeWrappersMap.get(cacheKey);\n\n      if (type) {\n        return type;\n      }\n\n      type = new NonNull(innerType);\n\n      this._typeWrappersMap.set(cacheKey, type);\n\n      return type;\n    } else if (typeNode.kind === 'ListType') {\n      var _innerType = this.getTypeFromAST(typeNode.type);\n\n      if (!_innerType) {\n        return;\n      }\n\n      var _cacheKey = \"[\".concat(this.getTypeString(_innerType), \"]\");\n\n      var _type = this._typeWrappersMap.get(_cacheKey);\n\n      if (_type) {\n        return _type;\n      }\n\n      _type = new List(_innerType);\n\n      this._typeWrappersMap.set(_cacheKey, _type);\n\n      return _type;\n    }\n\n    return this._typeMap.getTypeByName(typeNode.name.value);\n  };\n\n  _proto4._getRawType = function _getRawType(typeName) {\n    var type = this._typeWrappersMap.get(typeName);\n\n    if (type) {\n      return type;\n    }\n\n    if (typeof typeName === 'string') {\n      return this.getTypeFromAST(parseType(typeName));\n    } else {\n      var operationType;\n\n      if (typeName === QUERY_TYPE_KEY) {\n        operationType = this._typeMap.getQueryType();\n      } else if (typeName === MUTATION_TYPE_KEY) {\n        operationType = this._typeMap.getMutationType();\n      } else if (typeName === SUBSCRIPTION_TYPE_KEY) {\n        operationType = this._typeMap.getSubscriptionType();\n      }\n\n      if (operationType instanceof ObjectType) {\n        return operationType;\n      }\n    }\n  };\n\n  _proto4.getTypeFromString = function getTypeFromString(typeName) {\n    return this._getRawType(typeName);\n  };\n\n  _proto4.expectTypeFromString = function expectTypeFromString(typeName) {\n    var type = this.getTypeFromString(typeName);\n\n    if (type == null) {\n      throw createCompilerError(\"Unknown type: '\".concat(typeName, \"'.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.expectTypeFromAST = function expectTypeFromAST(ast) {\n    var type = this.getTypeFromAST(ast);\n\n    if (type == null) {\n      throw createCompilerError(\"Unknown type: '\".concat(print(ast), \"'.\"), null, [ast]);\n    }\n\n    return type;\n  };\n\n  _proto4.getNonNullType = function getNonNullType(type) {\n    if (type instanceof NonNull) {\n      return type;\n    }\n\n    var cacheKey = \"\".concat(String(type), \"!\");\n\n    var nonNullType = this._typeWrappersMap.get(cacheKey);\n\n    if (nonNullType) {\n      return nonNullType;\n    }\n\n    nonNullType = new NonNull(type);\n\n    this._typeWrappersMap.set(cacheKey, nonNullType);\n\n    return nonNullType;\n  };\n\n  _proto4.getRawType = function getRawType(type) {\n    return unwrap(type);\n  };\n\n  _proto4.getNullableType = function getNullableType(type) {\n    if (type instanceof NonNull) {\n      return type.ofType;\n    }\n\n    return type;\n  };\n\n  _proto4.getListItemType = function getListItemType(type) {\n    if (type instanceof List) {\n      return type.ofType;\n    }\n\n    return type;\n  };\n\n  _proto4.areEqualTypes = function areEqualTypes(typeA, typeB) {\n    if (typeA === typeB) {\n      return true;\n    }\n\n    if (typeA instanceof NonNull && typeB instanceof NonNull) {\n      return this.areEqualTypes(typeA.ofType, typeB.ofType);\n    }\n\n    if (typeA instanceof List && typeB instanceof List) {\n      return this.areEqualTypes(typeA.ofType, typeB.ofType);\n    }\n\n    if (isBaseType(typeA) && isBaseType(typeB)) {\n      return typeA.name === typeB.name;\n    }\n\n    return false;\n  }\n  /**\n   * Determine if the given type may implement the named type:\n   * - it is the named type\n   * - it implements the named interface\n   * - it is an abstract type and *some* of its concrete types may\n   *   implement the named type\n   */\n  ;\n\n  _proto4.mayImplement = function mayImplement(type, interfaceType) {\n    return this.areEqualTypes(type, interfaceType) || this.implementsInterface(type, interfaceType) || this.isAbstractType(type) && hasConcreteTypeThatImplements(this, type, interfaceType);\n  };\n\n  _proto4.implementsInterface = function implementsInterface(type, interfaceType) {\n    var _this3 = this;\n\n    return this.getInterfaces(type).some(function (typeInterface) {\n      return _this3.areEqualTypes(typeInterface, interfaceType);\n    });\n  };\n\n  _proto4.canHaveSelections = function canHaveSelections(type) {\n    return this.isObject(type) || this.isInterface(type);\n  };\n\n  _proto4.getTypeString = function getTypeString(type) {\n    return type.toString();\n  };\n\n  _proto4.isTypeSubTypeOf = function isTypeSubTypeOf(maybeSubType, superType) {\n    // Equivalent type is a valid subtype\n    if (maybeSubType === superType) {\n      return true;\n    } // If superType is non-null, maybeSubType must also be non-null.\n\n\n    if (superType instanceof NonNull) {\n      if (maybeSubType instanceof NonNull) {\n        return this.isTypeSubTypeOf(maybeSubType.ofType, superType.ofType);\n      }\n\n      return false;\n    }\n\n    if (maybeSubType instanceof NonNull) {\n      // If superType is nullable, maybeSubType may be non-null or nullable.\n      return this.isTypeSubTypeOf(maybeSubType.ofType, superType);\n    } // If superType type is a list, maybeSubType type must also be a list.\n\n\n    if (superType instanceof List) {\n      if (maybeSubType instanceof List) {\n        return this.isTypeSubTypeOf(maybeSubType.ofType, superType.ofType);\n      }\n\n      return false;\n    }\n\n    if (maybeSubType instanceof List) {\n      // If superType is not a list, maybeSubType must also be not a list.\n      return false;\n    } // If superType type is an abstract type, maybeSubType type may be a currently\n    // possible object type.\n\n\n    if (this.isAbstractType(superType) && this.isObject(maybeSubType) && this.isPossibleType(this.assertAbstractType(superType), this.assertObjectType(maybeSubType))) {\n      return true;\n    } // Otherwise, maybeSubType is not a valid subtype of the superType.\n\n\n    return false;\n  }\n  /**\n   * Provided two composite types, determine if they \"overlap\". Two composite\n   * types overlap when the Sets of possible concrete types for each intersect.\n   *\n   * This is often used to determine if a fragment of a given type could possibly\n   * be visited in a context of another type.\n   *\n   * This function is commutative.\n   */\n  ;\n\n  _proto4.doTypesOverlap = function doTypesOverlap(typeA, typeB) {\n    var _this4 = this; // Equivalent types overlap\n\n\n    if (typeA === typeB) {\n      return true;\n    }\n\n    if (_isAbstractType(typeA)) {\n      if (_isAbstractType(typeB)) {\n        // If both types are abstract, then determine if there is any intersection\n        // between possible concrete types of each.\n        return Array.from(this.getPossibleTypes(typeA)).some(function (type) {\n          if (_isObject(type)) {\n            return _this4.isPossibleType(typeB, type);\n          }\n        });\n      } // Determine if the latter type is a possible concrete type of the former.\n\n\n      return this.isPossibleType(typeA, typeB);\n    }\n\n    if (_isAbstractType(typeB)) {\n      // Determine if the former type is a possible concrete type of the latter.\n      return this.isPossibleType(typeB, typeA);\n    } // Otherwise the types do not overlap.\n\n\n    return false;\n  };\n\n  _proto4.isPossibleType = function isPossibleType(superType, maybeSubType) {\n    return this._typeMap.getPossibleTypeSet(superType).has(maybeSubType);\n  };\n\n  _proto4.assertScalarFieldType = function assertScalarFieldType(type) {\n    // Scalar type fields can be wrappers / or can be scalars/enums\n    if (_isWrapper(type) && !_isScalar(unwrap(type)) && !_isEnum(unwrap(type)) || !_isWrapper(type) && !_isScalar(type) && !_isEnum(type)) {\n      throw createCompilerError(\"Expected \".concat(String(type), \" to be a Scalar or Enum type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertLinkedFieldType = function assertLinkedFieldType(type) {\n    // Linked Field types can be wrappers / or can be composite types\n    if (_isWrapper(type) && !_isCompositeType(unwrap(type)) || !_isWrapper(type) && !_isCompositeType(type)) {\n      throw createCompilerError(\"Expected \".concat(String(type), \" to be a Object, Interface or a Union Type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertInputType = function assertInputType(type) {\n    // Input type fields can be wrappers / or can be scalars/enums\n    if (_isWrapper(type) && !_isInputType(unwrap(type)) || !_isWrapper(type) && !_isInputType(type)) {\n      throw createCompilerError(\"Expected \".concat(String(type), \" to be a Input, Scalar or Enum type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.asCompositeType = function asCompositeType(type) {\n    if (_isCompositeType(type)) {\n      return type;\n    }\n  };\n\n  _proto4.asInputType = function asInputType(type) {\n    if (_isWrapper(type) && _isInputType(unwrap(type)) || !_isWrapper(type) && _isInputType(type)) {\n      return type;\n    }\n  };\n\n  _proto4.asScalarFieldType = function asScalarFieldType(type) {\n    if (_isScalar(type) || _isEnum(type)) {\n      return type;\n    }\n  };\n\n  _proto4.assertScalarType = function assertScalarType(type) {\n    if (!_isScalar(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a scalar type, got \").concat(this.getTypeString(type), \".\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertObjectType = function assertObjectType(type) {\n    if (!_isObject(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be an object type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertInputObjectType = function assertInputObjectType(type) {\n    if (!_isInputObject(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be an input type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertInterfaceType = function assertInterfaceType(type) {\n    if (!_isInterface(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be an interface type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertCompositeType = function assertCompositeType(type) {\n    if (!_isCompositeType(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a composite type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertAbstractType = function assertAbstractType(type) {\n    if (!_isAbstractType(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be an abstract type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertLeafType = function assertLeafType(type) {\n    if (!this.isLeafType(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a leaf type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertUnionType = function assertUnionType(type) {\n    if (!_isUnion(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a union type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertEnumType = function assertEnumType(type) {\n    if (!_isEnum(type)) {\n      throw createCompilerError(\"Expected \".concat(String(type), \" to be an enum type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertIntType = function assertIntType(type) {\n    if (!_isScalar(type) || !this.isInt(type)) {\n      throw createCompilerError(\"Expected \".concat(String(type), \" to be an 'Int' type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertFloatType = function assertFloatType(type) {\n    if (!_isScalar(type) || !this.isFloat(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a 'Float' type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertBooleanType = function assertBooleanType(type) {\n    if (!_isScalar(type) || !this.isBoolean(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a 'Boolean' type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertStringType = function assertStringType(type) {\n    if (!_isScalar(type) || !this.isString(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a 'String' type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertIdType = function assertIdType(type) {\n    if (!_isScalar(type) || !this.isId(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be an ID type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.expectBooleanType = function expectBooleanType() {\n    return this.assertScalarType(this.expectTypeFromString('Boolean'));\n  };\n\n  _proto4.expectIntType = function expectIntType() {\n    return this.assertScalarType(this.expectTypeFromString('Int'));\n  };\n\n  _proto4.expectFloatType = function expectFloatType() {\n    return this.assertScalarType(this.expectTypeFromString('Float'));\n  };\n\n  _proto4.expectStringType = function expectStringType() {\n    return this.assertScalarType(this.expectTypeFromString('String'));\n  };\n\n  _proto4.expectIdType = function expectIdType() {\n    return this.assertScalarType(this.expectTypeFromString('ID'));\n  };\n\n  _proto4.getQueryType = function getQueryType() {\n    var queryType = this._getRawType(QUERY_TYPE_KEY);\n\n    if (queryType && _isObject(queryType)) {\n      return queryType;\n    }\n  };\n\n  _proto4.getMutationType = function getMutationType() {\n    var mutationType = this._getRawType(MUTATION_TYPE_KEY);\n\n    if (mutationType && _isObject(mutationType)) {\n      return mutationType;\n    }\n  };\n\n  _proto4.getSubscriptionType = function getSubscriptionType() {\n    var subscriptionType = this._getRawType(SUBSCRIPTION_TYPE_KEY);\n\n    if (subscriptionType && _isObject(subscriptionType)) {\n      return subscriptionType;\n    }\n  };\n\n  _proto4.expectQueryType = function expectQueryType() {\n    var queryType = this.getQueryType();\n\n    if (queryType == null) {\n      throw createCompilerError('Query type is not defined on the Schema');\n    }\n\n    return queryType;\n  };\n\n  _proto4.expectMutationType = function expectMutationType() {\n    var mutationType = this.getMutationType();\n\n    if (mutationType == null) {\n      throw createCompilerError('Mutation type is not defined the Schema');\n    }\n\n    return mutationType;\n  };\n\n  _proto4.expectSubscriptionType = function expectSubscriptionType() {\n    var subscriptionType = this.getSubscriptionType();\n\n    if (subscriptionType == null) {\n      throw createCompilerError('Subscription type is not defined the Schema');\n    }\n\n    return subscriptionType;\n  };\n\n  _proto4.isNonNull = function isNonNull(type) {\n    return type instanceof NonNull;\n  };\n\n  _proto4.isList = function isList(type) {\n    return type instanceof List;\n  };\n\n  _proto4.isWrapper = function isWrapper(type) {\n    return _isWrapper(type);\n  };\n\n  _proto4.isScalar = function isScalar(type) {\n    return _isScalar(type);\n  };\n\n  _proto4.isObject = function isObject(type) {\n    return _isObject(type);\n  };\n\n  _proto4.isEnum = function isEnum(type) {\n    return _isEnum(type);\n  };\n\n  _proto4.isUnion = function isUnion(type) {\n    return _isUnion(type);\n  };\n\n  _proto4.isInputObject = function isInputObject(type) {\n    return _isInputObject(type);\n  };\n\n  _proto4.isInterface = function isInterface(type) {\n    return _isInterface(type);\n  };\n\n  _proto4.isInputType = function isInputType(type) {\n    // Wrappers can be input types (so it's save to check unwrapped type here)\n    return _isInputType(type) || _isWrapper(type) && _isInputType(unwrap(type));\n  };\n\n  _proto4.isCompositeType = function isCompositeType(type) {\n    return _isCompositeType(type);\n  };\n\n  _proto4.isAbstractType = function isAbstractType(type) {\n    return _isAbstractType(type);\n  };\n\n  _proto4.isLeafType = function isLeafType(type) {\n    return this.isScalar(type) || this.isEnum(type);\n  };\n\n  _proto4.isId = function isId(type) {\n    if (type instanceof ScalarType) {\n      return type.name === 'ID';\n    }\n\n    return false;\n  };\n\n  _proto4.isInt = function isInt(type) {\n    if (type instanceof ScalarType) {\n      return type.name === 'Int';\n    }\n\n    return false;\n  };\n\n  _proto4.isFloat = function isFloat(type) {\n    if (type instanceof ScalarType) {\n      return type.name === 'Float';\n    }\n\n    return false;\n  };\n\n  _proto4.isBoolean = function isBoolean(type) {\n    if (type instanceof ScalarType) {\n      return type.name === 'Boolean';\n    }\n\n    return false;\n  };\n\n  _proto4.isString = function isString(type) {\n    if (type instanceof ScalarType) {\n      return type.name === 'String';\n    }\n\n    return false;\n  };\n\n  _proto4.hasField = function hasField(type, fieldName) {\n    var canHaveTypename = this.isObject(type) || this.isAbstractType(type); // Special case for __typename field\n\n    if (canHaveTypename && (fieldName === TYPENAME_FIELD || fieldName === CLIENT_ID_FIELD)) {\n      return true;\n    }\n\n    if (type instanceof ObjectType || type instanceof InterfaceType) {\n      return this._typeMap.getField(type, fieldName) != null;\n    } else if (type instanceof InputObjectType) {\n      return this._typeMap.getInputField(type, fieldName) != null;\n    }\n\n    return false;\n  };\n\n  _proto4.hasId = function hasId(type) {\n    if (!this.hasField(type, 'id')) {\n      return false;\n    }\n\n    var idField = this.expectField(type, 'id');\n    return this.areEqualTypes(this.getNullableType(this.getFieldType(idField)), this.expectIdType());\n  };\n\n  _proto4.getFields = function getFields(type) {\n    var fieldsMap = this._getFieldsMap(type);\n\n    return Array.from(fieldsMap.values());\n  };\n\n  _proto4._getFieldsMap = function _getFieldsMap(type) {\n    var cachedMap = this._fieldsMap.get(type);\n\n    if (cachedMap != null) {\n      return cachedMap;\n    }\n\n    var fieldsMap = new Map();\n\n    if (type instanceof ObjectType || type instanceof InterfaceType) {\n      var fields = this._typeMap.getFieldMap(type);\n\n      if (fields) {\n        var _iterator = _createForOfIteratorHelper(fields),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _step.value,\n                fieldName = _step$value[0],\n                fieldDefinition = _step$value[1];\n            var fieldType = this.expectTypeFromAST(fieldDefinition.type);\n            fieldsMap.set(fieldName, new Field(this, fieldName, fieldType, this.assertCompositeType(type), fieldDefinition.arguments, fieldDefinition.isClient));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    } else if (type instanceof InputObjectType) {\n      var _fields = this._typeMap.getInputFieldMap(type);\n\n      if (_fields) {\n        var _iterator2 = _createForOfIteratorHelper(_fields),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _step2.value,\n                _fieldName = _step2$value[0],\n                typeNode = _step2$value[1];\n\n            var _fieldType = this.expectTypeFromAST(typeNode);\n\n            fieldsMap.set(_fieldName, new Field(this, _fieldName, _fieldType, type, [], false));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n\n    if (fieldsMap.size === 0) {\n      throw createCompilerError(\"_getFieldsMap: Type '\".concat(type.name, \"' should have fields.\"));\n    }\n\n    this._fieldsMap.set(type, fieldsMap);\n\n    return fieldsMap;\n  };\n\n  _proto4.getFieldByName = function getFieldByName(type, fieldName) {\n    if (!this.hasField(type, fieldName)) {\n      return;\n    } // A \"special\" case for __typename and __id fields - which should\n    // not be in the list of type fields, but should be fine to select\n\n\n    if (fieldName === TYPENAME_FIELD) {\n      var typename = this._typeNameMap.get(type);\n\n      if (!typename) {\n        typename = new Field(this, TYPENAME_FIELD, this.getNonNullType(this.expectStringType()), type, [], false);\n\n        this._typeNameMap.set(type, typename);\n      }\n\n      return typename;\n    }\n\n    if (fieldName === CLIENT_ID_FIELD) {\n      var clientId = this._clientIdMap.get(type);\n\n      if (!clientId) {\n        clientId = new Field(this, CLIENT_ID_FIELD, this.getNonNullType(this.expectIdType()), type, [], true);\n\n        this._clientIdMap.set(type, clientId);\n      }\n\n      return clientId;\n    }\n\n    if (_isUnion(type)) {\n      throw createCompilerError(\"Unexpected union type '\".concat(this.getTypeString(type), \"' in the 'getFieldByName(...)'. Expected type with fields\"));\n    }\n\n    var fieldsMap = this._getFieldsMap(type);\n\n    return fieldsMap.get(fieldName);\n  };\n\n  _proto4.expectField = function expectField(type, fieldName) {\n    var field = this.getFieldByName(type, fieldName);\n\n    if (!field) {\n      throw createCompilerError(\"Unknown field '\".concat(fieldName, \"' on type '\").concat(this.getTypeString(type), \"'.\"));\n    }\n\n    return field;\n  };\n\n  _proto4.getFieldConfig = function getFieldConfig(field) {\n    return {\n      type: field.type,\n      args: Array.from(field.args.values())\n    };\n  };\n\n  _proto4.getFieldName = function getFieldName(field) {\n    return field.name;\n  };\n\n  _proto4.getFieldType = function getFieldType(field) {\n    return field.type;\n  };\n\n  _proto4.getFieldParentType = function getFieldParentType(field) {\n    return field.belongsTo;\n  };\n\n  _proto4.getFieldArgs = function getFieldArgs(field) {\n    return Array.from(field.args.values());\n  };\n\n  _proto4.getFieldArgByName = function getFieldArgByName(field, argName) {\n    return field.args.get(argName);\n  };\n\n  _proto4.getEnumValues = function getEnumValues(type) {\n    return type.values;\n  };\n\n  _proto4.getUnionTypes = function getUnionTypes(type) {\n    return Array.from(this._typeMap.getPossibleTypeSet(type));\n  };\n\n  _proto4.getInterfaces = function getInterfaces(type) {\n    if (type instanceof ObjectType) {\n      return this._typeMap.getInterfaces(type);\n    }\n\n    return [];\n  };\n\n  _proto4.getPossibleTypes = function getPossibleTypes(type) {\n    return this._typeMap.getPossibleTypeSet(type);\n  };\n\n  _proto4.getFetchableFieldName = function getFetchableFieldName(type) {\n    return this._typeMap.getFetchableFieldName(type);\n  };\n\n  _proto4.parseLiteral = function parseLiteral(type, valueNode) {\n    if (type instanceof EnumType && valueNode.kind === 'EnumValue') {\n      return this.parseValue(type, valueNode.value);\n    } else if (type instanceof ScalarType) {\n      if (valueNode.kind === 'BooleanValue' && type.name === 'Boolean') {\n        return GraphQLBoolean.parseLiteral(valueNode);\n      } else if (valueNode.kind === 'FloatValue' && type.name === 'Float') {\n        return GraphQLFloat.parseLiteral(valueNode);\n      } else if (valueNode.kind === 'IntValue' && (type.name === 'Int' || type.name === 'ID' || type.name === 'Float')) {\n        return GraphQLInt.parseLiteral(valueNode);\n      } else if (valueNode.kind === 'StringValue' && (type.name === 'String' || type.name === 'ID')) {\n        return GraphQLString.parseLiteral(valueNode);\n      } else if (!isDefaultScalar(type.name)) {\n        return valueFromASTUntyped(valueNode);\n      }\n    }\n  };\n\n  _proto4.parseValue = function parseValue(type, value) {\n    if (type instanceof EnumType) {\n      return type.values.includes(value) ? value : undefined;\n    } else if (type instanceof ScalarType) {\n      switch (type.name) {\n        case 'Boolean':\n          return GraphQLBoolean.parseValue(value);\n\n        case 'Float':\n          return GraphQLFloat.parseValue(value);\n\n        case 'Int':\n          return GraphQLInt.parseValue(value);\n\n        case 'String':\n          return GraphQLString.parseValue(value);\n\n        case 'ID':\n          return GraphQLID.parseValue(value);\n\n        default:\n          return value;\n      }\n    }\n  };\n\n  _proto4.serialize = function serialize(type, value) {\n    if (type instanceof EnumType) {\n      return type.values.includes(value) ? value : undefined;\n    } else if (type instanceof ScalarType) {\n      switch (type.name) {\n        case 'Boolean':\n          return GraphQLBoolean.serialize(value);\n\n        case 'Float':\n          return GraphQLFloat.serialize(value);\n\n        case 'Int':\n          return GraphQLInt.serialize(value);\n\n        case 'String':\n          return GraphQLString.serialize(value);\n\n        case 'ID':\n          return GraphQLID.serialize(value);\n\n        default:\n          return value;\n      }\n    }\n  };\n\n  _proto4.getDirectives = function getDirectives() {\n    return Array.from(this._directiveMap.values());\n  };\n\n  _proto4.getDirective = function getDirective(directiveName) {\n    return this._directiveMap.get(directiveName);\n  };\n\n  _proto4.isServerType = function isServerType(type) {\n    var unwrapped = unwrap(type);\n    return unwrapped.isClient === false;\n  };\n\n  _proto4.isServerField = function isServerField(field) {\n    return field.isClient === false;\n  };\n\n  _proto4.isServerDirective = function isServerDirective(directiveName) {\n    var directive = this._directiveMap.get(directiveName);\n\n    return (directive === null || directive === void 0 ? void 0 : directive.isClient) === false;\n  };\n\n  _proto4.isServerDefinedField = function isServerDefinedField(type, field) {\n    return this.isAbstractType(type) && field.directives.some(function (_ref) {\n      var name = _ref.name;\n      return name === 'fixme_fat_interface';\n    }) || this.hasField(type, field.name) && this.isServerField(this.expectField(type, field.name));\n  };\n\n  _proto4.isClientDefinedField = function isClientDefinedField(type, field) {\n    return !this.isServerDefinedField(type, field);\n  };\n\n  _proto4.extend = function extend(extensions) {\n    var doc = Array.isArray(extensions) ? parse(extensions.join('\\n')) : extensions;\n    var schemaExtensions = [];\n    doc.definitions.forEach(function (definition) {\n      if (isSchemaDefinitionAST(definition)) {\n        schemaExtensions.push(definition);\n      }\n    });\n\n    if (schemaExtensions.length > 0) {\n      return new Schema(this._typeMap.extend(schemaExtensions));\n    }\n\n    return this;\n  };\n\n  return Schema;\n}();\n\nvar TypeMap = /*#__PURE__*/function () {\n  function TypeMap(source, extensions) {\n    this._types = new Map([['ID', new ScalarType('ID', false)], ['String', new ScalarType('String', false)], ['Boolean', new ScalarType('Boolean', false)], ['Float', new ScalarType('Float', false)], ['Int', new ScalarType('Int', false)]]);\n    this._typeInterfaces = new Map();\n    this._unionTypes = new Map();\n    this._interfaceImplementations = new Map();\n    this._fields = new Map();\n    this._inputFields = new Map();\n    this._directives = new Map([['include', {\n      name: 'include',\n      isClient: false,\n      locations: ['FIELD', 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT'],\n      args: [{\n        name: 'if',\n        typeNode: parseType('Boolean!'),\n        defaultValue: undefined\n      }]\n    }], ['skip', {\n      name: 'skip',\n      isClient: false,\n      locations: ['FIELD', 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT'],\n      args: [{\n        name: 'if',\n        typeNode: parseType('Boolean!'),\n        defaultValue: undefined\n      }]\n    }], ['deprecated', {\n      name: 'deprecated',\n      isClient: false,\n      locations: ['FIELD_DEFINITION', 'ENUM_VALUE'],\n      args: [{\n        name: 'reason',\n        typeNode: parseType('String'),\n        defaultValue: {\n          kind: 'StringValue',\n          value: 'No longer supported'\n        }\n      }]\n    }]]);\n    this._queryTypeName = 'Query';\n    this._mutationTypeName = 'Mutation';\n    this._subscriptionTypeName = 'Subscription';\n    this._source = source;\n    this._extensions = extensions;\n    this._fetchable = new Map();\n\n    this._parse(source);\n\n    this._extend(extensions);\n  }\n\n  var _proto5 = TypeMap.prototype;\n\n  _proto5._parse = function _parse(source) {\n    var _this5 = this;\n\n    var document = parse(source, {\n      noLocation: true\n    });\n    document.definitions.forEach(function (definition) {\n      switch (definition.kind) {\n        case 'SchemaDefinition':\n          {\n            _this5._parseSchemaDefinition(definition);\n\n            break;\n          }\n\n        case 'ScalarTypeDefinition':\n          {\n            _this5._parseScalarNode(definition, false);\n\n            break;\n          }\n\n        case 'EnumTypeDefinition':\n          {\n            _this5._parseEnumNode(definition, false);\n\n            break;\n          }\n\n        case 'ObjectTypeDefinition':\n          {\n            _this5._parseObjectTypeNode(definition, false);\n\n            break;\n          }\n\n        case 'InputObjectTypeDefinition':\n          {\n            _this5._parseInputObjectTypeNode(definition, false);\n\n            break;\n          }\n\n        case 'UnionTypeDefinition':\n          {\n            _this5._parseUnionNode(definition, false);\n\n            break;\n          }\n\n        case 'InterfaceTypeDefinition':\n          {\n            _this5._parseInterfaceNode(definition, false);\n\n            break;\n          }\n\n        case 'DirectiveDefinition':\n          {\n            _this5._parseDirective(definition, false);\n\n            break;\n          }\n      }\n    });\n  };\n\n  _proto5._parseSchemaDefinition = function _parseSchemaDefinition(node) {\n    var _this6 = this;\n\n    node.operationTypes.forEach(function (operationType) {\n      switch (operationType.operation) {\n        case 'query':\n          _this6._queryTypeName = operationType.type.name.value;\n          break;\n\n        case 'mutation':\n          _this6._mutationTypeName = operationType.type.name.value;\n          break;\n\n        case 'subscription':\n          _this6._subscriptionTypeName = operationType.type.name.value;\n          break;\n      }\n    });\n  };\n\n  _proto5._parseScalarNode = function _parseScalarNode(node, isClient) {\n    var name = node.name.value;\n\n    if (!isDefaultScalar(name) && this._types.has(name)) {\n      throw createCompilerError(\"_parseScalarNode: Duplicate definition for type \".concat(name, \".\"), null, [node]);\n    }\n\n    this._types.set(name, new ScalarType(name, isClient));\n  };\n\n  _proto5._parseEnumNode = function _parseEnumNode(node, isClient) {\n    var name = node.name.value;\n\n    if (this._types.has(name)) {\n      throw createCompilerError(\"_parseEnumNode: Duplicate definition for type \".concat(name, \".\"), null, [node]);\n    } // SDL doesn't have information about the actual ENUM values\n\n\n    var values = node.values ? node.values.map(function (value) {\n      return value.name.value;\n    }) : [];\n\n    this._types.set(name, new EnumType(name, values, isClient));\n  };\n\n  _proto5._parseObjectTypeNode = function _parseObjectTypeNode(node, isClient) {\n    var _this7 = this;\n\n    var _this$_types$get;\n\n    var name = node.name.value; // Objects may be created by _parseUnionNode\n\n    var type = (_this$_types$get = this._types.get(name)) !== null && _this$_types$get !== void 0 ? _this$_types$get : new ObjectType(name, isClient);\n\n    if (!(type instanceof ObjectType)) {\n      throw createCompilerError(\"_parseObjectTypeNode: Expected object type, got \".concat(String(type)), null, [node]);\n    }\n\n    if (type.isClient !== isClient) {\n      throw createCompilerError(\"_parseObjectTypeNode: Cannot create object type '\".concat(name, \"' defined as a client type.\"), null, [node]);\n    }\n\n    var typeInterfaces = [];\n    node.interfaces && node.interfaces.forEach(function (interfaceTypeNode) {\n      var _this$_interfaceImple;\n\n      var interfaceName = interfaceTypeNode.name.value;\n\n      var interfaceType = _this7._types.get(interfaceName);\n\n      if (!interfaceType) {\n        interfaceType = new InterfaceType(interfaceName, isClient);\n\n        _this7._types.set(interfaceName, interfaceType);\n      }\n\n      if (!(interfaceType instanceof InterfaceType)) {\n        throw createCompilerError('_parseObjectTypeNode: Expected interface type', null, [interfaceTypeNode]);\n      }\n\n      var implementations = (_this$_interfaceImple = _this7._interfaceImplementations.get(interfaceType)) !== null && _this$_interfaceImple !== void 0 ? _this$_interfaceImple : new Set();\n      implementations.add(type);\n\n      _this7._interfaceImplementations.set(interfaceType, implementations);\n\n      typeInterfaces.push(interfaceType);\n    });\n    var fetchable = null;\n    node.directives && node.directives.forEach(function (directiveNode) {\n      if (directiveNode.name.value === 'fetchable') {\n        var field_name_arg = directiveNode.arguments && directiveNode.arguments.find(function (arg) {\n          return arg.name.value === 'field_name';\n        });\n\n        if (field_name_arg != null && field_name_arg.value.kind === 'StringValue') {\n          fetchable = {\n            field_name: field_name_arg.value.value\n          };\n        }\n      }\n    });\n\n    this._typeInterfaces.set(type, typeInterfaces);\n\n    this._types.set(name, type);\n\n    if (fetchable != null) {\n      this._fetchable.set(type, fetchable);\n    }\n\n    node.fields && this._handleTypeFieldsStrict(type, node.fields, isClient);\n  };\n\n  _proto5._parseInputObjectTypeNode = function _parseInputObjectTypeNode(node, isClient) {\n    var name = node.name.value;\n\n    if (this._types.has(name)) {\n      throw createCompilerError('_parseInputObjectTypeNode: Unable to parse schema file. Duplicate definition for object type', null, [node]);\n    }\n\n    var type = new InputObjectType(name, isClient);\n\n    this._types.set(name, type);\n\n    this._parseInputObjectFields(type, node);\n  };\n\n  _proto5._parseUnionNode = function _parseUnionNode(node, isClient) {\n    var _this8 = this;\n\n    var name = node.name.value;\n\n    if (this._types.has(name)) {\n      throw createCompilerError('_parseUnionNode: Unable to parse schema file. Duplicate definition for object type', null, [node]);\n    }\n\n    var union = new UnionType(name, isClient);\n\n    this._types.set(name, union);\n\n    this._unionTypes.set(union, new Set(node.types ? node.types.map(function (typeInUnion) {\n      var _this$_types$get2;\n\n      var typeInUnionName = typeInUnion.name.value;\n      var object = (_this$_types$get2 = _this8._types.get(typeInUnionName)) !== null && _this$_types$get2 !== void 0 ? _this$_types$get2 : new ObjectType(typeInUnionName, false);\n\n      if (!(object instanceof ObjectType)) {\n        throw createCompilerError('_parseUnionNode: Expected object type', null, [typeInUnion]);\n      }\n\n      _this8._types.set(typeInUnionName, object);\n\n      return object;\n    }) : []));\n  };\n\n  _proto5._parseInterfaceNode = function _parseInterfaceNode(node, isClient) {\n    var name = node.name.value;\n\n    var type = this._types.get(name);\n\n    if (!type) {\n      type = new InterfaceType(name, isClient);\n\n      this._types.set(name, type);\n    }\n\n    if (!(type instanceof InterfaceType)) {\n      throw createCompilerError(\"_parseInterfaceNode: Expected interface type. Got \".concat(String(type)), null, [node]);\n    }\n\n    if (type.isClient !== isClient) {\n      throw createCompilerError(\"_parseInterfaceNode: Cannot create interface '\".concat(name, \"' defined as a client interface\"), null, [node]);\n    }\n\n    node.fields && this._handleTypeFieldsStrict(type, node.fields, isClient);\n  };\n\n  _proto5._handleTypeFieldsStrict = function _handleTypeFieldsStrict(type, fields, isClient) {\n    if (this._fields.has(type)) {\n      throw createCompilerError('_handleTypeFieldsStrict: Unable to parse schema file. Duplicate definition for object type');\n    }\n\n    this._handleTypeFields(type, fields, isClient);\n  };\n\n  _proto5._handleTypeFields = function _handleTypeFields(type, fields, isClient) {\n    var _this$_fields$get;\n\n    var fieldsMap = (_this$_fields$get = this._fields.get(type)) !== null && _this$_fields$get !== void 0 ? _this$_fields$get : new Map();\n    fields.forEach(function (fieldNode) {\n      var fieldName = fieldNode.name.value;\n\n      if (fieldsMap.has(fieldName)) {\n        throw createCompilerError(\"_handleTypeFields: Duplicate definition for field '\".concat(fieldName, \"'.\"));\n      }\n\n      fieldsMap.set(fieldName, {\n        arguments: fieldNode.arguments ? fieldNode.arguments.map(function (arg) {\n          return {\n            name: arg.name.value,\n            typeNode: arg.type,\n            defaultValue: arg.defaultValue\n          };\n        }) : [],\n        type: fieldNode.type,\n        isClient: isClient\n      });\n    });\n\n    this._fields.set(type, fieldsMap);\n  };\n\n  _proto5._parseInputObjectFields = function _parseInputObjectFields(type, node) {\n    if (this._inputFields.has(type)) {\n      throw createCompilerError('_parseInputObjectFields: Unable to parse schema file. Duplicate definition for type', null, [node]);\n    }\n\n    var fields = new Map();\n\n    if (node.fields) {\n      node.fields.forEach(function (fieldNode) {\n        fields.set(fieldNode.name.value, fieldNode.type);\n      });\n    }\n\n    this._inputFields.set(type, fields);\n  };\n\n  _proto5._parseDirective = function _parseDirective(node, isClient) {\n    var name = node.name.value;\n\n    this._directives.set(name, {\n      name: name,\n      args: node.arguments ? node.arguments.map(function (arg) {\n        return {\n          name: arg.name.value,\n          typeNode: arg.type,\n          defaultValue: arg.defaultValue\n        };\n      }) : [],\n      locations: node.locations.map(function (location) {\n        switch (location.value) {\n          case 'QUERY':\n          case 'MUTATION':\n          case 'SUBSCRIPTION':\n          case 'FIELD':\n          case 'FRAGMENT_DEFINITION':\n          case 'FRAGMENT_SPREAD':\n          case 'INLINE_FRAGMENT':\n          case 'VARIABLE_DEFINITION':\n          case 'SCHEMA':\n          case 'SCALAR':\n          case 'OBJECT':\n          case 'FIELD_DEFINITION':\n          case 'ARGUMENT_DEFINITION':\n          case 'INTERFACE':\n          case 'UNION':\n          case 'ENUM':\n          case 'ENUM_VALUE':\n          case 'INPUT_OBJECT':\n          case 'INPUT_FIELD_DEFINITION':\n            return location.value;\n\n          default:\n            throw createCompilerError('Invalid directive location');\n        }\n      }),\n      isClient: isClient\n    });\n  };\n\n  _proto5._parseObjectTypeExtension = function _parseObjectTypeExtension(node) {\n    var type = this._types.get(node.name.value);\n\n    if (!(type instanceof ObjectType)) {\n      throw createCompilerError(\"_parseObjectTypeExtension: Expected to find type with the name '\".concat(node.name.value, \"'\"), null, [node]);\n    }\n\n    node.fields && this._handleTypeFields(type, node.fields, true\n    /** client fields */\n    );\n  };\n\n  _proto5._parseInterfaceTypeExtension = function _parseInterfaceTypeExtension(node) {\n    var type = this._types.get(node.name.value);\n\n    if (!(type instanceof InterfaceType)) {\n      throw createCompilerError('_parseInterfaceTypeExtension: Expected to have an interface type');\n    }\n\n    node.fields && this._handleTypeFields(type, node.fields, true);\n  };\n\n  _proto5._extend = function _extend(extensions) {\n    var _this9 = this;\n\n    extensions.forEach(function (definition) {\n      if (definition.kind === 'ObjectTypeDefinition') {\n        _this9._parseObjectTypeNode(definition, true);\n      } else if (definition.kind === 'InterfaceTypeDefinition') {\n        _this9._parseInterfaceNode(definition, true);\n      } else if (definition.kind === 'ScalarTypeDefinition') {\n        _this9._parseScalarNode(definition, true);\n      } else if (definition.kind === 'EnumTypeDefinition') {\n        _this9._parseEnumNode(definition, true);\n      } else if (definition.kind === 'InterfaceTypeExtension') {\n        _this9._parseInterfaceTypeExtension(definition);\n      } else if (definition.kind === 'ObjectTypeExtension') {\n        _this9._parseObjectTypeExtension(definition);\n      } else if (definition.kind === 'DirectiveDefinition') {\n        _this9._parseDirective(definition, true\n        /* client directive */\n        );\n      } else {\n        throw createCompilerError(\"Unexpected extension kind: '\".concat(definition.kind, \"'\"), null, [definition]);\n      }\n    });\n  };\n\n  _proto5.getTypes = function getTypes() {\n    return Array.from(this._types.values());\n  };\n\n  _proto5.getTypeByName = function getTypeByName(typename) {\n    return this._types.get(typename);\n  };\n\n  _proto5.getInterfaces = function getInterfaces(type) {\n    var _this$_typeInterfaces;\n\n    return (_this$_typeInterfaces = this._typeInterfaces.get(type)) !== null && _this$_typeInterfaces !== void 0 ? _this$_typeInterfaces : [];\n  };\n\n  _proto5.getPossibleTypeSet = function getPossibleTypeSet(type) {\n    var set;\n\n    if (type instanceof InterfaceType) {\n      var _this$_interfaceImple2;\n\n      set = (_this$_interfaceImple2 = this._interfaceImplementations.get(type)) !== null && _this$_interfaceImple2 !== void 0 ? _this$_interfaceImple2 : new Set();\n    } else if (type instanceof UnionType) {\n      var _this$_unionTypes$get;\n\n      set = (_this$_unionTypes$get = this._unionTypes.get(type)) !== null && _this$_unionTypes$get !== void 0 ? _this$_unionTypes$get : new Set();\n    } else {\n      throw createCompilerError('Invalid type supplied to \"getPossibleTypeSet\"');\n    }\n\n    if (!set) {\n      throw createCompilerError(\"Unable to find possible types for \".concat(type.name));\n    }\n\n    return set;\n  };\n\n  _proto5.getFetchableFieldName = function getFetchableFieldName(type) {\n    var _this$_fetchable$get$, _this$_fetchable$get;\n\n    return (_this$_fetchable$get$ = (_this$_fetchable$get = this._fetchable.get(type)) === null || _this$_fetchable$get === void 0 ? void 0 : _this$_fetchable$get.field_name) !== null && _this$_fetchable$get$ !== void 0 ? _this$_fetchable$get$ : null;\n  };\n\n  _proto5.getQueryType = function getQueryType() {\n    return this._types.get(this._queryTypeName);\n  };\n\n  _proto5.getMutationType = function getMutationType() {\n    return this._types.get(this._mutationTypeName);\n  };\n\n  _proto5.getSubscriptionType = function getSubscriptionType() {\n    return this._types.get(this._subscriptionTypeName);\n  };\n\n  _proto5.getField = function getField(type, fieldName) {\n    var fields = this._fields.get(type);\n\n    if (fields) {\n      return fields.get(fieldName);\n    }\n  };\n\n  _proto5.getFieldMap = function getFieldMap(type) {\n    return this._fields.get(type);\n  };\n\n  _proto5.getInputField = function getInputField(type, fieldName) {\n    var inputFields = this._inputFields.get(type);\n\n    if (inputFields) {\n      return inputFields.get(fieldName);\n    }\n  };\n\n  _proto5.getInputFieldMap = function getInputFieldMap(type) {\n    return this._inputFields.get(type);\n  };\n\n  _proto5.getDirectives = function getDirectives() {\n    return Array.from(this._directives.values());\n  };\n\n  _proto5.extend = function extend(extensions) {\n    return new TypeMap(this._source, this._extensions.concat(extensions));\n  };\n\n  return TypeMap;\n}();\n\nfunction create(baseSchema, schemaExtensionDocuments, schemaExtensions) {\n  var extensions = [];\n  schemaExtensions && schemaExtensions.forEach(function (source) {\n    var doc = parse(source, {\n      noLocation: true\n    });\n    doc.definitions.forEach(function (definition) {\n      if (isSchemaDefinitionAST(definition)) {\n        extensions.push(definition);\n      }\n    });\n  });\n  schemaExtensionDocuments && schemaExtensionDocuments.forEach(function (doc) {\n    doc.definitions.forEach(function (definition) {\n      if (isSchemaDefinitionAST(definition)) {\n        extensions.push(definition);\n      }\n    });\n  });\n  return new Schema(new TypeMap(baseSchema, extensions));\n}\n\nfunction parseInputArgumentDefinitions(schema, args) {\n  return args.map(function (arg) {\n    var argType = schema.assertInputType(schema.expectTypeFromAST(arg.typeNode));\n    var defaultValue;\n    var defaultValueNode = arg.defaultValue;\n\n    if (defaultValueNode != null) {\n      var nullableType = schema.getNullableType(argType);\n      var isNullable = schema.isNonNull(argType) === false;\n\n      if (isNullable && defaultValueNode.kind === 'NullValue') {\n        defaultValue = null;\n      } else {\n        if (nullableType instanceof ScalarType || nullableType instanceof EnumType) {\n          defaultValue = schema.parseLiteral(nullableType, defaultValueNode);\n        } else if (nullableType instanceof List && defaultValueNode.kind === 'ListValue' || nullableType instanceof InputObjectType && defaultValueNode.kind === 'ObjectValue') {\n          defaultValue = valueFromASTUntyped(defaultValueNode);\n        }\n      }\n\n      if (defaultValue === undefined) {\n        throw createCompilerError(\"parseInputArgumentDefinitions: Unexpected default value: \".concat(String(defaultValueNode), \". Expected to have a value of type \").concat(String(nullableType), \".\"));\n      }\n    }\n\n    return {\n      name: arg.name,\n      type: argType,\n      defaultValue: defaultValue\n    };\n  });\n}\n\nfunction parseInputArgumentDefinitionsMap(schema, args) {\n  return new Map(parseInputArgumentDefinitions(schema, args).map(function (arg) {\n    return [arg.name, arg];\n  }));\n}\n\nfunction isDefaultScalar(name) {\n  return new Set(['ID', 'String', 'Boolean', 'Int', 'Float']).has(name);\n}\n\nmodule.exports = {\n  create: create\n};","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/relay-compiler/lib/core/Schema.js"],"names":["_interopRequireDefault","require","_inheritsLoose2","_createForOfIteratorHelper","o","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","i","F","s","n","length","done","value","e","_e","f","TypeError","it","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","_require","createCompilerError","_require2","isSchemaDefinitionAST","_require3","GraphQLFloat","GraphQLInt","GraphQLBoolean","GraphQLString","GraphQLID","parse","parseType","print","valueFromASTUntyped","Type","isClient","_proto","toJSON","String","ScalarType","_Type","apply","arguments","EnumType","_Type2","values","_this","UnionType","_Type3","ObjectType","_Type4","InputObjectType","_Type5","InterfaceType","_Type6","List","type","ofType","_typeString","concat","_proto2","NonNull","_proto3","Field","schema","belongsTo","args","parseInputArgumentDefinitionsMap","unwrap","hasConcreteTypeThatImplements","interfaceType","_isAbstractType","getConcreteTypes","some","concreteType","implementsInterface","assertCompositeType","concreteTypes","Set","getPossibleTypes","forEach","possibleType","_isObject","add","TYPENAME_FIELD","CLIENT_ID_FIELD","QUERY_TYPE_KEY","MUTATION_TYPE_KEY","SUBSCRIPTION_TYPE_KEY","_isScalar","_isEnum","_isUnion","_isInputObject","_isInterface","_isWrapper","isBaseType","_isCompositeType","_isInputType","Schema","typeMap","_this2","_typeMap","_typeWrappersMap","Map","_fieldsMap","_typeNameMap","_clientIdMap","_directiveMap","getDirectives","map","directive","locations","parseInputArgumentDefinitions","_proto4","getTypes","getTypeFromAST","typeNode","kind","innerType","cacheKey","getTypeString","get","set","_innerType","_cacheKey","_type","getTypeByName","_getRawType","typeName","operationType","getQueryType","getMutationType","getSubscriptionType","getTypeFromString","expectTypeFromString","expectTypeFromAST","ast","getNonNullType","nonNullType","getRawType","getNullableType","getListItemType","areEqualTypes","typeA","typeB","mayImplement","isAbstractType","_this3","getInterfaces","typeInterface","canHaveSelections","isObject","isInterface","isTypeSubTypeOf","maybeSubType","superType","isPossibleType","assertAbstractType","assertObjectType","doTypesOverlap","_this4","getPossibleTypeSet","has","assertScalarFieldType","assertLinkedFieldType","assertInputType","asCompositeType","asInputType","asScalarFieldType","assertScalarType","assertInputObjectType","assertInterfaceType","assertLeafType","isLeafType","assertUnionType","assertEnumType","assertIntType","isInt","assertFloatType","isFloat","assertBooleanType","isBoolean","assertStringType","isString","assertIdType","isId","expectBooleanType","expectIntType","expectFloatType","expectStringType","expectIdType","queryType","mutationType","subscriptionType","expectQueryType","expectMutationType","expectSubscriptionType","isNonNull","isList","isWrapper","isScalar","isEnum","isUnion","isInputObject","isInputType","isCompositeType","hasField","fieldName","canHaveTypename","getField","getInputField","hasId","idField","expectField","getFieldType","getFields","fieldsMap","_getFieldsMap","cachedMap","fields","getFieldMap","_iterator","_step","_step$value","fieldDefinition","fieldType","_fields","getInputFieldMap","_iterator2","_step2","_step2$value","_fieldName","_fieldType","size","getFieldByName","typename","clientId","field","getFieldConfig","getFieldName","getFieldParentType","getFieldArgs","getFieldArgByName","argName","getEnumValues","getUnionTypes","getFetchableFieldName","parseLiteral","valueNode","parseValue","isDefaultScalar","includes","undefined","serialize","getDirective","directiveName","isServerType","unwrapped","isServerField","isServerDirective","isServerDefinedField","directives","_ref","isClientDefinedField","extend","extensions","doc","join","schemaExtensions","definitions","definition","push","TypeMap","source","_types","_typeInterfaces","_unionTypes","_interfaceImplementations","_inputFields","_directives","defaultValue","_queryTypeName","_mutationTypeName","_subscriptionTypeName","_source","_extensions","_fetchable","_parse","_extend","_proto5","_this5","document","noLocation","_parseSchemaDefinition","_parseScalarNode","_parseEnumNode","_parseObjectTypeNode","_parseInputObjectTypeNode","_parseUnionNode","_parseInterfaceNode","_parseDirective","node","_this6","operationTypes","operation","_this7","_this$_types$get","typeInterfaces","interfaces","interfaceTypeNode","_this$_interfaceImple","interfaceName","implementations","fetchable","directiveNode","field_name_arg","find","arg","field_name","_handleTypeFieldsStrict","_parseInputObjectFields","_this8","union","types","typeInUnion","_this$_types$get2","typeInUnionName","object","_handleTypeFields","_this$_fields$get","fieldNode","location","_parseObjectTypeExtension","_parseInterfaceTypeExtension","_this9","_this$_typeInterfaces","_this$_interfaceImple2","_this$_unionTypes$get","_this$_fetchable$get$","_this$_fetchable$get","inputFields","create","baseSchema","schemaExtensionDocuments","argType","defaultValueNode","nullableType","isNullable","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n * @emails oncall+relay\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require('./CompilerError'),\n    createCompilerError = _require.createCompilerError;\n\nvar _require2 = require('./SchemaUtils'),\n    isSchemaDefinitionAST = _require2.isSchemaDefinitionAST;\n\nvar _require3 = require('graphql'),\n    GraphQLFloat = _require3.GraphQLFloat,\n    GraphQLInt = _require3.GraphQLInt,\n    GraphQLBoolean = _require3.GraphQLBoolean,\n    GraphQLString = _require3.GraphQLString,\n    GraphQLID = _require3.GraphQLID,\n    parse = _require3.parse,\n    parseType = _require3.parseType,\n    print = _require3.print,\n    valueFromASTUntyped = _require3.valueFromASTUntyped;\n\n/**\n * @private\n */\nvar Type = /*#__PURE__*/function () {\n  function Type(name, isClient) {\n    this.name = name;\n    this.isClient = isClient;\n  }\n\n  var _proto = Type.prototype;\n\n  _proto.toString = function toString() {\n    return this.name;\n  };\n\n  _proto.toJSON = function toJSON() {\n    return String(this);\n  };\n\n  return Type;\n}();\n/**\n * @private\n */\n\n\nvar ScalarType = /*#__PURE__*/function (_Type) {\n  (0, _inheritsLoose2[\"default\"])(ScalarType, _Type);\n\n  function ScalarType() {\n    return _Type.apply(this, arguments) || this;\n  }\n\n  return ScalarType;\n}(Type);\n/**\n * @private\n */\n\n\nvar EnumType = /*#__PURE__*/function (_Type2) {\n  (0, _inheritsLoose2[\"default\"])(EnumType, _Type2);\n\n  function EnumType(name, values, isClient) {\n    var _this;\n\n    _this = _Type2.call(this, name, isClient) || this;\n    _this.values = values;\n    return _this;\n  }\n\n  return EnumType;\n}(Type);\n/**\n * @private\n */\n\n\nvar UnionType = /*#__PURE__*/function (_Type3) {\n  (0, _inheritsLoose2[\"default\"])(UnionType, _Type3);\n\n  function UnionType() {\n    return _Type3.apply(this, arguments) || this;\n  }\n\n  return UnionType;\n}(Type);\n/**\n * @private\n */\n\n\nvar ObjectType = /*#__PURE__*/function (_Type4) {\n  (0, _inheritsLoose2[\"default\"])(ObjectType, _Type4);\n\n  function ObjectType() {\n    return _Type4.apply(this, arguments) || this;\n  }\n\n  return ObjectType;\n}(Type);\n/**\n * @private\n */\n\n\nvar InputObjectType = /*#__PURE__*/function (_Type5) {\n  (0, _inheritsLoose2[\"default\"])(InputObjectType, _Type5);\n\n  function InputObjectType() {\n    return _Type5.apply(this, arguments) || this;\n  }\n\n  return InputObjectType;\n}(Type);\n/**\n * @private\n */\n\n\nvar InterfaceType = /*#__PURE__*/function (_Type6) {\n  (0, _inheritsLoose2[\"default\"])(InterfaceType, _Type6);\n\n  function InterfaceType() {\n    return _Type6.apply(this, arguments) || this;\n  }\n\n  return InterfaceType;\n}(Type);\n/**\n * @private\n */\n\n\nvar List = /*#__PURE__*/function () {\n  function List(type) {\n    this.ofType = type;\n    this._typeString = \"[\".concat(String(this.ofType), \"]\");\n  }\n\n  var _proto2 = List.prototype;\n\n  _proto2.toString = function toString() {\n    return this._typeString;\n  };\n\n  _proto2.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return List;\n}();\n/**\n * @private\n */\n\n\nvar NonNull = /*#__PURE__*/function () {\n  function NonNull(type) {\n    this.ofType = type;\n    this._typeString = \"\".concat(String(this.ofType), \"!\");\n  }\n\n  var _proto3 = NonNull.prototype;\n\n  _proto3.toString = function toString() {\n    return this._typeString;\n  };\n\n  _proto3.toJSON = function toJSON() {\n    return this.toString();\n  };\n\n  return NonNull;\n}();\n/**\n * @private\n */\n\n\nvar Field = function Field(schema, name, type, belongsTo, args, isClient) {\n  this.name = name;\n  this.type = type;\n  this.belongsTo = belongsTo;\n  this.isClient = isClient;\n  this.args = parseInputArgumentDefinitionsMap(schema, args);\n};\n/**\n * @private\n */\n\n\nfunction unwrap(type) {\n  if (type instanceof NonNull || type instanceof List) {\n    return unwrap(type.ofType);\n  }\n\n  return type;\n}\n/**\n * @private\n */\n\n\nfunction hasConcreteTypeThatImplements(schema, type, interfaceType) {\n  return _isAbstractType(type) && getConcreteTypes(schema, type).some(function (concreteType) {\n    return schema.implementsInterface(schema.assertCompositeType(concreteType), interfaceType);\n  });\n}\n/**\n * @private\n */\n\n\nfunction getConcreteTypes(schema, type) {\n  var concreteTypes = new Set();\n  schema.getPossibleTypes(type).forEach(function (possibleType) {\n    if (_isObject(possibleType)) {\n      concreteTypes.add(possibleType);\n    }\n  });\n  return Array.from(concreteTypes);\n}\n\nvar TYPENAME_FIELD = '__typename';\nvar CLIENT_ID_FIELD = '__id';\nvar QUERY_TYPE_KEY = Symbol('Query');\nvar MUTATION_TYPE_KEY = Symbol('Mutation');\nvar SUBSCRIPTION_TYPE_KEY = Symbol('Subscription');\n\nfunction _isScalar(type) {\n  return type instanceof ScalarType;\n}\n\nfunction _isObject(type) {\n  return type instanceof ObjectType;\n}\n\nfunction _isEnum(type) {\n  return type instanceof EnumType;\n}\n\nfunction _isUnion(type) {\n  return type instanceof UnionType;\n}\n\nfunction _isInputObject(type) {\n  return type instanceof InputObjectType;\n}\n\nfunction _isInterface(type) {\n  return type instanceof InterfaceType;\n}\n\nfunction _isWrapper(type) {\n  return type instanceof List || type instanceof NonNull;\n}\n\nfunction isBaseType(type) {\n  return type instanceof ScalarType || type instanceof ObjectType || type instanceof EnumType || type instanceof UnionType || type instanceof InputObjectType || type instanceof InterfaceType;\n}\n\nfunction _isAbstractType(type) {\n  return type instanceof UnionType || type instanceof InterfaceType;\n}\n\nfunction _isCompositeType(type) {\n  return type instanceof ObjectType || type instanceof UnionType || type instanceof InterfaceType;\n}\n\nfunction _isInputType(type) {\n  return type instanceof InputObjectType || type instanceof ScalarType || type instanceof EnumType;\n}\n\nvar Schema = /*#__PURE__*/function () {\n  /**\n   * @private\n   */\n  function Schema(typeMap) {\n    var _this2 = this;\n\n    this._typeMap = typeMap;\n    this._typeWrappersMap = new Map();\n    this._fieldsMap = new Map();\n    this._typeNameMap = new Map();\n    this._clientIdMap = new Map();\n    this._directiveMap = new Map(typeMap.getDirectives().map(function (directive) {\n      return [directive.name, {\n        locations: directive.locations,\n        args: parseInputArgumentDefinitions(_this2, directive.args),\n        name: directive.name,\n        isClient: directive.isClient\n      }];\n    }));\n  }\n\n  var _proto4 = Schema.prototype;\n\n  _proto4.getTypes = function getTypes() {\n    return this._typeMap.getTypes();\n  };\n\n  _proto4.getTypeFromAST = function getTypeFromAST(typeNode) {\n    if (typeNode.kind === 'NonNullType') {\n      var innerType = this.getTypeFromAST(typeNode.type);\n\n      if (!innerType) {\n        return;\n      }\n\n      if (innerType instanceof NonNull) {\n        throw createCompilerError('Unable to wrap non-nullable type with non-null wrapper.');\n      }\n\n      var cacheKey = \"\".concat(this.getTypeString(innerType), \"!\");\n\n      var type = this._typeWrappersMap.get(cacheKey);\n\n      if (type) {\n        return type;\n      }\n\n      type = new NonNull(innerType);\n\n      this._typeWrappersMap.set(cacheKey, type);\n\n      return type;\n    } else if (typeNode.kind === 'ListType') {\n      var _innerType = this.getTypeFromAST(typeNode.type);\n\n      if (!_innerType) {\n        return;\n      }\n\n      var _cacheKey = \"[\".concat(this.getTypeString(_innerType), \"]\");\n\n      var _type = this._typeWrappersMap.get(_cacheKey);\n\n      if (_type) {\n        return _type;\n      }\n\n      _type = new List(_innerType);\n\n      this._typeWrappersMap.set(_cacheKey, _type);\n\n      return _type;\n    }\n\n    return this._typeMap.getTypeByName(typeNode.name.value);\n  };\n\n  _proto4._getRawType = function _getRawType(typeName) {\n    var type = this._typeWrappersMap.get(typeName);\n\n    if (type) {\n      return type;\n    }\n\n    if (typeof typeName === 'string') {\n      return this.getTypeFromAST(parseType(typeName));\n    } else {\n      var operationType;\n\n      if (typeName === QUERY_TYPE_KEY) {\n        operationType = this._typeMap.getQueryType();\n      } else if (typeName === MUTATION_TYPE_KEY) {\n        operationType = this._typeMap.getMutationType();\n      } else if (typeName === SUBSCRIPTION_TYPE_KEY) {\n        operationType = this._typeMap.getSubscriptionType();\n      }\n\n      if (operationType instanceof ObjectType) {\n        return operationType;\n      }\n    }\n  };\n\n  _proto4.getTypeFromString = function getTypeFromString(typeName) {\n    return this._getRawType(typeName);\n  };\n\n  _proto4.expectTypeFromString = function expectTypeFromString(typeName) {\n    var type = this.getTypeFromString(typeName);\n\n    if (type == null) {\n      throw createCompilerError(\"Unknown type: '\".concat(typeName, \"'.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.expectTypeFromAST = function expectTypeFromAST(ast) {\n    var type = this.getTypeFromAST(ast);\n\n    if (type == null) {\n      throw createCompilerError(\"Unknown type: '\".concat(print(ast), \"'.\"), null, [ast]);\n    }\n\n    return type;\n  };\n\n  _proto4.getNonNullType = function getNonNullType(type) {\n    if (type instanceof NonNull) {\n      return type;\n    }\n\n    var cacheKey = \"\".concat(String(type), \"!\");\n\n    var nonNullType = this._typeWrappersMap.get(cacheKey);\n\n    if (nonNullType) {\n      return nonNullType;\n    }\n\n    nonNullType = new NonNull(type);\n\n    this._typeWrappersMap.set(cacheKey, nonNullType);\n\n    return nonNullType;\n  };\n\n  _proto4.getRawType = function getRawType(type) {\n    return unwrap(type);\n  };\n\n  _proto4.getNullableType = function getNullableType(type) {\n    if (type instanceof NonNull) {\n      return type.ofType;\n    }\n\n    return type;\n  };\n\n  _proto4.getListItemType = function getListItemType(type) {\n    if (type instanceof List) {\n      return type.ofType;\n    }\n\n    return type;\n  };\n\n  _proto4.areEqualTypes = function areEqualTypes(typeA, typeB) {\n    if (typeA === typeB) {\n      return true;\n    }\n\n    if (typeA instanceof NonNull && typeB instanceof NonNull) {\n      return this.areEqualTypes(typeA.ofType, typeB.ofType);\n    }\n\n    if (typeA instanceof List && typeB instanceof List) {\n      return this.areEqualTypes(typeA.ofType, typeB.ofType);\n    }\n\n    if (isBaseType(typeA) && isBaseType(typeB)) {\n      return typeA.name === typeB.name;\n    }\n\n    return false;\n  }\n  /**\n   * Determine if the given type may implement the named type:\n   * - it is the named type\n   * - it implements the named interface\n   * - it is an abstract type and *some* of its concrete types may\n   *   implement the named type\n   */\n  ;\n\n  _proto4.mayImplement = function mayImplement(type, interfaceType) {\n    return this.areEqualTypes(type, interfaceType) || this.implementsInterface(type, interfaceType) || this.isAbstractType(type) && hasConcreteTypeThatImplements(this, type, interfaceType);\n  };\n\n  _proto4.implementsInterface = function implementsInterface(type, interfaceType) {\n    var _this3 = this;\n\n    return this.getInterfaces(type).some(function (typeInterface) {\n      return _this3.areEqualTypes(typeInterface, interfaceType);\n    });\n  };\n\n  _proto4.canHaveSelections = function canHaveSelections(type) {\n    return this.isObject(type) || this.isInterface(type);\n  };\n\n  _proto4.getTypeString = function getTypeString(type) {\n    return type.toString();\n  };\n\n  _proto4.isTypeSubTypeOf = function isTypeSubTypeOf(maybeSubType, superType) {\n    // Equivalent type is a valid subtype\n    if (maybeSubType === superType) {\n      return true;\n    } // If superType is non-null, maybeSubType must also be non-null.\n\n\n    if (superType instanceof NonNull) {\n      if (maybeSubType instanceof NonNull) {\n        return this.isTypeSubTypeOf(maybeSubType.ofType, superType.ofType);\n      }\n\n      return false;\n    }\n\n    if (maybeSubType instanceof NonNull) {\n      // If superType is nullable, maybeSubType may be non-null or nullable.\n      return this.isTypeSubTypeOf(maybeSubType.ofType, superType);\n    } // If superType type is a list, maybeSubType type must also be a list.\n\n\n    if (superType instanceof List) {\n      if (maybeSubType instanceof List) {\n        return this.isTypeSubTypeOf(maybeSubType.ofType, superType.ofType);\n      }\n\n      return false;\n    }\n\n    if (maybeSubType instanceof List) {\n      // If superType is not a list, maybeSubType must also be not a list.\n      return false;\n    } // If superType type is an abstract type, maybeSubType type may be a currently\n    // possible object type.\n\n\n    if (this.isAbstractType(superType) && this.isObject(maybeSubType) && this.isPossibleType(this.assertAbstractType(superType), this.assertObjectType(maybeSubType))) {\n      return true;\n    } // Otherwise, maybeSubType is not a valid subtype of the superType.\n\n\n    return false;\n  }\n  /**\n   * Provided two composite types, determine if they \"overlap\". Two composite\n   * types overlap when the Sets of possible concrete types for each intersect.\n   *\n   * This is often used to determine if a fragment of a given type could possibly\n   * be visited in a context of another type.\n   *\n   * This function is commutative.\n   */\n  ;\n\n  _proto4.doTypesOverlap = function doTypesOverlap(typeA, typeB) {\n    var _this4 = this;\n\n    // Equivalent types overlap\n    if (typeA === typeB) {\n      return true;\n    }\n\n    if (_isAbstractType(typeA)) {\n      if (_isAbstractType(typeB)) {\n        // If both types are abstract, then determine if there is any intersection\n        // between possible concrete types of each.\n        return Array.from(this.getPossibleTypes(typeA)).some(function (type) {\n          if (_isObject(type)) {\n            return _this4.isPossibleType(typeB, type);\n          }\n        });\n      } // Determine if the latter type is a possible concrete type of the former.\n\n\n      return this.isPossibleType(typeA, typeB);\n    }\n\n    if (_isAbstractType(typeB)) {\n      // Determine if the former type is a possible concrete type of the latter.\n      return this.isPossibleType(typeB, typeA);\n    } // Otherwise the types do not overlap.\n\n\n    return false;\n  };\n\n  _proto4.isPossibleType = function isPossibleType(superType, maybeSubType) {\n    return this._typeMap.getPossibleTypeSet(superType).has(maybeSubType);\n  };\n\n  _proto4.assertScalarFieldType = function assertScalarFieldType(type) {\n    // Scalar type fields can be wrappers / or can be scalars/enums\n    if (_isWrapper(type) && !_isScalar(unwrap(type)) && !_isEnum(unwrap(type)) || !_isWrapper(type) && !_isScalar(type) && !_isEnum(type)) {\n      throw createCompilerError(\"Expected \".concat(String(type), \" to be a Scalar or Enum type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertLinkedFieldType = function assertLinkedFieldType(type) {\n    // Linked Field types can be wrappers / or can be composite types\n    if (_isWrapper(type) && !_isCompositeType(unwrap(type)) || !_isWrapper(type) && !_isCompositeType(type)) {\n      throw createCompilerError(\"Expected \".concat(String(type), \" to be a Object, Interface or a Union Type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertInputType = function assertInputType(type) {\n    // Input type fields can be wrappers / or can be scalars/enums\n    if (_isWrapper(type) && !_isInputType(unwrap(type)) || !_isWrapper(type) && !_isInputType(type)) {\n      throw createCompilerError(\"Expected \".concat(String(type), \" to be a Input, Scalar or Enum type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.asCompositeType = function asCompositeType(type) {\n    if (_isCompositeType(type)) {\n      return type;\n    }\n  };\n\n  _proto4.asInputType = function asInputType(type) {\n    if (_isWrapper(type) && _isInputType(unwrap(type)) || !_isWrapper(type) && _isInputType(type)) {\n      return type;\n    }\n  };\n\n  _proto4.asScalarFieldType = function asScalarFieldType(type) {\n    if (_isScalar(type) || _isEnum(type)) {\n      return type;\n    }\n  };\n\n  _proto4.assertScalarType = function assertScalarType(type) {\n    if (!_isScalar(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a scalar type, got \").concat(this.getTypeString(type), \".\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertObjectType = function assertObjectType(type) {\n    if (!_isObject(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be an object type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertInputObjectType = function assertInputObjectType(type) {\n    if (!_isInputObject(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be an input type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertInterfaceType = function assertInterfaceType(type) {\n    if (!_isInterface(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be an interface type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertCompositeType = function assertCompositeType(type) {\n    if (!_isCompositeType(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a composite type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertAbstractType = function assertAbstractType(type) {\n    if (!_isAbstractType(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be an abstract type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertLeafType = function assertLeafType(type) {\n    if (!this.isLeafType(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a leaf type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertUnionType = function assertUnionType(type) {\n    if (!_isUnion(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a union type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertEnumType = function assertEnumType(type) {\n    if (!_isEnum(type)) {\n      throw createCompilerError(\"Expected \".concat(String(type), \" to be an enum type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertIntType = function assertIntType(type) {\n    if (!_isScalar(type) || !this.isInt(type)) {\n      throw createCompilerError(\"Expected \".concat(String(type), \" to be an 'Int' type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertFloatType = function assertFloatType(type) {\n    if (!_isScalar(type) || !this.isFloat(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a 'Float' type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertBooleanType = function assertBooleanType(type) {\n    if (!_isScalar(type) || !this.isBoolean(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a 'Boolean' type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertStringType = function assertStringType(type) {\n    if (!_isScalar(type) || !this.isString(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be a 'String' type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.assertIdType = function assertIdType(type) {\n    if (!_isScalar(type) || !this.isId(type)) {\n      throw createCompilerError(\"Expected \".concat(this.getTypeString(type), \" to be an ID type.\"));\n    }\n\n    return type;\n  };\n\n  _proto4.expectBooleanType = function expectBooleanType() {\n    return this.assertScalarType(this.expectTypeFromString('Boolean'));\n  };\n\n  _proto4.expectIntType = function expectIntType() {\n    return this.assertScalarType(this.expectTypeFromString('Int'));\n  };\n\n  _proto4.expectFloatType = function expectFloatType() {\n    return this.assertScalarType(this.expectTypeFromString('Float'));\n  };\n\n  _proto4.expectStringType = function expectStringType() {\n    return this.assertScalarType(this.expectTypeFromString('String'));\n  };\n\n  _proto4.expectIdType = function expectIdType() {\n    return this.assertScalarType(this.expectTypeFromString('ID'));\n  };\n\n  _proto4.getQueryType = function getQueryType() {\n    var queryType = this._getRawType(QUERY_TYPE_KEY);\n\n    if (queryType && _isObject(queryType)) {\n      return queryType;\n    }\n  };\n\n  _proto4.getMutationType = function getMutationType() {\n    var mutationType = this._getRawType(MUTATION_TYPE_KEY);\n\n    if (mutationType && _isObject(mutationType)) {\n      return mutationType;\n    }\n  };\n\n  _proto4.getSubscriptionType = function getSubscriptionType() {\n    var subscriptionType = this._getRawType(SUBSCRIPTION_TYPE_KEY);\n\n    if (subscriptionType && _isObject(subscriptionType)) {\n      return subscriptionType;\n    }\n  };\n\n  _proto4.expectQueryType = function expectQueryType() {\n    var queryType = this.getQueryType();\n\n    if (queryType == null) {\n      throw createCompilerError('Query type is not defined on the Schema');\n    }\n\n    return queryType;\n  };\n\n  _proto4.expectMutationType = function expectMutationType() {\n    var mutationType = this.getMutationType();\n\n    if (mutationType == null) {\n      throw createCompilerError('Mutation type is not defined the Schema');\n    }\n\n    return mutationType;\n  };\n\n  _proto4.expectSubscriptionType = function expectSubscriptionType() {\n    var subscriptionType = this.getSubscriptionType();\n\n    if (subscriptionType == null) {\n      throw createCompilerError('Subscription type is not defined the Schema');\n    }\n\n    return subscriptionType;\n  };\n\n  _proto4.isNonNull = function isNonNull(type) {\n    return type instanceof NonNull;\n  };\n\n  _proto4.isList = function isList(type) {\n    return type instanceof List;\n  };\n\n  _proto4.isWrapper = function isWrapper(type) {\n    return _isWrapper(type);\n  };\n\n  _proto4.isScalar = function isScalar(type) {\n    return _isScalar(type);\n  };\n\n  _proto4.isObject = function isObject(type) {\n    return _isObject(type);\n  };\n\n  _proto4.isEnum = function isEnum(type) {\n    return _isEnum(type);\n  };\n\n  _proto4.isUnion = function isUnion(type) {\n    return _isUnion(type);\n  };\n\n  _proto4.isInputObject = function isInputObject(type) {\n    return _isInputObject(type);\n  };\n\n  _proto4.isInterface = function isInterface(type) {\n    return _isInterface(type);\n  };\n\n  _proto4.isInputType = function isInputType(type) {\n    // Wrappers can be input types (so it's save to check unwrapped type here)\n    return _isInputType(type) || _isWrapper(type) && _isInputType(unwrap(type));\n  };\n\n  _proto4.isCompositeType = function isCompositeType(type) {\n    return _isCompositeType(type);\n  };\n\n  _proto4.isAbstractType = function isAbstractType(type) {\n    return _isAbstractType(type);\n  };\n\n  _proto4.isLeafType = function isLeafType(type) {\n    return this.isScalar(type) || this.isEnum(type);\n  };\n\n  _proto4.isId = function isId(type) {\n    if (type instanceof ScalarType) {\n      return type.name === 'ID';\n    }\n\n    return false;\n  };\n\n  _proto4.isInt = function isInt(type) {\n    if (type instanceof ScalarType) {\n      return type.name === 'Int';\n    }\n\n    return false;\n  };\n\n  _proto4.isFloat = function isFloat(type) {\n    if (type instanceof ScalarType) {\n      return type.name === 'Float';\n    }\n\n    return false;\n  };\n\n  _proto4.isBoolean = function isBoolean(type) {\n    if (type instanceof ScalarType) {\n      return type.name === 'Boolean';\n    }\n\n    return false;\n  };\n\n  _proto4.isString = function isString(type) {\n    if (type instanceof ScalarType) {\n      return type.name === 'String';\n    }\n\n    return false;\n  };\n\n  _proto4.hasField = function hasField(type, fieldName) {\n    var canHaveTypename = this.isObject(type) || this.isAbstractType(type); // Special case for __typename field\n\n    if (canHaveTypename && (fieldName === TYPENAME_FIELD || fieldName === CLIENT_ID_FIELD)) {\n      return true;\n    }\n\n    if (type instanceof ObjectType || type instanceof InterfaceType) {\n      return this._typeMap.getField(type, fieldName) != null;\n    } else if (type instanceof InputObjectType) {\n      return this._typeMap.getInputField(type, fieldName) != null;\n    }\n\n    return false;\n  };\n\n  _proto4.hasId = function hasId(type) {\n    if (!this.hasField(type, 'id')) {\n      return false;\n    }\n\n    var idField = this.expectField(type, 'id');\n    return this.areEqualTypes(this.getNullableType(this.getFieldType(idField)), this.expectIdType());\n  };\n\n  _proto4.getFields = function getFields(type) {\n    var fieldsMap = this._getFieldsMap(type);\n\n    return Array.from(fieldsMap.values());\n  };\n\n  _proto4._getFieldsMap = function _getFieldsMap(type) {\n    var cachedMap = this._fieldsMap.get(type);\n\n    if (cachedMap != null) {\n      return cachedMap;\n    }\n\n    var fieldsMap = new Map();\n\n    if (type instanceof ObjectType || type instanceof InterfaceType) {\n      var fields = this._typeMap.getFieldMap(type);\n\n      if (fields) {\n        var _iterator = _createForOfIteratorHelper(fields),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _step$value = _step.value,\n                fieldName = _step$value[0],\n                fieldDefinition = _step$value[1];\n            var fieldType = this.expectTypeFromAST(fieldDefinition.type);\n            fieldsMap.set(fieldName, new Field(this, fieldName, fieldType, this.assertCompositeType(type), fieldDefinition.arguments, fieldDefinition.isClient));\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n    } else if (type instanceof InputObjectType) {\n      var _fields = this._typeMap.getInputFieldMap(type);\n\n      if (_fields) {\n        var _iterator2 = _createForOfIteratorHelper(_fields),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _step2.value,\n                _fieldName = _step2$value[0],\n                typeNode = _step2$value[1];\n\n            var _fieldType = this.expectTypeFromAST(typeNode);\n\n            fieldsMap.set(_fieldName, new Field(this, _fieldName, _fieldType, type, [], false));\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n\n    if (fieldsMap.size === 0) {\n      throw createCompilerError(\"_getFieldsMap: Type '\".concat(type.name, \"' should have fields.\"));\n    }\n\n    this._fieldsMap.set(type, fieldsMap);\n\n    return fieldsMap;\n  };\n\n  _proto4.getFieldByName = function getFieldByName(type, fieldName) {\n    if (!this.hasField(type, fieldName)) {\n      return;\n    } // A \"special\" case for __typename and __id fields - which should\n    // not be in the list of type fields, but should be fine to select\n\n\n    if (fieldName === TYPENAME_FIELD) {\n      var typename = this._typeNameMap.get(type);\n\n      if (!typename) {\n        typename = new Field(this, TYPENAME_FIELD, this.getNonNullType(this.expectStringType()), type, [], false);\n\n        this._typeNameMap.set(type, typename);\n      }\n\n      return typename;\n    }\n\n    if (fieldName === CLIENT_ID_FIELD) {\n      var clientId = this._clientIdMap.get(type);\n\n      if (!clientId) {\n        clientId = new Field(this, CLIENT_ID_FIELD, this.getNonNullType(this.expectIdType()), type, [], true);\n\n        this._clientIdMap.set(type, clientId);\n      }\n\n      return clientId;\n    }\n\n    if (_isUnion(type)) {\n      throw createCompilerError(\"Unexpected union type '\".concat(this.getTypeString(type), \"' in the 'getFieldByName(...)'. Expected type with fields\"));\n    }\n\n    var fieldsMap = this._getFieldsMap(type);\n\n    return fieldsMap.get(fieldName);\n  };\n\n  _proto4.expectField = function expectField(type, fieldName) {\n    var field = this.getFieldByName(type, fieldName);\n\n    if (!field) {\n      throw createCompilerError(\"Unknown field '\".concat(fieldName, \"' on type '\").concat(this.getTypeString(type), \"'.\"));\n    }\n\n    return field;\n  };\n\n  _proto4.getFieldConfig = function getFieldConfig(field) {\n    return {\n      type: field.type,\n      args: Array.from(field.args.values())\n    };\n  };\n\n  _proto4.getFieldName = function getFieldName(field) {\n    return field.name;\n  };\n\n  _proto4.getFieldType = function getFieldType(field) {\n    return field.type;\n  };\n\n  _proto4.getFieldParentType = function getFieldParentType(field) {\n    return field.belongsTo;\n  };\n\n  _proto4.getFieldArgs = function getFieldArgs(field) {\n    return Array.from(field.args.values());\n  };\n\n  _proto4.getFieldArgByName = function getFieldArgByName(field, argName) {\n    return field.args.get(argName);\n  };\n\n  _proto4.getEnumValues = function getEnumValues(type) {\n    return type.values;\n  };\n\n  _proto4.getUnionTypes = function getUnionTypes(type) {\n    return Array.from(this._typeMap.getPossibleTypeSet(type));\n  };\n\n  _proto4.getInterfaces = function getInterfaces(type) {\n    if (type instanceof ObjectType) {\n      return this._typeMap.getInterfaces(type);\n    }\n\n    return [];\n  };\n\n  _proto4.getPossibleTypes = function getPossibleTypes(type) {\n    return this._typeMap.getPossibleTypeSet(type);\n  };\n\n  _proto4.getFetchableFieldName = function getFetchableFieldName(type) {\n    return this._typeMap.getFetchableFieldName(type);\n  };\n\n  _proto4.parseLiteral = function parseLiteral(type, valueNode) {\n    if (type instanceof EnumType && valueNode.kind === 'EnumValue') {\n      return this.parseValue(type, valueNode.value);\n    } else if (type instanceof ScalarType) {\n      if (valueNode.kind === 'BooleanValue' && type.name === 'Boolean') {\n        return GraphQLBoolean.parseLiteral(valueNode);\n      } else if (valueNode.kind === 'FloatValue' && type.name === 'Float') {\n        return GraphQLFloat.parseLiteral(valueNode);\n      } else if (valueNode.kind === 'IntValue' && (type.name === 'Int' || type.name === 'ID' || type.name === 'Float')) {\n        return GraphQLInt.parseLiteral(valueNode);\n      } else if (valueNode.kind === 'StringValue' && (type.name === 'String' || type.name === 'ID')) {\n        return GraphQLString.parseLiteral(valueNode);\n      } else if (!isDefaultScalar(type.name)) {\n        return valueFromASTUntyped(valueNode);\n      }\n    }\n  };\n\n  _proto4.parseValue = function parseValue(type, value) {\n    if (type instanceof EnumType) {\n      return type.values.includes(value) ? value : undefined;\n    } else if (type instanceof ScalarType) {\n      switch (type.name) {\n        case 'Boolean':\n          return GraphQLBoolean.parseValue(value);\n\n        case 'Float':\n          return GraphQLFloat.parseValue(value);\n\n        case 'Int':\n          return GraphQLInt.parseValue(value);\n\n        case 'String':\n          return GraphQLString.parseValue(value);\n\n        case 'ID':\n          return GraphQLID.parseValue(value);\n\n        default:\n          return value;\n      }\n    }\n  };\n\n  _proto4.serialize = function serialize(type, value) {\n    if (type instanceof EnumType) {\n      return type.values.includes(value) ? value : undefined;\n    } else if (type instanceof ScalarType) {\n      switch (type.name) {\n        case 'Boolean':\n          return GraphQLBoolean.serialize(value);\n\n        case 'Float':\n          return GraphQLFloat.serialize(value);\n\n        case 'Int':\n          return GraphQLInt.serialize(value);\n\n        case 'String':\n          return GraphQLString.serialize(value);\n\n        case 'ID':\n          return GraphQLID.serialize(value);\n\n        default:\n          return value;\n      }\n    }\n  };\n\n  _proto4.getDirectives = function getDirectives() {\n    return Array.from(this._directiveMap.values());\n  };\n\n  _proto4.getDirective = function getDirective(directiveName) {\n    return this._directiveMap.get(directiveName);\n  };\n\n  _proto4.isServerType = function isServerType(type) {\n    var unwrapped = unwrap(type);\n    return unwrapped.isClient === false;\n  };\n\n  _proto4.isServerField = function isServerField(field) {\n    return field.isClient === false;\n  };\n\n  _proto4.isServerDirective = function isServerDirective(directiveName) {\n    var directive = this._directiveMap.get(directiveName);\n\n    return (directive === null || directive === void 0 ? void 0 : directive.isClient) === false;\n  };\n\n  _proto4.isServerDefinedField = function isServerDefinedField(type, field) {\n    return this.isAbstractType(type) && field.directives.some(function (_ref) {\n      var name = _ref.name;\n      return name === 'fixme_fat_interface';\n    }) || this.hasField(type, field.name) && this.isServerField(this.expectField(type, field.name));\n  };\n\n  _proto4.isClientDefinedField = function isClientDefinedField(type, field) {\n    return !this.isServerDefinedField(type, field);\n  };\n\n  _proto4.extend = function extend(extensions) {\n    var doc = Array.isArray(extensions) ? parse(extensions.join('\\n')) : extensions;\n    var schemaExtensions = [];\n    doc.definitions.forEach(function (definition) {\n      if (isSchemaDefinitionAST(definition)) {\n        schemaExtensions.push(definition);\n      }\n    });\n\n    if (schemaExtensions.length > 0) {\n      return new Schema(this._typeMap.extend(schemaExtensions));\n    }\n\n    return this;\n  };\n\n  return Schema;\n}();\n\nvar TypeMap = /*#__PURE__*/function () {\n  function TypeMap(source, extensions) {\n    this._types = new Map([['ID', new ScalarType('ID', false)], ['String', new ScalarType('String', false)], ['Boolean', new ScalarType('Boolean', false)], ['Float', new ScalarType('Float', false)], ['Int', new ScalarType('Int', false)]]);\n    this._typeInterfaces = new Map();\n    this._unionTypes = new Map();\n    this._interfaceImplementations = new Map();\n    this._fields = new Map();\n    this._inputFields = new Map();\n    this._directives = new Map([['include', {\n      name: 'include',\n      isClient: false,\n      locations: ['FIELD', 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT'],\n      args: [{\n        name: 'if',\n        typeNode: parseType('Boolean!'),\n        defaultValue: undefined\n      }]\n    }], ['skip', {\n      name: 'skip',\n      isClient: false,\n      locations: ['FIELD', 'FRAGMENT_SPREAD', 'INLINE_FRAGMENT'],\n      args: [{\n        name: 'if',\n        typeNode: parseType('Boolean!'),\n        defaultValue: undefined\n      }]\n    }], ['deprecated', {\n      name: 'deprecated',\n      isClient: false,\n      locations: ['FIELD_DEFINITION', 'ENUM_VALUE'],\n      args: [{\n        name: 'reason',\n        typeNode: parseType('String'),\n        defaultValue: {\n          kind: 'StringValue',\n          value: 'No longer supported'\n        }\n      }]\n    }]]);\n    this._queryTypeName = 'Query';\n    this._mutationTypeName = 'Mutation';\n    this._subscriptionTypeName = 'Subscription';\n    this._source = source;\n    this._extensions = extensions;\n    this._fetchable = new Map();\n\n    this._parse(source);\n\n    this._extend(extensions);\n  }\n\n  var _proto5 = TypeMap.prototype;\n\n  _proto5._parse = function _parse(source) {\n    var _this5 = this;\n\n    var document = parse(source, {\n      noLocation: true\n    });\n    document.definitions.forEach(function (definition) {\n      switch (definition.kind) {\n        case 'SchemaDefinition':\n          {\n            _this5._parseSchemaDefinition(definition);\n\n            break;\n          }\n\n        case 'ScalarTypeDefinition':\n          {\n            _this5._parseScalarNode(definition, false);\n\n            break;\n          }\n\n        case 'EnumTypeDefinition':\n          {\n            _this5._parseEnumNode(definition, false);\n\n            break;\n          }\n\n        case 'ObjectTypeDefinition':\n          {\n            _this5._parseObjectTypeNode(definition, false);\n\n            break;\n          }\n\n        case 'InputObjectTypeDefinition':\n          {\n            _this5._parseInputObjectTypeNode(definition, false);\n\n            break;\n          }\n\n        case 'UnionTypeDefinition':\n          {\n            _this5._parseUnionNode(definition, false);\n\n            break;\n          }\n\n        case 'InterfaceTypeDefinition':\n          {\n            _this5._parseInterfaceNode(definition, false);\n\n            break;\n          }\n\n        case 'DirectiveDefinition':\n          {\n            _this5._parseDirective(definition, false);\n\n            break;\n          }\n      }\n    });\n  };\n\n  _proto5._parseSchemaDefinition = function _parseSchemaDefinition(node) {\n    var _this6 = this;\n\n    node.operationTypes.forEach(function (operationType) {\n      switch (operationType.operation) {\n        case 'query':\n          _this6._queryTypeName = operationType.type.name.value;\n          break;\n\n        case 'mutation':\n          _this6._mutationTypeName = operationType.type.name.value;\n          break;\n\n        case 'subscription':\n          _this6._subscriptionTypeName = operationType.type.name.value;\n          break;\n      }\n    });\n  };\n\n  _proto5._parseScalarNode = function _parseScalarNode(node, isClient) {\n    var name = node.name.value;\n\n    if (!isDefaultScalar(name) && this._types.has(name)) {\n      throw createCompilerError(\"_parseScalarNode: Duplicate definition for type \".concat(name, \".\"), null, [node]);\n    }\n\n    this._types.set(name, new ScalarType(name, isClient));\n  };\n\n  _proto5._parseEnumNode = function _parseEnumNode(node, isClient) {\n    var name = node.name.value;\n\n    if (this._types.has(name)) {\n      throw createCompilerError(\"_parseEnumNode: Duplicate definition for type \".concat(name, \".\"), null, [node]);\n    } // SDL doesn't have information about the actual ENUM values\n\n\n    var values = node.values ? node.values.map(function (value) {\n      return value.name.value;\n    }) : [];\n\n    this._types.set(name, new EnumType(name, values, isClient));\n  };\n\n  _proto5._parseObjectTypeNode = function _parseObjectTypeNode(node, isClient) {\n    var _this7 = this;\n\n    var _this$_types$get;\n\n    var name = node.name.value; // Objects may be created by _parseUnionNode\n\n    var type = (_this$_types$get = this._types.get(name)) !== null && _this$_types$get !== void 0 ? _this$_types$get : new ObjectType(name, isClient);\n\n    if (!(type instanceof ObjectType)) {\n      throw createCompilerError(\"_parseObjectTypeNode: Expected object type, got \".concat(String(type)), null, [node]);\n    }\n\n    if (type.isClient !== isClient) {\n      throw createCompilerError(\"_parseObjectTypeNode: Cannot create object type '\".concat(name, \"' defined as a client type.\"), null, [node]);\n    }\n\n    var typeInterfaces = [];\n    node.interfaces && node.interfaces.forEach(function (interfaceTypeNode) {\n      var _this$_interfaceImple;\n\n      var interfaceName = interfaceTypeNode.name.value;\n\n      var interfaceType = _this7._types.get(interfaceName);\n\n      if (!interfaceType) {\n        interfaceType = new InterfaceType(interfaceName, isClient);\n\n        _this7._types.set(interfaceName, interfaceType);\n      }\n\n      if (!(interfaceType instanceof InterfaceType)) {\n        throw createCompilerError('_parseObjectTypeNode: Expected interface type', null, [interfaceTypeNode]);\n      }\n\n      var implementations = (_this$_interfaceImple = _this7._interfaceImplementations.get(interfaceType)) !== null && _this$_interfaceImple !== void 0 ? _this$_interfaceImple : new Set();\n      implementations.add(type);\n\n      _this7._interfaceImplementations.set(interfaceType, implementations);\n\n      typeInterfaces.push(interfaceType);\n    });\n    var fetchable = null;\n    node.directives && node.directives.forEach(function (directiveNode) {\n      if (directiveNode.name.value === 'fetchable') {\n        var field_name_arg = directiveNode.arguments && directiveNode.arguments.find(function (arg) {\n          return arg.name.value === 'field_name';\n        });\n\n        if (field_name_arg != null && field_name_arg.value.kind === 'StringValue') {\n          fetchable = {\n            field_name: field_name_arg.value.value\n          };\n        }\n      }\n    });\n\n    this._typeInterfaces.set(type, typeInterfaces);\n\n    this._types.set(name, type);\n\n    if (fetchable != null) {\n      this._fetchable.set(type, fetchable);\n    }\n\n    node.fields && this._handleTypeFieldsStrict(type, node.fields, isClient);\n  };\n\n  _proto5._parseInputObjectTypeNode = function _parseInputObjectTypeNode(node, isClient) {\n    var name = node.name.value;\n\n    if (this._types.has(name)) {\n      throw createCompilerError('_parseInputObjectTypeNode: Unable to parse schema file. Duplicate definition for object type', null, [node]);\n    }\n\n    var type = new InputObjectType(name, isClient);\n\n    this._types.set(name, type);\n\n    this._parseInputObjectFields(type, node);\n  };\n\n  _proto5._parseUnionNode = function _parseUnionNode(node, isClient) {\n    var _this8 = this;\n\n    var name = node.name.value;\n\n    if (this._types.has(name)) {\n      throw createCompilerError('_parseUnionNode: Unable to parse schema file. Duplicate definition for object type', null, [node]);\n    }\n\n    var union = new UnionType(name, isClient);\n\n    this._types.set(name, union);\n\n    this._unionTypes.set(union, new Set(node.types ? node.types.map(function (typeInUnion) {\n      var _this$_types$get2;\n\n      var typeInUnionName = typeInUnion.name.value;\n      var object = (_this$_types$get2 = _this8._types.get(typeInUnionName)) !== null && _this$_types$get2 !== void 0 ? _this$_types$get2 : new ObjectType(typeInUnionName, false);\n\n      if (!(object instanceof ObjectType)) {\n        throw createCompilerError('_parseUnionNode: Expected object type', null, [typeInUnion]);\n      }\n\n      _this8._types.set(typeInUnionName, object);\n\n      return object;\n    }) : []));\n  };\n\n  _proto5._parseInterfaceNode = function _parseInterfaceNode(node, isClient) {\n    var name = node.name.value;\n\n    var type = this._types.get(name);\n\n    if (!type) {\n      type = new InterfaceType(name, isClient);\n\n      this._types.set(name, type);\n    }\n\n    if (!(type instanceof InterfaceType)) {\n      throw createCompilerError(\"_parseInterfaceNode: Expected interface type. Got \".concat(String(type)), null, [node]);\n    }\n\n    if (type.isClient !== isClient) {\n      throw createCompilerError(\"_parseInterfaceNode: Cannot create interface '\".concat(name, \"' defined as a client interface\"), null, [node]);\n    }\n\n    node.fields && this._handleTypeFieldsStrict(type, node.fields, isClient);\n  };\n\n  _proto5._handleTypeFieldsStrict = function _handleTypeFieldsStrict(type, fields, isClient) {\n    if (this._fields.has(type)) {\n      throw createCompilerError('_handleTypeFieldsStrict: Unable to parse schema file. Duplicate definition for object type');\n    }\n\n    this._handleTypeFields(type, fields, isClient);\n  };\n\n  _proto5._handleTypeFields = function _handleTypeFields(type, fields, isClient) {\n    var _this$_fields$get;\n\n    var fieldsMap = (_this$_fields$get = this._fields.get(type)) !== null && _this$_fields$get !== void 0 ? _this$_fields$get : new Map();\n    fields.forEach(function (fieldNode) {\n      var fieldName = fieldNode.name.value;\n\n      if (fieldsMap.has(fieldName)) {\n        throw createCompilerError(\"_handleTypeFields: Duplicate definition for field '\".concat(fieldName, \"'.\"));\n      }\n\n      fieldsMap.set(fieldName, {\n        arguments: fieldNode.arguments ? fieldNode.arguments.map(function (arg) {\n          return {\n            name: arg.name.value,\n            typeNode: arg.type,\n            defaultValue: arg.defaultValue\n          };\n        }) : [],\n        type: fieldNode.type,\n        isClient: isClient\n      });\n    });\n\n    this._fields.set(type, fieldsMap);\n  };\n\n  _proto5._parseInputObjectFields = function _parseInputObjectFields(type, node) {\n    if (this._inputFields.has(type)) {\n      throw createCompilerError('_parseInputObjectFields: Unable to parse schema file. Duplicate definition for type', null, [node]);\n    }\n\n    var fields = new Map();\n\n    if (node.fields) {\n      node.fields.forEach(function (fieldNode) {\n        fields.set(fieldNode.name.value, fieldNode.type);\n      });\n    }\n\n    this._inputFields.set(type, fields);\n  };\n\n  _proto5._parseDirective = function _parseDirective(node, isClient) {\n    var name = node.name.value;\n\n    this._directives.set(name, {\n      name: name,\n      args: node.arguments ? node.arguments.map(function (arg) {\n        return {\n          name: arg.name.value,\n          typeNode: arg.type,\n          defaultValue: arg.defaultValue\n        };\n      }) : [],\n      locations: node.locations.map(function (location) {\n        switch (location.value) {\n          case 'QUERY':\n          case 'MUTATION':\n          case 'SUBSCRIPTION':\n          case 'FIELD':\n          case 'FRAGMENT_DEFINITION':\n          case 'FRAGMENT_SPREAD':\n          case 'INLINE_FRAGMENT':\n          case 'VARIABLE_DEFINITION':\n          case 'SCHEMA':\n          case 'SCALAR':\n          case 'OBJECT':\n          case 'FIELD_DEFINITION':\n          case 'ARGUMENT_DEFINITION':\n          case 'INTERFACE':\n          case 'UNION':\n          case 'ENUM':\n          case 'ENUM_VALUE':\n          case 'INPUT_OBJECT':\n          case 'INPUT_FIELD_DEFINITION':\n            return location.value;\n\n          default:\n            throw createCompilerError('Invalid directive location');\n        }\n      }),\n      isClient: isClient\n    });\n  };\n\n  _proto5._parseObjectTypeExtension = function _parseObjectTypeExtension(node) {\n    var type = this._types.get(node.name.value);\n\n    if (!(type instanceof ObjectType)) {\n      throw createCompilerError(\"_parseObjectTypeExtension: Expected to find type with the name '\".concat(node.name.value, \"'\"), null, [node]);\n    }\n\n    node.fields && this._handleTypeFields(type, node.fields, true\n    /** client fields */\n    );\n  };\n\n  _proto5._parseInterfaceTypeExtension = function _parseInterfaceTypeExtension(node) {\n    var type = this._types.get(node.name.value);\n\n    if (!(type instanceof InterfaceType)) {\n      throw createCompilerError('_parseInterfaceTypeExtension: Expected to have an interface type');\n    }\n\n    node.fields && this._handleTypeFields(type, node.fields, true);\n  };\n\n  _proto5._extend = function _extend(extensions) {\n    var _this9 = this;\n\n    extensions.forEach(function (definition) {\n      if (definition.kind === 'ObjectTypeDefinition') {\n        _this9._parseObjectTypeNode(definition, true);\n      } else if (definition.kind === 'InterfaceTypeDefinition') {\n        _this9._parseInterfaceNode(definition, true);\n      } else if (definition.kind === 'ScalarTypeDefinition') {\n        _this9._parseScalarNode(definition, true);\n      } else if (definition.kind === 'EnumTypeDefinition') {\n        _this9._parseEnumNode(definition, true);\n      } else if (definition.kind === 'InterfaceTypeExtension') {\n        _this9._parseInterfaceTypeExtension(definition);\n      } else if (definition.kind === 'ObjectTypeExtension') {\n        _this9._parseObjectTypeExtension(definition);\n      } else if (definition.kind === 'DirectiveDefinition') {\n        _this9._parseDirective(definition, true\n        /* client directive */\n        );\n      } else {\n        throw createCompilerError(\"Unexpected extension kind: '\".concat(definition.kind, \"'\"), null, [definition]);\n      }\n    });\n  };\n\n  _proto5.getTypes = function getTypes() {\n    return Array.from(this._types.values());\n  };\n\n  _proto5.getTypeByName = function getTypeByName(typename) {\n    return this._types.get(typename);\n  };\n\n  _proto5.getInterfaces = function getInterfaces(type) {\n    var _this$_typeInterfaces;\n\n    return (_this$_typeInterfaces = this._typeInterfaces.get(type)) !== null && _this$_typeInterfaces !== void 0 ? _this$_typeInterfaces : [];\n  };\n\n  _proto5.getPossibleTypeSet = function getPossibleTypeSet(type) {\n    var set;\n\n    if (type instanceof InterfaceType) {\n      var _this$_interfaceImple2;\n\n      set = (_this$_interfaceImple2 = this._interfaceImplementations.get(type)) !== null && _this$_interfaceImple2 !== void 0 ? _this$_interfaceImple2 : new Set();\n    } else if (type instanceof UnionType) {\n      var _this$_unionTypes$get;\n\n      set = (_this$_unionTypes$get = this._unionTypes.get(type)) !== null && _this$_unionTypes$get !== void 0 ? _this$_unionTypes$get : new Set();\n    } else {\n      throw createCompilerError('Invalid type supplied to \"getPossibleTypeSet\"');\n    }\n\n    if (!set) {\n      throw createCompilerError(\"Unable to find possible types for \".concat(type.name));\n    }\n\n    return set;\n  };\n\n  _proto5.getFetchableFieldName = function getFetchableFieldName(type) {\n    var _this$_fetchable$get$, _this$_fetchable$get;\n\n    return (_this$_fetchable$get$ = (_this$_fetchable$get = this._fetchable.get(type)) === null || _this$_fetchable$get === void 0 ? void 0 : _this$_fetchable$get.field_name) !== null && _this$_fetchable$get$ !== void 0 ? _this$_fetchable$get$ : null;\n  };\n\n  _proto5.getQueryType = function getQueryType() {\n    return this._types.get(this._queryTypeName);\n  };\n\n  _proto5.getMutationType = function getMutationType() {\n    return this._types.get(this._mutationTypeName);\n  };\n\n  _proto5.getSubscriptionType = function getSubscriptionType() {\n    return this._types.get(this._subscriptionTypeName);\n  };\n\n  _proto5.getField = function getField(type, fieldName) {\n    var fields = this._fields.get(type);\n\n    if (fields) {\n      return fields.get(fieldName);\n    }\n  };\n\n  _proto5.getFieldMap = function getFieldMap(type) {\n    return this._fields.get(type);\n  };\n\n  _proto5.getInputField = function getInputField(type, fieldName) {\n    var inputFields = this._inputFields.get(type);\n\n    if (inputFields) {\n      return inputFields.get(fieldName);\n    }\n  };\n\n  _proto5.getInputFieldMap = function getInputFieldMap(type) {\n    return this._inputFields.get(type);\n  };\n\n  _proto5.getDirectives = function getDirectives() {\n    return Array.from(this._directives.values());\n  };\n\n  _proto5.extend = function extend(extensions) {\n    return new TypeMap(this._source, this._extensions.concat(extensions));\n  };\n\n  return TypeMap;\n}();\n\nfunction create(baseSchema, schemaExtensionDocuments, schemaExtensions) {\n  var extensions = [];\n  schemaExtensions && schemaExtensions.forEach(function (source) {\n    var doc = parse(source, {\n      noLocation: true\n    });\n    doc.definitions.forEach(function (definition) {\n      if (isSchemaDefinitionAST(definition)) {\n        extensions.push(definition);\n      }\n    });\n  });\n  schemaExtensionDocuments && schemaExtensionDocuments.forEach(function (doc) {\n    doc.definitions.forEach(function (definition) {\n      if (isSchemaDefinitionAST(definition)) {\n        extensions.push(definition);\n      }\n    });\n  });\n  return new Schema(new TypeMap(baseSchema, extensions));\n}\n\nfunction parseInputArgumentDefinitions(schema, args) {\n  return args.map(function (arg) {\n    var argType = schema.assertInputType(schema.expectTypeFromAST(arg.typeNode));\n    var defaultValue;\n    var defaultValueNode = arg.defaultValue;\n\n    if (defaultValueNode != null) {\n      var nullableType = schema.getNullableType(argType);\n      var isNullable = schema.isNonNull(argType) === false;\n\n      if (isNullable && defaultValueNode.kind === 'NullValue') {\n        defaultValue = null;\n      } else {\n        if (nullableType instanceof ScalarType || nullableType instanceof EnumType) {\n          defaultValue = schema.parseLiteral(nullableType, defaultValueNode);\n        } else if (nullableType instanceof List && defaultValueNode.kind === 'ListValue' || nullableType instanceof InputObjectType && defaultValueNode.kind === 'ObjectValue') {\n          defaultValue = valueFromASTUntyped(defaultValueNode);\n        }\n      }\n\n      if (defaultValue === undefined) {\n        throw createCompilerError(\"parseInputArgumentDefinitions: Unexpected default value: \".concat(String(defaultValueNode), \". Expected to have a value of type \").concat(String(nullableType), \".\"));\n      }\n    }\n\n    return {\n      name: arg.name,\n      type: argType,\n      defaultValue: defaultValue\n    };\n  });\n}\n\nfunction parseInputArgumentDefinitionsMap(schema, args) {\n  return new Map(parseInputArgumentDefinitions(schema, args).map(function (arg) {\n    return [arg.name, arg];\n  }));\n}\n\nfunction isDefaultScalar(name) {\n  return new Set(['ID', 'String', 'Boolean', 'Int', 'Float']).has(name);\n}\n\nmodule.exports = {\n  create: create\n};"]},"metadata":{},"sourceType":"script"}