{"ast":null,"code":"import { asArray, debugLog, printSchemaWithDirectives, isDocumentString, parseGraphQLSDL, fixSchemaAst, compareStrings } from '@graphql-tools/utils';\nimport { cwd } from 'process';\nimport { isSchema, parse, Kind, Source, print } from 'graphql';\nimport isGlob from 'is-glob';\nimport pLimit from 'p-limit';\nimport importFrom from 'import-from';\nimport unixify from 'unixify';\nimport globby, { sync } from 'globby';\nimport { printWithComments, resetComments, mergeSchemasAsync, mergeSchemas } from '@graphql-tools/merge';\n\nfunction normalizePointers(unnormalizedPointerOrPointers) {\n  return asArray(unnormalizedPointerOrPointers).reduce((normalizedPointers, unnormalizedPointer) => {\n    if (typeof unnormalizedPointer === 'string') {\n      normalizedPointers[unnormalizedPointer] = {};\n    } else if (typeof unnormalizedPointer === 'object') {\n      Object.assign(normalizedPointers, unnormalizedPointer);\n    } else {\n      throw new Error(`Invalid pointer ${unnormalizedPointer}`);\n    }\n\n    return normalizedPointers;\n  }, {});\n}\n\nfunction applyDefaultOptions(options) {\n  options.cache = options.cache || {};\n  options.cwd = options.cwd || cwd();\n  options.sort = 'sort' in options ? options.sort : true;\n}\n\nasync function loadFile(pointer, options) {\n  const cached = useCache({\n    pointer,\n    options\n  });\n\n  if (cached) {\n    return cached;\n  }\n\n  for await (const loader of options.loaders) {\n    try {\n      const canLoad = await loader.canLoad(pointer, options);\n\n      if (canLoad) {\n        return await loader.load(pointer, options);\n      }\n    } catch (error) {\n      debugLog(`Failed to find any GraphQL type definitions in: ${pointer} - ${error.message}`);\n      throw error;\n    }\n  }\n\n  return undefined;\n}\n\nfunction loadFileSync(pointer, options) {\n  const cached = useCache({\n    pointer,\n    options\n  });\n\n  if (cached) {\n    return cached;\n  }\n\n  for (const loader of options.loaders) {\n    try {\n      const canLoad = loader.canLoadSync && loader.loadSync && loader.canLoadSync(pointer, options);\n\n      if (canLoad) {\n        return loader.loadSync(pointer, options);\n      }\n    } catch (error) {\n      debugLog(`Failed to find any GraphQL type definitions in: ${pointer} - ${error.message}`);\n      throw error;\n    }\n  }\n\n  return undefined;\n}\n\nfunction useCache({\n  pointer,\n  options\n}) {\n  if (options['cache']) {\n    return options['cache'][pointer];\n  }\n}\n/**\n * Converts a string to 32bit integer\n */\n\n\nfunction stringToHash(str) {\n  let hash = 0;\n\n  if (str.length === 0) {\n    return hash;\n  }\n\n  let char;\n\n  for (let i = 0; i < str.length; i++) {\n    char = str.charCodeAt(i); // tslint:disable-next-line: no-bitwise\n\n    hash = (hash << 5) - hash + char; // tslint:disable-next-line: no-bitwise\n\n    hash = hash & hash;\n  }\n\n  return hash;\n}\n\nfunction useStack(...fns) {\n  return input => {\n    function createNext(i) {\n      if (i >= fns.length) {\n        return () => {};\n      }\n\n      return function next() {\n        fns[i](input, createNext(i + 1));\n      };\n    }\n\n    fns[0](input, createNext(1));\n  };\n}\n\nfunction useLimit(concurrency) {\n  return pLimit(concurrency);\n}\n\nfunction getCustomLoaderByPath(path, cwd) {\n  try {\n    const requiredModule = importFrom(cwd, path);\n\n    if (requiredModule) {\n      if (requiredModule.default && typeof requiredModule.default === 'function') {\n        return requiredModule.default;\n      }\n\n      if (typeof requiredModule === 'function') {\n        return requiredModule;\n      }\n    }\n  } catch (e) {}\n\n  return null;\n}\n\nasync function useCustomLoader(loaderPointer, cwd) {\n  let loader;\n\n  if (typeof loaderPointer === 'string') {\n    loader = await getCustomLoaderByPath(loaderPointer, cwd);\n  } else if (typeof loaderPointer === 'function') {\n    loader = loaderPointer;\n  }\n\n  if (typeof loader !== 'function') {\n    throw new Error(`Failed to load custom loader: ${loaderPointer}`);\n  }\n\n  return loader;\n}\n\nfunction useCustomLoaderSync(loaderPointer, cwd) {\n  let loader;\n\n  if (typeof loaderPointer === 'string') {\n    loader = getCustomLoaderByPath(loaderPointer, cwd);\n  } else if (typeof loaderPointer === 'function') {\n    loader = loaderPointer;\n  }\n\n  if (typeof loader !== 'function') {\n    throw new Error(`Failed to load custom loader: ${loaderPointer}`);\n  }\n\n  return loader;\n}\n\nfunction useQueue(options) {\n  const queue = [];\n  const limit = (options === null || options === void 0 ? void 0 : options.concurrency) ? pLimit(options.concurrency) : async fn => fn();\n  return {\n    add(fn) {\n      queue.push(() => limit(fn));\n    },\n\n    runAll() {\n      return Promise.all(queue.map(fn => fn()));\n    }\n\n  };\n}\n\nfunction useSyncQueue() {\n  const queue = [];\n  return {\n    add(fn) {\n      queue.push(fn);\n    },\n\n    runAll() {\n      queue.forEach(fn => fn());\n    }\n\n  };\n}\n\nconst CONCURRENCY_LIMIT = 50;\n\nasync function collectSources({\n  pointerOptionMap,\n  options\n}) {\n  var _a;\n\n  const sources = [];\n  const globs = [];\n  const globOptions = {};\n  const queue = useQueue({\n    concurrency: CONCURRENCY_LIMIT\n  });\n  const {\n    addSource,\n    addGlob,\n    collect\n  } = createHelpers({\n    sources,\n    globs,\n    options,\n    globOptions,\n    stack: [collectDocumentString, collectGlob, collectCustomLoader, collectFallback]\n  });\n\n  for (const pointer in pointerOptionMap) {\n    const pointerOptions = { ...((_a = pointerOptionMap[pointer]) !== null && _a !== void 0 ? _a : {}),\n      unixify\n    };\n    collect({\n      pointer,\n      pointerOptions,\n      pointerOptionMap,\n      options,\n      addSource,\n      addGlob,\n      queue: queue.add\n    });\n  }\n\n  if (globs.length) {\n    includeIgnored({\n      options,\n      globs\n    });\n    const paths = await globby(globs, createGlobbyOptions(options));\n    collectSourcesFromGlobals({\n      filepaths: paths,\n      options,\n      globOptions,\n      pointerOptionMap,\n      addSource,\n      queue: queue.add\n    });\n  }\n\n  await queue.runAll();\n  return sources;\n}\n\nfunction collectSourcesSync({\n  pointerOptionMap,\n  options\n}) {\n  var _a;\n\n  const sources = [];\n  const globs = [];\n  const globOptions = {};\n  const queue = useSyncQueue();\n  const {\n    addSource,\n    addGlob,\n    collect\n  } = createHelpers({\n    sources,\n    globs,\n    options,\n    globOptions,\n    stack: [collectDocumentString, collectGlob, collectCustomLoaderSync, collectFallbackSync]\n  });\n\n  for (const pointer in pointerOptionMap) {\n    const pointerOptions = { ...((_a = pointerOptionMap[pointer]) !== null && _a !== void 0 ? _a : {}),\n      unixify\n    };\n    collect({\n      pointer,\n      pointerOptions,\n      pointerOptionMap,\n      options,\n      addSource,\n      addGlob,\n      queue: queue.add\n    });\n  }\n\n  if (globs.length) {\n    includeIgnored({\n      options,\n      globs\n    });\n    const paths = sync(globs, createGlobbyOptions(options));\n    collectSourcesFromGlobalsSync({\n      filepaths: paths,\n      options,\n      globOptions,\n      pointerOptionMap,\n      addSource,\n      queue: queue.add\n    });\n  }\n\n  queue.runAll();\n  return sources;\n} //\n\n\nfunction createHelpers({\n  sources,\n  globs,\n  options,\n  globOptions,\n  stack\n}) {\n  const addSource = ({\n    pointer,\n    source,\n    noCache\n  }) => {\n    sources.push(source);\n\n    if (!noCache) {\n      options.cache[pointer] = source;\n    }\n  };\n\n  const collect = useStack(...stack);\n\n  const addGlob = ({\n    pointerOptions,\n    pointer\n  }) => {\n    globs.push(pointer);\n    Object.assign(globOptions, pointerOptions);\n  };\n\n  return {\n    addSource,\n    collect,\n    addGlob\n  };\n}\n\nfunction includeIgnored({\n  options,\n  globs\n}) {\n  if (options.ignore) {\n    const ignoreList = asArray(options.ignore).map(g => `!(${g})`).map(unixify);\n\n    if (ignoreList.length > 0) {\n      globs.push(...ignoreList);\n    }\n  }\n}\n\nfunction createGlobbyOptions(options) {\n  return {\n    absolute: true,\n    ...options,\n    ignore: []\n  };\n}\n\nfunction collectSourcesFromGlobals({\n  filepaths,\n  options,\n  globOptions,\n  pointerOptionMap,\n  addSource,\n  queue\n}) {\n  const collectFromGlobs = useStack(collectCustomLoader, collectFallback);\n\n  for (let i = 0; i < filepaths.length; i++) {\n    const pointer = filepaths[i];\n    collectFromGlobs({\n      pointer,\n      pointerOptions: globOptions,\n      pointerOptionMap,\n      options,\n      addSource,\n      addGlob: () => {\n        throw new Error(`I don't accept any new globs!`);\n      },\n      queue\n    });\n  }\n}\n\nfunction collectSourcesFromGlobalsSync({\n  filepaths,\n  options,\n  globOptions,\n  pointerOptionMap,\n  addSource,\n  queue\n}) {\n  const collectFromGlobs = useStack(collectCustomLoaderSync, collectFallbackSync);\n\n  for (let i = 0; i < filepaths.length; i++) {\n    const pointer = filepaths[i];\n    collectFromGlobs({\n      pointer,\n      pointerOptions: globOptions,\n      pointerOptionMap,\n      options,\n      addSource,\n      addGlob: () => {\n        throw new Error(`I don't accept any new globs!`);\n      },\n      queue\n    });\n  }\n}\n\nfunction addResultOfCustomLoader({\n  pointer,\n  result,\n  addSource\n}) {\n  if (isSchema(result)) {\n    addSource({\n      source: {\n        location: pointer,\n        schema: result,\n        document: parse(printSchemaWithDirectives(result))\n      },\n      pointer,\n      noCache: true\n    });\n  } else if (result.kind && result.kind === Kind.DOCUMENT) {\n    addSource({\n      source: {\n        document: result,\n        location: pointer\n      },\n      pointer\n    });\n  } else if (result.document) {\n    addSource({\n      source: {\n        location: pointer,\n        ...result\n      },\n      pointer\n    });\n  }\n}\n\nfunction collectDocumentString({\n  pointer,\n  pointerOptions,\n  options,\n  addSource,\n  queue\n}, next) {\n  if (isDocumentString(pointer)) {\n    return queue(() => {\n      const source = parseGraphQLSDL(`${stringToHash(pointer)}.graphql`, pointer, { ...options,\n        ...pointerOptions\n      });\n      addSource({\n        source,\n        pointer\n      });\n    });\n  }\n\n  next();\n}\n\nfunction collectGlob({\n  pointer,\n  pointerOptions,\n  addGlob\n}, next) {\n  if (isGlob(pointerOptions.unixify(pointer))) {\n    return addGlob({\n      pointer: pointerOptions.unixify(pointer),\n      pointerOptions\n    });\n  }\n\n  next();\n}\n\nfunction collectCustomLoader({\n  pointer,\n  pointerOptions,\n  queue,\n  addSource,\n  options,\n  pointerOptionMap\n}, next) {\n  if (pointerOptions.loader) {\n    return queue(async () => {\n      const loader = await useCustomLoader(pointerOptions.loader, options.cwd);\n      const result = await loader(pointer, { ...options,\n        ...pointerOptions\n      }, pointerOptionMap);\n\n      if (!result) {\n        return;\n      }\n\n      addResultOfCustomLoader({\n        pointer,\n        result,\n        addSource\n      });\n    });\n  }\n\n  next();\n}\n\nfunction collectCustomLoaderSync({\n  pointer,\n  pointerOptions,\n  queue,\n  addSource,\n  options,\n  pointerOptionMap\n}, next) {\n  if (pointerOptions.loader) {\n    return queue(() => {\n      const loader = useCustomLoaderSync(pointerOptions.loader, options.cwd);\n      const result = loader(pointer, { ...options,\n        ...pointerOptions\n      }, pointerOptionMap);\n\n      if (result) {\n        addResultOfCustomLoader({\n          pointer,\n          result,\n          addSource\n        });\n      }\n    });\n  }\n\n  next();\n}\n\nfunction collectFallback({\n  queue,\n  pointer,\n  options,\n  pointerOptions,\n  addSource\n}) {\n  return queue(async () => {\n    const source = await loadFile(pointer, { ...options,\n      ...pointerOptions\n    });\n\n    if (source) {\n      addSource({\n        source,\n        pointer\n      });\n    }\n  });\n}\n\nfunction collectFallbackSync({\n  queue,\n  pointer,\n  options,\n  pointerOptions,\n  addSource\n}) {\n  return queue(() => {\n    const source = loadFileSync(pointer, { ...options,\n      ...pointerOptions\n    });\n\n    if (source) {\n      addSource({\n        source,\n        pointer\n      });\n    }\n  });\n}\n/**\n * @internal\n */\n\n\nconst filterKind = (content, filterKinds) => {\n  if (content && content.definitions && content.definitions.length && filterKinds && filterKinds.length > 0) {\n    const invalidDefinitions = [];\n    const validDefinitions = [];\n\n    for (const definitionNode of content.definitions) {\n      if (filterKinds.includes(definitionNode.kind)) {\n        invalidDefinitions.push(definitionNode);\n      } else {\n        validDefinitions.push(definitionNode);\n      }\n    }\n\n    if (invalidDefinitions.length > 0) {\n      invalidDefinitions.forEach(d => {\n        debugLog(`Filtered document of kind ${d.kind} due to filter policy (${filterKinds.join(', ')})`);\n      });\n    }\n\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: validDefinitions\n    };\n  }\n\n  return content;\n};\n\nfunction parseSource({\n  partialSource,\n  options,\n  globOptions,\n  pointerOptionMap,\n  addValidSource\n}) {\n  if (partialSource) {\n    const input = prepareInput({\n      source: partialSource,\n      options,\n      globOptions,\n      pointerOptionMap\n    });\n    parseSchema(input);\n    parseRawSDL(input);\n\n    if (input.source.document) {\n      useKindsFilter(input);\n      useComments(input);\n      collectValidSources(input, addValidSource);\n    }\n  }\n} //\n\n\nfunction prepareInput({\n  source,\n  options,\n  globOptions,\n  pointerOptionMap\n}) {\n  const specificOptions = { ...options,\n    ...(source.location in pointerOptionMap ? globOptions : pointerOptionMap[source.location])\n  };\n  return {\n    source: { ...source\n    },\n    options: specificOptions\n  };\n}\n\nfunction parseSchema(input) {\n  if (input.source.schema) {\n    input.source.schema = fixSchemaAst(input.source.schema, input.options);\n    input.source.rawSDL = printSchemaWithDirectives(input.source.schema, input.options);\n  }\n}\n\nfunction parseRawSDL(input) {\n  if (input.source.rawSDL) {\n    input.source.document = parseGraphQLSDL(input.source.location, input.source.rawSDL, input.options).document;\n  }\n}\n\nfunction useKindsFilter(input) {\n  if (input.options.filterKinds) {\n    input.source.document = filterKind(input.source.document, input.options.filterKinds);\n  }\n}\n\nfunction useComments(input) {\n  if (!input.source.rawSDL) {\n    input.source.rawSDL = printWithComments(input.source.document);\n    resetComments();\n  }\n}\n\nfunction collectValidSources(input, addValidSource) {\n  if (input.source.document.definitions && input.source.document.definitions.length > 0) {\n    addValidSource(input.source);\n  }\n}\n\nconst CONCURRENCY_LIMIT$1 = 100;\n/**\n * Asynchronously loads any GraphQL documents (i.e. executable documents like\n * operations and fragments as well as type system definitions) from the\n * provided pointers.\n * @param pointerOrPointers Pointers to the sources to load the documents from\n * @param options Additional options\n */\n\nasync function loadTypedefs(pointerOrPointers, options) {\n  const pointerOptionMap = normalizePointers(pointerOrPointers);\n  const globOptions = {};\n  applyDefaultOptions(options);\n  const sources = await collectSources({\n    pointerOptionMap,\n    options\n  });\n  const validSources = []; // If we have few k of files it may be an issue\n\n  const limit = useLimit(CONCURRENCY_LIMIT$1);\n  await Promise.all(sources.map(partialSource => limit(() => parseSource({\n    partialSource,\n    options,\n    globOptions,\n    pointerOptionMap,\n\n    addValidSource(source) {\n      validSources.push(source);\n    }\n\n  }))));\n  return prepareResult({\n    options,\n    pointerOptionMap,\n    validSources\n  });\n}\n/**\n * Synchronously loads any GraphQL documents (i.e. executable documents like\n * operations and fragments as well as type system definitions) from the\n * provided pointers.\n * @param pointerOrPointers Pointers to the sources to load the documents from\n * @param options Additional options\n */\n\n\nfunction loadTypedefsSync(pointerOrPointers, options) {\n  const pointerOptionMap = normalizePointers(pointerOrPointers);\n  const globOptions = {};\n  applyDefaultOptions(options);\n  const sources = collectSourcesSync({\n    pointerOptionMap,\n    options\n  });\n  const validSources = [];\n  sources.forEach(partialSource => {\n    parseSource({\n      partialSource,\n      options,\n      globOptions,\n      pointerOptionMap,\n\n      addValidSource(source) {\n        validSources.push(source);\n      }\n\n    });\n  });\n  return prepareResult({\n    options,\n    pointerOptionMap,\n    validSources\n  });\n} //\n\n\nfunction prepareResult({\n  options,\n  pointerOptionMap,\n  validSources\n}) {\n  const pointerList = Object.keys(pointerOptionMap);\n\n  if (pointerList.length > 0 && validSources.length === 0) {\n    throw new Error(`\n      Unable to find any GraphQL type definitions for the following pointers:\n        ${pointerList.map(p => `\n          - ${p}\n          `)}`);\n  }\n\n  return options.sort ? validSources.sort((left, right) => compareStrings(left.location, right.location)) : validSources;\n}\n/**\n * Kinds of AST nodes that are included in executable documents\n */\n\n\nconst OPERATION_KINDS = [Kind.OPERATION_DEFINITION, Kind.FRAGMENT_DEFINITION];\n/**\n * Kinds of AST nodes that are included in type system definition documents\n */\n\nconst NON_OPERATION_KINDS = Object.keys(Kind).reduce((prev, v) => [...prev, Kind[v]], []).filter(v => !OPERATION_KINDS.includes(v));\n/**\n * Asynchronously loads executable documents (i.e. operations and fragments) from\n * the provided pointers. The pointers may be individual files or a glob pattern.\n * The files themselves may be `.graphql` files or `.js` and `.ts` (in which\n * case they will be parsed using graphql-tag-pluck).\n * @param pointerOrPointers Pointers to the files to load the documents from\n * @param options Additional options\n */\n\nfunction loadDocuments(pointerOrPointers, options) {\n  return loadTypedefs(pointerOrPointers, {\n    noRequire: true,\n    filterKinds: NON_OPERATION_KINDS,\n    ...options\n  });\n}\n/**\n * Synchronously loads executable documents (i.e. operations and fragments) from\n * the provided pointers. The pointers may be individual files or a glob pattern.\n * The files themselves may be `.graphql` files or `.js` and `.ts` (in which\n * case they will be parsed using graphql-tag-pluck).\n * @param pointerOrPointers Pointers to the files to load the documents from\n * @param options Additional options\n */\n\n\nfunction loadDocumentsSync(pointerOrPointers, options) {\n  return loadTypedefsSync(pointerOrPointers, {\n    noRequire: true,\n    filterKinds: NON_OPERATION_KINDS,\n    ...options\n  });\n}\n/**\n * Asynchronously loads a schema from the provided pointers.\n * @param schemaPointers Pointers to the sources to load the schema from\n * @param options Additional options\n */\n\n\nasync function loadSchema(schemaPointers, options) {\n  const sources = await loadTypedefs(schemaPointers, {\n    filterKinds: OPERATION_KINDS,\n    ...options\n  });\n  const {\n    schemas,\n    typeDefs\n  } = collectSchemasAndTypeDefs(sources);\n  const mergeSchemasOptions = {\n    schemas,\n    typeDefs,\n    ...options\n  };\n  const schema = await mergeSchemasAsync(mergeSchemasOptions);\n\n  if (options === null || options === void 0 ? void 0 : options.includeSources) {\n    includeSources(schema, sources);\n  }\n\n  return schema;\n}\n/**\n * Synchronously loads a schema from the provided pointers.\n * @param schemaPointers Pointers to the sources to load the schema from\n * @param options Additional options\n */\n\n\nfunction loadSchemaSync(schemaPointers, options) {\n  const sources = loadTypedefsSync(schemaPointers, {\n    filterKinds: OPERATION_KINDS,\n    ...options\n  });\n  const {\n    schemas,\n    typeDefs\n  } = collectSchemasAndTypeDefs(sources);\n  const mergeSchemasOptions = {\n    schemas,\n    typeDefs,\n    ...options\n  };\n  const schema = mergeSchemas(mergeSchemasOptions);\n\n  if (options === null || options === void 0 ? void 0 : options.includeSources) {\n    includeSources(schema, sources);\n  }\n\n  return schema;\n}\n\nfunction includeSources(schema, sources) {\n  schema.extensions = { ...schema.extensions,\n    sources: sources.filter(source => source.rawSDL || source.document).map(source => new Source(source.rawSDL || print(source.document), source.location))\n  };\n}\n\nfunction collectSchemasAndTypeDefs(sources) {\n  const schemas = [];\n  const typeDefs = [];\n  sources.forEach(source => {\n    if (source.schema) {\n      schemas.push(source.schema);\n    } else {\n      typeDefs.push(source.document);\n    }\n  });\n  return {\n    schemas,\n    typeDefs\n  };\n}\n\nexport { NON_OPERATION_KINDS, OPERATION_KINDS, filterKind, loadDocuments, loadDocumentsSync, loadSchema, loadSchemaSync, loadTypedefs, loadTypedefsSync };","map":{"version":3,"sources":["../../../dist/load/src/utils/pointers.js","../../../dist/load/src/load-typedefs/options.js","../../../dist/load/src/load-typedefs/load-file.js","../../../dist/load/src/utils/helpers.js","../../../dist/load/src/utils/custom-loader.js","../../../dist/load/src/utils/queue.js","../../../dist/load/src/load-typedefs/collect-sources.js","../../../dist/load/src/filter-document-kind.js","../../../dist/load/src/load-typedefs/parse.js","../../../dist/load/src/load-typedefs.js","../../../dist/load/src/documents.js","../../../dist/load/src/schema.js"],"names":["globbySync","CONCURRENCY_LIMIT","GraphQLSource"],"mappings":"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","sourcesContent":["import { asArray } from '@graphql-tools/utils';\nexport function normalizePointers(unnormalizedPointerOrPointers) {\n    return asArray(unnormalizedPointerOrPointers).reduce((normalizedPointers, unnormalizedPointer) => {\n        if (typeof unnormalizedPointer === 'string') {\n            normalizedPointers[unnormalizedPointer] = {};\n        }\n        else if (typeof unnormalizedPointer === 'object') {\n            Object.assign(normalizedPointers, unnormalizedPointer);\n        }\n        else {\n            throw new Error(`Invalid pointer ${unnormalizedPointer}`);\n        }\n        return normalizedPointers;\n    }, {});\n}\n//# sourceMappingURL=pointers.js.map","import { cwd } from 'process';\nexport function applyDefaultOptions(options) {\n    options.cache = options.cache || {};\n    options.cwd = options.cwd || cwd();\n    options.sort = 'sort' in options ? options.sort : true;\n}\n//# sourceMappingURL=options.js.map","import { debugLog } from '@graphql-tools/utils';\nexport async function loadFile(pointer, options) {\n    const cached = useCache({ pointer, options });\n    if (cached) {\n        return cached;\n    }\n    for await (const loader of options.loaders) {\n        try {\n            const canLoad = await loader.canLoad(pointer, options);\n            if (canLoad) {\n                return await loader.load(pointer, options);\n            }\n        }\n        catch (error) {\n            debugLog(`Failed to find any GraphQL type definitions in: ${pointer} - ${error.message}`);\n            throw error;\n        }\n    }\n    return undefined;\n}\nexport function loadFileSync(pointer, options) {\n    const cached = useCache({ pointer, options });\n    if (cached) {\n        return cached;\n    }\n    for (const loader of options.loaders) {\n        try {\n            const canLoad = loader.canLoadSync && loader.loadSync && loader.canLoadSync(pointer, options);\n            if (canLoad) {\n                return loader.loadSync(pointer, options);\n            }\n        }\n        catch (error) {\n            debugLog(`Failed to find any GraphQL type definitions in: ${pointer} - ${error.message}`);\n            throw error;\n        }\n    }\n    return undefined;\n}\nfunction useCache({ pointer, options }) {\n    if (options['cache']) {\n        return options['cache'][pointer];\n    }\n}\n//# sourceMappingURL=load-file.js.map","import pLimit from 'p-limit';\n/**\n * Converts a string to 32bit integer\n */\nexport function stringToHash(str) {\n    let hash = 0;\n    if (str.length === 0) {\n        return hash;\n    }\n    let char;\n    for (let i = 0; i < str.length; i++) {\n        char = str.charCodeAt(i);\n        // tslint:disable-next-line: no-bitwise\n        hash = (hash << 5) - hash + char;\n        // tslint:disable-next-line: no-bitwise\n        hash = hash & hash;\n    }\n    return hash;\n}\nexport function useStack(...fns) {\n    return (input) => {\n        function createNext(i) {\n            if (i >= fns.length) {\n                return () => { };\n            }\n            return function next() {\n                fns[i](input, createNext(i + 1));\n            };\n        }\n        fns[0](input, createNext(1));\n    };\n}\nexport function useLimit(concurrency) {\n    return pLimit(concurrency);\n}\n//# sourceMappingURL=helpers.js.map","import importFrom from 'import-from';\nexport function getCustomLoaderByPath(path, cwd) {\n    try {\n        const requiredModule = importFrom(cwd, path);\n        if (requiredModule) {\n            if (requiredModule.default && typeof requiredModule.default === 'function') {\n                return requiredModule.default;\n            }\n            if (typeof requiredModule === 'function') {\n                return requiredModule;\n            }\n        }\n    }\n    catch (e) { }\n    return null;\n}\nexport async function useCustomLoader(loaderPointer, cwd) {\n    let loader;\n    if (typeof loaderPointer === 'string') {\n        loader = await getCustomLoaderByPath(loaderPointer, cwd);\n    }\n    else if (typeof loaderPointer === 'function') {\n        loader = loaderPointer;\n    }\n    if (typeof loader !== 'function') {\n        throw new Error(`Failed to load custom loader: ${loaderPointer}`);\n    }\n    return loader;\n}\nexport function useCustomLoaderSync(loaderPointer, cwd) {\n    let loader;\n    if (typeof loaderPointer === 'string') {\n        loader = getCustomLoaderByPath(loaderPointer, cwd);\n    }\n    else if (typeof loaderPointer === 'function') {\n        loader = loaderPointer;\n    }\n    if (typeof loader !== 'function') {\n        throw new Error(`Failed to load custom loader: ${loaderPointer}`);\n    }\n    return loader;\n}\n//# sourceMappingURL=custom-loader.js.map","import pLimit from 'p-limit';\nexport function useQueue(options) {\n    const queue = [];\n    const limit = (options === null || options === void 0 ? void 0 : options.concurrency) ? pLimit(options.concurrency) : async (fn) => fn();\n    return {\n        add(fn) {\n            queue.push(() => limit(fn));\n        },\n        runAll() {\n            return Promise.all(queue.map(fn => fn()));\n        },\n    };\n}\nexport function useSyncQueue() {\n    const queue = [];\n    return {\n        add(fn) {\n            queue.push(fn);\n        },\n        runAll() {\n            queue.forEach(fn => fn());\n        },\n    };\n}\n//# sourceMappingURL=queue.js.map","import { isDocumentString, parseGraphQLSDL, asArray, printSchemaWithDirectives } from '@graphql-tools/utils';\nimport { isSchema, Kind, parse } from 'graphql';\nimport isGlob from 'is-glob';\nimport { loadFile, loadFileSync } from './load-file';\nimport { stringToHash, useStack } from '../utils/helpers';\nimport { useCustomLoader, useCustomLoaderSync } from '../utils/custom-loader';\nimport { useQueue, useSyncQueue } from '../utils/queue';\nimport unixify from 'unixify';\nimport globby, { sync as globbySync } from 'globby';\nconst CONCURRENCY_LIMIT = 50;\nexport async function collectSources({ pointerOptionMap, options, }) {\n    var _a;\n    const sources = [];\n    const globs = [];\n    const globOptions = {};\n    const queue = useQueue({ concurrency: CONCURRENCY_LIMIT });\n    const { addSource, addGlob, collect } = createHelpers({\n        sources,\n        globs,\n        options,\n        globOptions,\n        stack: [collectDocumentString, collectGlob, collectCustomLoader, collectFallback],\n    });\n    for (const pointer in pointerOptionMap) {\n        const pointerOptions = {\n            ...((_a = pointerOptionMap[pointer]) !== null && _a !== void 0 ? _a : {}),\n            unixify,\n        };\n        collect({\n            pointer,\n            pointerOptions,\n            pointerOptionMap,\n            options,\n            addSource,\n            addGlob,\n            queue: queue.add,\n        });\n    }\n    if (globs.length) {\n        includeIgnored({\n            options,\n            globs,\n        });\n        const paths = await globby(globs, createGlobbyOptions(options));\n        collectSourcesFromGlobals({\n            filepaths: paths,\n            options,\n            globOptions,\n            pointerOptionMap,\n            addSource,\n            queue: queue.add,\n        });\n    }\n    await queue.runAll();\n    return sources;\n}\nexport function collectSourcesSync({ pointerOptionMap, options, }) {\n    var _a;\n    const sources = [];\n    const globs = [];\n    const globOptions = {};\n    const queue = useSyncQueue();\n    const { addSource, addGlob, collect } = createHelpers({\n        sources,\n        globs,\n        options,\n        globOptions,\n        stack: [collectDocumentString, collectGlob, collectCustomLoaderSync, collectFallbackSync],\n    });\n    for (const pointer in pointerOptionMap) {\n        const pointerOptions = {\n            ...((_a = pointerOptionMap[pointer]) !== null && _a !== void 0 ? _a : {}),\n            unixify,\n        };\n        collect({\n            pointer,\n            pointerOptions,\n            pointerOptionMap,\n            options,\n            addSource,\n            addGlob,\n            queue: queue.add,\n        });\n    }\n    if (globs.length) {\n        includeIgnored({\n            options,\n            globs,\n        });\n        const paths = globbySync(globs, createGlobbyOptions(options));\n        collectSourcesFromGlobalsSync({\n            filepaths: paths,\n            options,\n            globOptions,\n            pointerOptionMap,\n            addSource,\n            queue: queue.add,\n        });\n    }\n    queue.runAll();\n    return sources;\n}\n//\nfunction createHelpers({ sources, globs, options, globOptions, stack, }) {\n    const addSource = ({ pointer, source, noCache, }) => {\n        sources.push(source);\n        if (!noCache) {\n            options.cache[pointer] = source;\n        }\n    };\n    const collect = useStack(...stack);\n    const addGlob = ({ pointerOptions, pointer }) => {\n        globs.push(pointer);\n        Object.assign(globOptions, pointerOptions);\n    };\n    return {\n        addSource,\n        collect,\n        addGlob,\n    };\n}\nfunction includeIgnored({ options, globs }) {\n    if (options.ignore) {\n        const ignoreList = asArray(options.ignore)\n            .map(g => `!(${g})`)\n            .map(unixify);\n        if (ignoreList.length > 0) {\n            globs.push(...ignoreList);\n        }\n    }\n}\nfunction createGlobbyOptions(options) {\n    return { absolute: true, ...options, ignore: [] };\n}\nfunction collectSourcesFromGlobals({ filepaths, options, globOptions, pointerOptionMap, addSource, queue, }) {\n    const collectFromGlobs = useStack(collectCustomLoader, collectFallback);\n    for (let i = 0; i < filepaths.length; i++) {\n        const pointer = filepaths[i];\n        collectFromGlobs({\n            pointer,\n            pointerOptions: globOptions,\n            pointerOptionMap,\n            options,\n            addSource,\n            addGlob: () => {\n                throw new Error(`I don't accept any new globs!`);\n            },\n            queue,\n        });\n    }\n}\nfunction collectSourcesFromGlobalsSync({ filepaths, options, globOptions, pointerOptionMap, addSource, queue, }) {\n    const collectFromGlobs = useStack(collectCustomLoaderSync, collectFallbackSync);\n    for (let i = 0; i < filepaths.length; i++) {\n        const pointer = filepaths[i];\n        collectFromGlobs({\n            pointer,\n            pointerOptions: globOptions,\n            pointerOptionMap,\n            options,\n            addSource,\n            addGlob: () => {\n                throw new Error(`I don't accept any new globs!`);\n            },\n            queue,\n        });\n    }\n}\nfunction addResultOfCustomLoader({ pointer, result, addSource, }) {\n    if (isSchema(result)) {\n        addSource({\n            source: {\n                location: pointer,\n                schema: result,\n                document: parse(printSchemaWithDirectives(result)),\n            },\n            pointer,\n            noCache: true,\n        });\n    }\n    else if (result.kind && result.kind === Kind.DOCUMENT) {\n        addSource({\n            source: {\n                document: result,\n                location: pointer,\n            },\n            pointer,\n        });\n    }\n    else if (result.document) {\n        addSource({\n            source: {\n                location: pointer,\n                ...result,\n            },\n            pointer,\n        });\n    }\n}\nfunction collectDocumentString({ pointer, pointerOptions, options, addSource, queue }, next) {\n    if (isDocumentString(pointer)) {\n        return queue(() => {\n            const source = parseGraphQLSDL(`${stringToHash(pointer)}.graphql`, pointer, {\n                ...options,\n                ...pointerOptions,\n            });\n            addSource({\n                source,\n                pointer,\n            });\n        });\n    }\n    next();\n}\nfunction collectGlob({ pointer, pointerOptions, addGlob }, next) {\n    if (isGlob(pointerOptions.unixify(pointer))) {\n        return addGlob({\n            pointer: pointerOptions.unixify(pointer),\n            pointerOptions,\n        });\n    }\n    next();\n}\nfunction collectCustomLoader({ pointer, pointerOptions, queue, addSource, options, pointerOptionMap }, next) {\n    if (pointerOptions.loader) {\n        return queue(async () => {\n            const loader = await useCustomLoader(pointerOptions.loader, options.cwd);\n            const result = await loader(pointer, { ...options, ...pointerOptions }, pointerOptionMap);\n            if (!result) {\n                return;\n            }\n            addResultOfCustomLoader({ pointer, result, addSource });\n        });\n    }\n    next();\n}\nfunction collectCustomLoaderSync({ pointer, pointerOptions, queue, addSource, options, pointerOptionMap }, next) {\n    if (pointerOptions.loader) {\n        return queue(() => {\n            const loader = useCustomLoaderSync(pointerOptions.loader, options.cwd);\n            const result = loader(pointer, { ...options, ...pointerOptions }, pointerOptionMap);\n            if (result) {\n                addResultOfCustomLoader({ pointer, result, addSource });\n            }\n        });\n    }\n    next();\n}\nfunction collectFallback({ queue, pointer, options, pointerOptions, addSource }) {\n    return queue(async () => {\n        const source = await loadFile(pointer, {\n            ...options,\n            ...pointerOptions,\n        });\n        if (source) {\n            addSource({ source, pointer });\n        }\n    });\n}\nfunction collectFallbackSync({ queue, pointer, options, pointerOptions, addSource }) {\n    return queue(() => {\n        const source = loadFileSync(pointer, {\n            ...options,\n            ...pointerOptions,\n        });\n        if (source) {\n            addSource({ source, pointer });\n        }\n    });\n}\n//# sourceMappingURL=collect-sources.js.map","import { debugLog } from '@graphql-tools/utils';\nimport { Kind } from 'graphql';\n/**\n * @internal\n */\nexport const filterKind = (content, filterKinds) => {\n    if (content && content.definitions && content.definitions.length && filterKinds && filterKinds.length > 0) {\n        const invalidDefinitions = [];\n        const validDefinitions = [];\n        for (const definitionNode of content.definitions) {\n            if (filterKinds.includes(definitionNode.kind)) {\n                invalidDefinitions.push(definitionNode);\n            }\n            else {\n                validDefinitions.push(definitionNode);\n            }\n        }\n        if (invalidDefinitions.length > 0) {\n            invalidDefinitions.forEach(d => {\n                debugLog(`Filtered document of kind ${d.kind} due to filter policy (${filterKinds.join(', ')})`);\n            });\n        }\n        return {\n            kind: Kind.DOCUMENT,\n            definitions: validDefinitions,\n        };\n    }\n    return content;\n};\n//# sourceMappingURL=filter-document-kind.js.map","import { printSchemaWithDirectives, fixSchemaAst, parseGraphQLSDL } from '@graphql-tools/utils';\nimport { printWithComments, resetComments } from '@graphql-tools/merge';\nimport { filterKind } from '../filter-document-kind';\nexport function parseSource({ partialSource, options, globOptions, pointerOptionMap, addValidSource }) {\n    if (partialSource) {\n        const input = prepareInput({\n            source: partialSource,\n            options,\n            globOptions,\n            pointerOptionMap,\n        });\n        parseSchema(input);\n        parseRawSDL(input);\n        if (input.source.document) {\n            useKindsFilter(input);\n            useComments(input);\n            collectValidSources(input, addValidSource);\n        }\n    }\n}\n//\nfunction prepareInput({ source, options, globOptions, pointerOptionMap, }) {\n    const specificOptions = {\n        ...options,\n        ...(source.location in pointerOptionMap ? globOptions : pointerOptionMap[source.location]),\n    };\n    return { source: { ...source }, options: specificOptions };\n}\nfunction parseSchema(input) {\n    if (input.source.schema) {\n        input.source.schema = fixSchemaAst(input.source.schema, input.options);\n        input.source.rawSDL = printSchemaWithDirectives(input.source.schema, input.options);\n    }\n}\nfunction parseRawSDL(input) {\n    if (input.source.rawSDL) {\n        input.source.document = parseGraphQLSDL(input.source.location, input.source.rawSDL, input.options).document;\n    }\n}\nfunction useKindsFilter(input) {\n    if (input.options.filterKinds) {\n        input.source.document = filterKind(input.source.document, input.options.filterKinds);\n    }\n}\nfunction useComments(input) {\n    if (!input.source.rawSDL) {\n        input.source.rawSDL = printWithComments(input.source.document);\n        resetComments();\n    }\n}\nfunction collectValidSources(input, addValidSource) {\n    if (input.source.document.definitions && input.source.document.definitions.length > 0) {\n        addValidSource(input.source);\n    }\n}\n//# sourceMappingURL=parse.js.map","import { compareStrings } from '@graphql-tools/utils';\nimport { normalizePointers } from './utils/pointers';\nimport { applyDefaultOptions } from './load-typedefs/options';\nimport { collectSources, collectSourcesSync } from './load-typedefs/collect-sources';\nimport { parseSource } from './load-typedefs/parse';\nimport { useLimit } from './utils/helpers';\nconst CONCURRENCY_LIMIT = 100;\n/**\n * Asynchronously loads any GraphQL documents (i.e. executable documents like\n * operations and fragments as well as type system definitions) from the\n * provided pointers.\n * @param pointerOrPointers Pointers to the sources to load the documents from\n * @param options Additional options\n */\nexport async function loadTypedefs(pointerOrPointers, options) {\n    const pointerOptionMap = normalizePointers(pointerOrPointers);\n    const globOptions = {};\n    applyDefaultOptions(options);\n    const sources = await collectSources({\n        pointerOptionMap,\n        options,\n    });\n    const validSources = [];\n    // If we have few k of files it may be an issue\n    const limit = useLimit(CONCURRENCY_LIMIT);\n    await Promise.all(sources.map(partialSource => limit(() => parseSource({\n        partialSource,\n        options,\n        globOptions,\n        pointerOptionMap,\n        addValidSource(source) {\n            validSources.push(source);\n        },\n    }))));\n    return prepareResult({ options, pointerOptionMap, validSources });\n}\n/**\n * Synchronously loads any GraphQL documents (i.e. executable documents like\n * operations and fragments as well as type system definitions) from the\n * provided pointers.\n * @param pointerOrPointers Pointers to the sources to load the documents from\n * @param options Additional options\n */\nexport function loadTypedefsSync(pointerOrPointers, options) {\n    const pointerOptionMap = normalizePointers(pointerOrPointers);\n    const globOptions = {};\n    applyDefaultOptions(options);\n    const sources = collectSourcesSync({\n        pointerOptionMap,\n        options,\n    });\n    const validSources = [];\n    sources.forEach(partialSource => {\n        parseSource({\n            partialSource,\n            options,\n            globOptions,\n            pointerOptionMap,\n            addValidSource(source) {\n                validSources.push(source);\n            },\n        });\n    });\n    return prepareResult({ options, pointerOptionMap, validSources });\n}\n//\nfunction prepareResult({ options, pointerOptionMap, validSources, }) {\n    const pointerList = Object.keys(pointerOptionMap);\n    if (pointerList.length > 0 && validSources.length === 0) {\n        throw new Error(`\n      Unable to find any GraphQL type definitions for the following pointers:\n        ${pointerList.map(p => `\n          - ${p}\n          `)}`);\n    }\n    return options.sort\n        ? validSources.sort((left, right) => compareStrings(left.location, right.location))\n        : validSources;\n}\n//# sourceMappingURL=load-typedefs.js.map","import { Kind } from 'graphql';\nimport { loadTypedefs, loadTypedefsSync } from './load-typedefs';\n/**\n * Kinds of AST nodes that are included in executable documents\n */\nexport const OPERATION_KINDS = [Kind.OPERATION_DEFINITION, Kind.FRAGMENT_DEFINITION];\n/**\n * Kinds of AST nodes that are included in type system definition documents\n */\nexport const NON_OPERATION_KINDS = Object.keys(Kind)\n    .reduce((prev, v) => [...prev, Kind[v]], [])\n    .filter(v => !OPERATION_KINDS.includes(v));\n/**\n * Asynchronously loads executable documents (i.e. operations and fragments) from\n * the provided pointers. The pointers may be individual files or a glob pattern.\n * The files themselves may be `.graphql` files or `.js` and `.ts` (in which\n * case they will be parsed using graphql-tag-pluck).\n * @param pointerOrPointers Pointers to the files to load the documents from\n * @param options Additional options\n */\nexport function loadDocuments(pointerOrPointers, options) {\n    return loadTypedefs(pointerOrPointers, { noRequire: true, filterKinds: NON_OPERATION_KINDS, ...options });\n}\n/**\n * Synchronously loads executable documents (i.e. operations and fragments) from\n * the provided pointers. The pointers may be individual files or a glob pattern.\n * The files themselves may be `.graphql` files or `.js` and `.ts` (in which\n * case they will be parsed using graphql-tag-pluck).\n * @param pointerOrPointers Pointers to the files to load the documents from\n * @param options Additional options\n */\nexport function loadDocumentsSync(pointerOrPointers, options) {\n    return loadTypedefsSync(pointerOrPointers, { noRequire: true, filterKinds: NON_OPERATION_KINDS, ...options });\n}\n//# sourceMappingURL=documents.js.map","import { loadTypedefs, loadTypedefsSync } from './load-typedefs';\nimport { Source as GraphQLSource, print } from 'graphql';\nimport { OPERATION_KINDS } from './documents';\nimport { mergeSchemasAsync, mergeSchemas } from '@graphql-tools/merge';\n/**\n * Asynchronously loads a schema from the provided pointers.\n * @param schemaPointers Pointers to the sources to load the schema from\n * @param options Additional options\n */\nexport async function loadSchema(schemaPointers, options) {\n    const sources = await loadTypedefs(schemaPointers, {\n        filterKinds: OPERATION_KINDS,\n        ...options,\n    });\n    const { schemas, typeDefs } = collectSchemasAndTypeDefs(sources);\n    const mergeSchemasOptions = {\n        schemas,\n        typeDefs,\n        ...options,\n    };\n    const schema = await mergeSchemasAsync(mergeSchemasOptions);\n    if (options === null || options === void 0 ? void 0 : options.includeSources) {\n        includeSources(schema, sources);\n    }\n    return schema;\n}\n/**\n * Synchronously loads a schema from the provided pointers.\n * @param schemaPointers Pointers to the sources to load the schema from\n * @param options Additional options\n */\nexport function loadSchemaSync(schemaPointers, options) {\n    const sources = loadTypedefsSync(schemaPointers, {\n        filterKinds: OPERATION_KINDS,\n        ...options,\n    });\n    const { schemas, typeDefs } = collectSchemasAndTypeDefs(sources);\n    const mergeSchemasOptions = {\n        schemas,\n        typeDefs,\n        ...options,\n    };\n    const schema = mergeSchemas(mergeSchemasOptions);\n    if (options === null || options === void 0 ? void 0 : options.includeSources) {\n        includeSources(schema, sources);\n    }\n    return schema;\n}\nfunction includeSources(schema, sources) {\n    schema.extensions = {\n        ...schema.extensions,\n        sources: sources\n            .filter(source => source.rawSDL || source.document)\n            .map(source => new GraphQLSource(source.rawSDL || print(source.document), source.location)),\n    };\n}\nfunction collectSchemasAndTypeDefs(sources) {\n    const schemas = [];\n    const typeDefs = [];\n    sources.forEach(source => {\n        if (source.schema) {\n            schemas.push(source.schema);\n        }\n        else {\n            typeDefs.push(source.document);\n        }\n    });\n    return {\n        schemas,\n        typeDefs,\n    };\n}\n//# sourceMappingURL=schema.js.map"]},"metadata":{},"sourceType":"module"}