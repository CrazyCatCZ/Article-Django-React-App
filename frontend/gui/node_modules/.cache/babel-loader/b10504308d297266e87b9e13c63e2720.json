{"ast":null,"code":"import { Kind, typeFromAST, TypeInfo, visit, visitWithTypeInfo, print, getNamedType, isAbstractType, isInterfaceType, isObjectType, TypeNameMetaFieldDef, getNullableType, isLeafType, isCompositeType, isListType, getOperationAST, isSchema, execute, subscribe, validate, defaultFieldResolver, parse } from 'graphql';\nimport isPromise from 'is-promise';\nimport { applySchemaTransforms, serializeInputValue, updateArgument, collectFields, implementsAbstractType, relocatedError, getErrorsByPathSegment, mergeDeep, ERROR_SYMBOL, typesContainSelectionSet, setErrors, slicedError, getResponseKeyFromInfo, mapAsyncIterator, getErrors, concatInlineFragments } from '@graphql-tools/utils';\nimport AggregateError from '@ardatan/aggregate-error';\nimport DataLoader from 'dataloader';\nconst OBJECT_SUBSCHEMA_SYMBOL = Symbol('initialSubschema');\nconst FIELD_SUBSCHEMA_MAP_SYMBOL = Symbol('subschemaMap');\n\nfunction getSubschema(result, responseKey) {\n  const subschema = result[FIELD_SUBSCHEMA_MAP_SYMBOL] && result[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];\n  return subschema || result[OBJECT_SUBSCHEMA_SYMBOL];\n}\n\nfunction setObjectSubschema(result, subschema) {\n  result[OBJECT_SUBSCHEMA_SYMBOL] = subschema;\n}\n\nfunction isSubschemaConfig(value) {\n  return Boolean(value.schema && value.permutations === undefined);\n}\n\nfunction isSubschema(value) {\n  return Boolean(value.transformedSchema);\n}\n\nclass Subschema {\n  constructor(config) {\n    var _a;\n\n    this.schema = config.schema;\n    this.executor = config.executor;\n    this.subscriber = config.subscriber;\n    this.createProxyingResolver = config.createProxyingResolver;\n    this.transforms = (_a = config.transforms) !== null && _a !== void 0 ? _a : [];\n    this.merge = config.merge;\n    this.transformedSchema = applySchemaTransforms(this.schema, this.transforms);\n  }\n\n}\n\nfunction getDelegatingOperation(parentType, schema) {\n  if (parentType === schema.getMutationType()) {\n    return 'mutation';\n  } else if (parentType === schema.getSubscriptionType()) {\n    return 'subscription';\n  }\n\n  return 'query';\n}\n\nfunction createRequestFromInfo({\n  info,\n  operationName,\n  operation = getDelegatingOperation(info.parentType, info.schema),\n  fieldName = info.fieldName,\n  selectionSet,\n  fieldNodes = info.fieldNodes\n}) {\n  return createRequest({\n    sourceSchema: info.schema,\n    sourceParentType: info.parentType,\n    sourceFieldName: info.fieldName,\n    fragments: info.fragments,\n    variableDefinitions: info.operation.variableDefinitions,\n    variableValues: info.variableValues,\n    targetOperationName: operationName,\n    targetOperation: operation,\n    targetFieldName: fieldName,\n    selectionSet,\n    fieldNodes\n  });\n}\n\nfunction createRequest({\n  sourceSchema,\n  sourceParentType,\n  sourceFieldName,\n  fragments,\n  variableDefinitions,\n  variableValues,\n  targetOperationName,\n  targetOperation,\n  targetFieldName,\n  selectionSet,\n  fieldNodes\n}) {\n  var _a;\n\n  let newSelectionSet;\n  let argumentNodeMap;\n\n  if (selectionSet != null) {\n    newSelectionSet = selectionSet;\n    argumentNodeMap = Object.create(null);\n  } else {\n    const selections = fieldNodes.reduce((acc, fieldNode) => fieldNode.selectionSet != null ? acc.concat(fieldNode.selectionSet.selections) : acc, []);\n    newSelectionSet = selections.length ? {\n      kind: Kind.SELECTION_SET,\n      selections\n    } : undefined;\n    argumentNodeMap = {};\n    const args = (_a = fieldNodes[0]) === null || _a === void 0 ? void 0 : _a.arguments;\n\n    if (args) {\n      argumentNodeMap = args.reduce((prev, curr) => ({ ...prev,\n        [curr.name.value]: curr\n      }), argumentNodeMap);\n    }\n  }\n\n  const newVariables = Object.create(null);\n  const variableDefinitionMap = Object.create(null);\n\n  if (sourceSchema != null && variableDefinitions != null) {\n    variableDefinitions.forEach(def => {\n      const varName = def.variable.name.value;\n      variableDefinitionMap[varName] = def;\n      const varType = typeFromAST(sourceSchema, def.type);\n      const serializedValue = serializeInputValue(varType, variableValues[varName]);\n\n      if (serializedValue !== undefined) {\n        newVariables[varName] = serializedValue;\n      }\n    });\n  }\n\n  if (sourceParentType != null) {\n    updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, newVariables);\n  }\n\n  const rootfieldNode = {\n    kind: Kind.FIELD,\n    arguments: Object.keys(argumentNodeMap).map(argName => argumentNodeMap[argName]),\n    name: {\n      kind: Kind.NAME,\n      value: targetFieldName || fieldNodes[0].name.value\n    },\n    selectionSet: newSelectionSet\n  };\n  const operationName = targetOperationName ? {\n    kind: Kind.NAME,\n    value: targetOperationName\n  } : undefined;\n  const operationDefinition = {\n    kind: Kind.OPERATION_DEFINITION,\n    name: operationName,\n    operation: targetOperation,\n    variableDefinitions: Object.keys(variableDefinitionMap).map(varName => variableDefinitionMap[varName]),\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: [rootfieldNode]\n    }\n  };\n  let definitions = [operationDefinition];\n\n  if (fragments != null) {\n    definitions = definitions.concat(Object.keys(fragments).map(fragmentName => fragments[fragmentName]));\n  }\n\n  const document = {\n    kind: Kind.DOCUMENT,\n    definitions\n  };\n  return {\n    document,\n    variables: newVariables\n  };\n}\n\nfunction updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, variableValues) {\n  const sourceField = sourceParentType.getFields()[sourceFieldName];\n  sourceField.args.forEach(argument => {\n    const argName = argument.name;\n    const sourceArgType = argument.type;\n\n    if (argumentNodeMap[argName] === undefined) {\n      const defaultValue = argument.defaultValue;\n\n      if (defaultValue !== undefined) {\n        updateArgument(argName, sourceArgType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(sourceArgType, defaultValue));\n      }\n    }\n  });\n}\n\nfunction memoizeInfoAnd2Objects(fn) {\n  let cache1;\n\n  function memoized(a1, a2, a3) {\n    if (!cache1) {\n      cache1 = new WeakMap();\n      const cache2 = new WeakMap();\n      cache1.set(a1.fieldNodes, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    let cache2 = cache1.get(a1.fieldNodes);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      cache1.set(a1.fieldNodes, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache3.get(a3);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  }\n\n  return memoized;\n}\n\nfunction memoize4(fn) {\n  let cache1;\n\n  function memoized(a1, a2, a3, a4) {\n    if (!cache1) {\n      cache1 = new WeakMap();\n      const cache2 = new WeakMap();\n      cache1.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    let cache2 = cache1.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      cache1.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    const cache4 = cache3.get(a3);\n\n    if (!cache4) {\n      const cache4 = new WeakMap();\n      cache3.set(a3, cache4);\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache4.get(a4);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3, a4);\n      cache4.set(a4, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  }\n\n  return memoized;\n}\n\nfunction memoize3(fn) {\n  let cache1;\n\n  function memoized(a1, a2, a3) {\n    if (!cache1) {\n      cache1 = new WeakMap();\n      const cache2 = new WeakMap();\n      cache1.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    let cache2 = cache1.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      cache1.set(a1, cache2);\n      const cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    let cache3 = cache2.get(a2);\n\n    if (!cache3) {\n      cache3 = new WeakMap();\n      cache2.set(a2, cache3);\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache3.get(a3);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3);\n      cache3.set(a3, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  }\n\n  return memoized;\n}\n\nfunction memoize2(fn) {\n  let cache1;\n\n  function memoized(a1, a2) {\n    if (!cache1) {\n      cache1 = new WeakMap();\n      const cache2 = new WeakMap();\n      cache1.set(a1, cache2);\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    let cache2 = cache1.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      cache1.set(a1, cache2);\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache2.get(a2);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  }\n\n  return memoized;\n}\n\nfunction memoize2of3(fn) {\n  let cache1;\n\n  function memoized(a1, a2, a3) {\n    if (!cache1) {\n      cache1 = new WeakMap();\n      const cache2 = new WeakMap();\n      cache1.set(a1, cache2);\n      const newValue = fn(a1, a2, a3);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    let cache2 = cache1.get(a1);\n\n    if (!cache2) {\n      cache2 = new WeakMap();\n      cache1.set(a1, cache2);\n      const newValue = fn(a1, a2, a3);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    const cachedValue = cache2.get(a2);\n\n    if (cachedValue === undefined) {\n      const newValue = fn(a1, a2, a3);\n      cache2.set(a2, newValue);\n      return newValue;\n    }\n\n    return cachedValue;\n  }\n\n  return memoized;\n}\n\nclass VisitSelectionSets {\n  constructor(schema, initialType, visitor) {\n    this.schema = schema;\n    this.initialType = initialType;\n    this.visitor = visitor;\n  }\n\n  transformRequest(originalRequest) {\n    const document = visitSelectionSets(originalRequest, this.schema, this.initialType, this.visitor);\n    return { ...originalRequest,\n      document\n    };\n  }\n\n}\n\nfunction visitSelectionSets(request, schema, initialType, visitor) {\n  const {\n    document,\n    variables\n  } = request;\n  const operations = [];\n  const fragments = Object.create(null);\n  document.definitions.forEach(def => {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      operations.push(def);\n    } else if (def.kind === Kind.FRAGMENT_DEFINITION) {\n      fragments[def.name.value] = def;\n    }\n  });\n  const partialExecutionContext = {\n    schema,\n    variableValues: variables,\n    fragments\n  };\n  const typeInfo = new TypeInfo(schema, undefined, initialType);\n  const newDefinitions = operations.map(operation => {\n    const type = operation.operation === 'query' ? schema.getQueryType() : operation.operation === 'mutation' ? schema.getMutationType() : schema.getSubscriptionType();\n    const fields = collectFields(partialExecutionContext, type, operation.selectionSet, Object.create(null), Object.create(null));\n    const newSelections = [];\n    Object.keys(fields).forEach(responseKey => {\n      const fieldNodes = fields[responseKey];\n      fieldNodes.forEach(fieldNode => {\n        const selectionSet = fieldNode.selectionSet;\n\n        if (selectionSet == null) {\n          newSelections.push(fieldNode);\n          return;\n        }\n\n        const newSelectionSet = visit(selectionSet, visitWithTypeInfo(typeInfo, {\n          [Kind.SELECTION_SET]: node => visitor(node, typeInfo)\n        }));\n\n        if (newSelectionSet === selectionSet) {\n          newSelections.push(fieldNode);\n          return;\n        }\n\n        newSelections.push({ ...fieldNode,\n          selectionSet: newSelectionSet\n        });\n      });\n    });\n    return { ...operation,\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: newSelections\n      }\n    };\n  });\n  Object.values(fragments).forEach(fragment => {\n    newDefinitions.push(visit(fragment, visitWithTypeInfo(typeInfo, {\n      [Kind.SELECTION_SET]: node => visitor(node, typeInfo)\n    })));\n  });\n  return { ...document,\n    definitions: newDefinitions\n  };\n}\n\nclass AddSelectionSets {\n  constructor(sourceSchema, initialType, selectionSetsByType, selectionSetsByField, dynamicSelectionSetsByField) {\n    this.transformer = new VisitSelectionSets(sourceSchema, initialType, (node, typeInfo) => visitSelectionSet(node, typeInfo, selectionSetsByType, selectionSetsByField, dynamicSelectionSetsByField));\n  }\n\n  transformRequest(originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  }\n\n}\n\nfunction visitSelectionSet(node, typeInfo, selectionSetsByType, selectionSetsByField, dynamicSelectionSetsByField) {\n  const parentType = typeInfo.getParentType();\n  const newSelections = new Map();\n\n  if (parentType != null) {\n    const parentTypeName = parentType.name;\n    addSelectionsToMap(newSelections, node);\n\n    if (parentTypeName in selectionSetsByType) {\n      const selectionSet = selectionSetsByType[parentTypeName];\n      addSelectionsToMap(newSelections, selectionSet);\n    }\n\n    if (parentTypeName in selectionSetsByField) {\n      node.selections.forEach(selection => {\n        if (selection.kind === Kind.FIELD) {\n          const name = selection.name.value;\n          const selectionSet = selectionSetsByField[parentTypeName][name];\n\n          if (selectionSet != null) {\n            addSelectionsToMap(newSelections, selectionSet);\n          }\n        }\n      });\n    }\n\n    if (parentTypeName in dynamicSelectionSetsByField) {\n      node.selections.forEach(selection => {\n        if (selection.kind === Kind.FIELD) {\n          const name = selection.name.value;\n          const dynamicSelectionSets = dynamicSelectionSetsByField[parentTypeName][name];\n\n          if (dynamicSelectionSets != null) {\n            dynamicSelectionSets.forEach(selectionSetFn => {\n              const selectionSet = selectionSetFn(selection);\n\n              if (selectionSet != null) {\n                addSelectionsToMap(newSelections, selectionSet);\n              }\n            });\n          }\n        }\n      });\n    }\n\n    return { ...node,\n      selections: Array.from(newSelections.values())\n    };\n  }\n}\n\nconst addSelectionsToMap = memoize2(function (map, selectionSet) {\n  selectionSet.selections.forEach(selection => {\n    map.set(print(selection), selection);\n  });\n});\n\nclass ExpandAbstractTypes {\n  constructor(sourceSchema, targetSchema) {\n    this.targetSchema = targetSchema;\n    const {\n      possibleTypesMap,\n      interfaceExtensionsMap\n    } = extractPossibleTypes(sourceSchema, targetSchema);\n    this.possibleTypesMap = possibleTypesMap;\n    this.reversePossibleTypesMap = flipMapping(this.possibleTypesMap);\n    this.interfaceExtensionsMap = interfaceExtensionsMap;\n  }\n\n  transformRequest(originalRequest) {\n    const document = expandAbstractTypes(this.targetSchema, this.possibleTypesMap, this.reversePossibleTypesMap, this.interfaceExtensionsMap, originalRequest.document);\n    return { ...originalRequest,\n      document\n    };\n  }\n\n}\n\nfunction extractPossibleTypes(sourceSchema, targetSchema) {\n  const typeMap = sourceSchema.getTypeMap();\n  const possibleTypesMap = Object.create(null);\n  const interfaceExtensionsMap = Object.create(null);\n  Object.keys(typeMap).forEach(typeName => {\n    const type = typeMap[typeName];\n\n    if (isAbstractType(type)) {\n      const targetType = targetSchema.getType(typeName);\n\n      if (isInterfaceType(type) && isInterfaceType(targetType)) {\n        const targetTypeFields = targetType.getFields();\n        const extensionFields = Object.create(null);\n        Object.keys(type.getFields()).forEach(fieldName => {\n          if (!targetTypeFields[fieldName]) {\n            extensionFields[fieldName] = true;\n          }\n        });\n\n        if (Object.keys(extensionFields).length) {\n          interfaceExtensionsMap[typeName] = extensionFields;\n        }\n      }\n\n      if (!isAbstractType(targetType) || typeName in interfaceExtensionsMap) {\n        const implementations = sourceSchema.getPossibleTypes(type);\n        possibleTypesMap[typeName] = implementations.filter(impl => targetSchema.getType(impl.name)).map(impl => impl.name);\n      }\n    }\n  });\n  return {\n    possibleTypesMap,\n    interfaceExtensionsMap\n  };\n}\n\nfunction flipMapping(mapping) {\n  const result = Object.create(null);\n  Object.keys(mapping).forEach(typeName => {\n    const toTypeNames = mapping[typeName];\n    toTypeNames.forEach(toTypeName => {\n      if (!(toTypeName in result)) {\n        result[toTypeName] = [];\n      }\n\n      result[toTypeName].push(typeName);\n    });\n  });\n  return result;\n}\n\nfunction expandAbstractTypes(targetSchema, possibleTypesMap, reversePossibleTypesMap, interfaceExtensionsMap, document) {\n  const operations = document.definitions.filter(def => def.kind === Kind.OPERATION_DEFINITION);\n  const fragments = document.definitions.filter(def => def.kind === Kind.FRAGMENT_DEFINITION);\n  const existingFragmentNames = fragments.map(fragment => fragment.name.value);\n  let fragmentCounter = 0;\n\n  const generateFragmentName = typeName => {\n    let fragmentName;\n\n    do {\n      fragmentName = `_${typeName}_Fragment${fragmentCounter.toString()}`;\n      fragmentCounter++;\n    } while (existingFragmentNames.indexOf(fragmentName) !== -1);\n\n    return fragmentName;\n  };\n\n  const generateInlineFragment = (typeName, selectionSet) => {\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: {\n        kind: Kind.NAMED_TYPE,\n        name: {\n          kind: Kind.NAME,\n          value: typeName\n        }\n      },\n      selectionSet\n    };\n  };\n\n  const newFragments = [];\n  const fragmentReplacements = Object.create(null);\n  fragments.forEach(fragment => {\n    newFragments.push(fragment);\n    const possibleTypes = possibleTypesMap[fragment.typeCondition.name.value];\n\n    if (possibleTypes != null) {\n      fragmentReplacements[fragment.name.value] = [];\n      possibleTypes.forEach(possibleTypeName => {\n        const name = generateFragmentName(possibleTypeName);\n        existingFragmentNames.push(name);\n        const newFragment = {\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: Kind.NAME,\n            value: name\n          },\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: possibleTypeName\n            }\n          },\n          selectionSet: fragment.selectionSet\n        };\n        newFragments.push(newFragment);\n        fragmentReplacements[fragment.name.value].push({\n          fragmentName: name,\n          typeName: possibleTypeName\n        });\n      });\n    }\n  });\n  const newDocument = { ...document,\n    definitions: [...operations, ...newFragments]\n  };\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(newDocument, visitWithTypeInfo(typeInfo, {\n    [Kind.SELECTION_SET](node) {\n      let newSelections = node.selections;\n      const addedSelections = [];\n      const maybeType = typeInfo.getParentType();\n\n      if (maybeType != null) {\n        const parentType = getNamedType(maybeType);\n        const interfaceExtension = interfaceExtensionsMap[parentType.name];\n        const interfaceExtensionFields = [];\n        node.selections.forEach(selection => {\n          if (selection.kind === Kind.INLINE_FRAGMENT) {\n            if (selection.typeCondition != null) {\n              const possibleTypes = possibleTypesMap[selection.typeCondition.name.value];\n\n              if (possibleTypes != null) {\n                possibleTypes.forEach(possibleType => {\n                  const maybePossibleType = targetSchema.getType(possibleType);\n\n                  if (maybePossibleType != null && implementsAbstractType(targetSchema, parentType, maybePossibleType)) {\n                    addedSelections.push(generateInlineFragment(possibleType, selection.selectionSet));\n                  }\n                });\n              }\n            }\n          } else if (selection.kind === Kind.FRAGMENT_SPREAD) {\n            const fragmentName = selection.name.value;\n\n            if (fragmentName in fragmentReplacements) {\n              fragmentReplacements[fragmentName].forEach(replacement => {\n                const typeName = replacement.typeName;\n                const maybeReplacementType = targetSchema.getType(typeName);\n\n                if (maybeReplacementType != null && implementsAbstractType(targetSchema, parentType, maybeType)) {\n                  addedSelections.push({\n                    kind: Kind.FRAGMENT_SPREAD,\n                    name: {\n                      kind: Kind.NAME,\n                      value: replacement.fragmentName\n                    }\n                  });\n                }\n              });\n            }\n          } else if (interfaceExtension != null && interfaceExtension[selection.name.value] && selection.kind === Kind.FIELD) {\n            interfaceExtensionFields.push(selection);\n          }\n        });\n\n        if (parentType.name in reversePossibleTypesMap) {\n          addedSelections.push({\n            kind: Kind.FIELD,\n            name: {\n              kind: Kind.NAME,\n              value: '__typename'\n            }\n          });\n        }\n\n        if (interfaceExtensionFields.length) {\n          const possibleTypes = possibleTypesMap[parentType.name];\n\n          if (possibleTypes != null) {\n            possibleTypes.forEach(possibleType => {\n              addedSelections.push(generateInlineFragment(possibleType, {\n                kind: Kind.SELECTION_SET,\n                selections: interfaceExtensionFields\n              }));\n            });\n            newSelections = newSelections.filter(selection => !(selection.kind === Kind.FIELD && interfaceExtension[selection.name.value]));\n          }\n        }\n      }\n\n      if (addedSelections.length) {\n        return { ...node,\n          selections: newSelections.concat(addedSelections)\n        };\n      }\n    }\n\n  }));\n} // For motivation, see https://github.com/ardatan/graphql-tools/issues/751\n\n\nclass WrapConcreteTypes {\n  constructor(returnType, targetSchema) {\n    this.returnType = returnType;\n    this.targetSchema = targetSchema;\n  }\n\n  transformRequest(originalRequest) {\n    const document = wrapConcreteTypes(this.returnType, this.targetSchema, originalRequest.document);\n    return { ...originalRequest,\n      document\n    };\n  }\n\n}\n\nfunction wrapConcreteTypes(returnType, targetSchema, document) {\n  const namedType = getNamedType(returnType);\n\n  if (!isObjectType(namedType)) {\n    return document;\n  }\n\n  const queryRootType = targetSchema.getQueryType();\n  const mutationRootType = targetSchema.getMutationType();\n  const subscriptionRootType = targetSchema.getSubscriptionType();\n  const typeInfo = new TypeInfo(targetSchema);\n  const newDocument = visit(document, visitWithTypeInfo(typeInfo, {\n    [Kind.FIELD](node) {\n      const maybeType = typeInfo.getParentType();\n\n      if (maybeType == null) {\n        return false;\n      }\n\n      const parentType = getNamedType(maybeType);\n\n      if (parentType !== queryRootType && parentType !== mutationRootType && parentType !== subscriptionRootType) {\n        return false;\n      }\n\n      if (!isAbstractType(getNamedType(typeInfo.getType()))) {\n        return false;\n      }\n\n      return { ...node,\n        selectionSet: {\n          kind: Kind.SELECTION_SET,\n          selections: [{\n            kind: Kind.INLINE_FRAGMENT,\n            typeCondition: {\n              kind: Kind.NAMED_TYPE,\n              name: {\n                kind: Kind.NAME,\n                value: namedType.name\n              }\n            },\n            selectionSet: node.selectionSet\n          }]\n        }\n      };\n    }\n\n  }));\n  return newDocument;\n}\n\nclass FilterToSchema {\n  constructor(targetSchema) {\n    this.targetSchema = targetSchema;\n  }\n\n  transformRequest(originalRequest) {\n    return { ...originalRequest,\n      ...filterToSchema(this.targetSchema, originalRequest.document, originalRequest.variables)\n    };\n  }\n\n}\n\nfunction filterToSchema(targetSchema, document, variables) {\n  const operations = document.definitions.filter(def => def.kind === Kind.OPERATION_DEFINITION);\n  const fragments = document.definitions.filter(def => def.kind === Kind.FRAGMENT_DEFINITION);\n  let usedVariables = [];\n  let usedFragments = [];\n  const newOperations = [];\n  let newFragments = [];\n  const validFragments = fragments.filter(fragment => {\n    const typeName = fragment.typeCondition.name.value;\n    return Boolean(targetSchema.getType(typeName));\n  });\n  const validFragmentsWithType = validFragments.reduce((prev, fragment) => ({ ...prev,\n    [fragment.name.value]: targetSchema.getType(fragment.typeCondition.name.value)\n  }), {});\n  let fragmentSet = Object.create(null);\n  operations.forEach(operation => {\n    let type;\n\n    if (operation.operation === 'subscription') {\n      type = targetSchema.getSubscriptionType();\n    } else if (operation.operation === 'mutation') {\n      type = targetSchema.getMutationType();\n    } else {\n      type = targetSchema.getQueryType();\n    }\n\n    const {\n      selectionSet,\n      usedFragments: operationUsedFragments,\n      usedVariables: operationUsedVariables\n    } = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet);\n    usedFragments = union(usedFragments, operationUsedFragments);\n    const {\n      usedVariables: collectedUsedVariables,\n      newFragments: collectedNewFragments,\n      fragmentSet: collectedFragmentSet\n    } = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments);\n    const operationOrFragmentVariables = union(operationUsedVariables, collectedUsedVariables);\n    usedVariables = union(usedVariables, operationOrFragmentVariables);\n    newFragments = collectedNewFragments;\n    fragmentSet = collectedFragmentSet;\n    const variableDefinitions = operation.variableDefinitions.filter(variable => operationOrFragmentVariables.indexOf(variable.variable.name.value) !== -1);\n    newOperations.push({\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation.operation,\n      name: operation.name,\n      directives: operation.directives,\n      variableDefinitions,\n      selectionSet\n    });\n  });\n  const newVariables = usedVariables.reduce((acc, variableName) => {\n    const variableValue = variables[variableName];\n\n    if (variableValue !== undefined) {\n      acc[variableName] = variableValue;\n    }\n\n    return acc;\n  }, {});\n  return {\n    document: {\n      kind: Kind.DOCUMENT,\n      definitions: [...newOperations, ...newFragments]\n    },\n    variables: newVariables\n  };\n}\n\nfunction collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {\n  let remainingFragments = usedFragments.slice();\n  let usedVariables = [];\n  const newFragments = [];\n\n  while (remainingFragments.length !== 0) {\n    const nextFragmentName = remainingFragments.pop();\n    const fragment = validFragments.find(fr => fr.name.value === nextFragmentName);\n\n    if (fragment != null) {\n      const name = nextFragmentName;\n      const typeName = fragment.typeCondition.name.value;\n      const type = targetSchema.getType(typeName);\n      const {\n        selectionSet,\n        usedFragments: fragmentUsedFragments,\n        usedVariables: fragmentUsedVariables\n      } = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet);\n      remainingFragments = union(remainingFragments, fragmentUsedFragments);\n      usedVariables = union(usedVariables, fragmentUsedVariables);\n\n      if (!(name in fragmentSet)) {\n        fragmentSet[name] = true;\n        newFragments.push({\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: Kind.NAME,\n            value: name\n          },\n          typeCondition: fragment.typeCondition,\n          selectionSet\n        });\n      }\n    }\n  }\n\n  return {\n    usedVariables,\n    newFragments,\n    fragmentSet\n  };\n}\n\nfunction filterSelectionSet(schema, type, validFragments, selectionSet) {\n  const usedFragments = [];\n  const usedVariables = [];\n  const typeInfo = new TypeInfo(schema, undefined, type);\n  const filteredSelectionSet = visit(selectionSet, visitWithTypeInfo(typeInfo, {\n    [Kind.FIELD]: {\n      enter(node) {\n        const parentType = typeInfo.getParentType();\n\n        if (isObjectType(parentType) || isInterfaceType(parentType)) {\n          const fields = parentType.getFields();\n          const field = node.name.value === '__typename' ? TypeNameMetaFieldDef : fields[node.name.value];\n\n          if (!field) {\n            return null;\n          }\n\n          const argNames = (field.args != null ? field.args : []).map(arg => arg.name);\n\n          if (node.arguments != null) {\n            const args = node.arguments.filter(arg => argNames.indexOf(arg.name.value) !== -1);\n\n            if (args.length !== node.arguments.length) {\n              return { ...node,\n                arguments: args\n              };\n            }\n          }\n        }\n      },\n\n      leave(node) {\n        const resolvedType = getNamedType(typeInfo.getType());\n\n        if (isObjectType(resolvedType) || isInterfaceType(resolvedType)) {\n          const selections = node.selectionSet != null ? node.selectionSet.selections : null;\n\n          if (selections == null || selections.length === 0) {\n            // need to remove any added variables. Is there a better way to do this?\n            visit(node, {\n              [Kind.VARIABLE](variableNode) {\n                const index = usedVariables.indexOf(variableNode.name.value);\n\n                if (index !== -1) {\n                  usedVariables.splice(index, 1);\n                }\n              }\n\n            });\n            return null;\n          }\n        }\n      }\n\n    },\n\n    [Kind.FRAGMENT_SPREAD](node) {\n      if (node.name.value in validFragments) {\n        const parentType = typeInfo.getParentType();\n        const innerType = validFragments[node.name.value];\n\n        if (!implementsAbstractType(schema, parentType, innerType)) {\n          return null;\n        }\n\n        usedFragments.push(node.name.value);\n        return;\n      }\n\n      return null;\n    },\n\n    [Kind.INLINE_FRAGMENT]: {\n      enter(node) {\n        if (node.typeCondition != null) {\n          const parentType = typeInfo.getParentType();\n          const innerType = schema.getType(node.typeCondition.name.value);\n\n          if (!implementsAbstractType(schema, parentType, innerType)) {\n            return null;\n          }\n        }\n      }\n\n    },\n\n    [Kind.VARIABLE](node) {\n      usedVariables.push(node.name.value);\n    }\n\n  }));\n  return {\n    selectionSet: filteredSelectionSet,\n    usedFragments,\n    usedVariables\n  };\n}\n\nfunction union(...arrays) {\n  const cache = Object.create(null);\n  const result = [];\n  arrays.forEach(array => {\n    array.forEach(item => {\n      if (!(item in cache)) {\n        cache[item] = true;\n        result.push(item);\n      }\n    });\n  });\n  return result;\n}\n\nclass AddFragmentsByField {\n  constructor(targetSchema, mapping) {\n    this.targetSchema = targetSchema;\n    this.mapping = mapping;\n  }\n\n  transformRequest(originalRequest) {\n    const document = addFragmentsByField(this.targetSchema, originalRequest.document, this.mapping);\n    return { ...originalRequest,\n      document\n    };\n  }\n\n}\n\nfunction addFragmentsByField(targetSchema, document, mapping) {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(document, visitWithTypeInfo(typeInfo, {\n    [Kind.SELECTION_SET](node) {\n      const parentType = typeInfo.getParentType();\n\n      if (parentType != null) {\n        const parentTypeName = parentType.name;\n        let selections = node.selections;\n\n        if (parentTypeName in mapping) {\n          node.selections.forEach(selection => {\n            if (selection.kind === Kind.FIELD) {\n              const name = selection.name.value;\n              const fragment = mapping[parentTypeName][name];\n\n              if (fragment != null) {\n                selections = selections.concat(fragment);\n              }\n            }\n          });\n        }\n\n        if (selections !== node.selections) {\n          return { ...node,\n            selections\n          };\n        }\n      }\n    }\n\n  }));\n}\n\nclass AddTypenameToAbstract {\n  constructor(targetSchema) {\n    this.targetSchema = targetSchema;\n  }\n\n  transformRequest(originalRequest) {\n    const document = addTypenameToAbstract(this.targetSchema, originalRequest.document);\n    return { ...originalRequest,\n      document\n    };\n  }\n\n}\n\nfunction addTypenameToAbstract(targetSchema, document) {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(document, visitWithTypeInfo(typeInfo, {\n    [Kind.SELECTION_SET](node) {\n      const parentType = typeInfo.getParentType();\n      let selections = node.selections;\n\n      if (parentType != null && isAbstractType(parentType)) {\n        selections = selections.concat({\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: '__typename'\n          }\n        });\n      }\n\n      if (selections !== node.selections) {\n        return { ...node,\n          selections\n        };\n      }\n    }\n\n  }));\n}\n\nfunction handleNull(errors) {\n  if (errors.length) {\n    if (errors.some(error => !error.path || error.path.length < 2)) {\n      if (errors.length > 1) {\n        const combinedError = new AggregateError(errors);\n        return combinedError;\n      }\n\n      const error = errors[0];\n      return error.originalError || relocatedError(error, null);\n    } else if (errors.some(error => typeof error.path[1] === 'string')) {\n      const childErrors = getErrorsByPathSegment(errors);\n      const result = {};\n      Object.keys(childErrors).forEach(pathSegment => {\n        result[pathSegment] = handleNull(childErrors[pathSegment]);\n      });\n      return result;\n    }\n\n    const childErrors = getErrorsByPathSegment(errors);\n    const result = [];\n    Object.keys(childErrors).forEach(pathSegment => {\n      result.push(handleNull(childErrors[pathSegment]));\n    });\n    return result;\n  }\n\n  return null;\n}\n\nfunction mergeProxiedResults(target, ...sources) {\n  const results = sources.filter(source => !(source instanceof Error));\n  const fieldSubschemaMap = results.reduce((acc, source) => {\n    const subschema = source[OBJECT_SUBSCHEMA_SYMBOL];\n    Object.keys(source).forEach(key => {\n      acc[key] = subschema;\n    });\n    return acc;\n  }, {});\n  const result = results.reduce(mergeDeep, target);\n  result[FIELD_SUBSCHEMA_MAP_SYMBOL] = target[FIELD_SUBSCHEMA_MAP_SYMBOL] ? Object.assign({}, target[FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap) : fieldSubschemaMap;\n  const errors = sources.map(source => source instanceof Error ? source : source[ERROR_SYMBOL]);\n  result[ERROR_SYMBOL] = target[ERROR_SYMBOL].concat(...errors);\n  return result;\n}\n\nconst sortSubschemasByProxiability = memoize4(function (mergedTypeInfo, sourceSubschemaOrSourceSubschemas, targetSubschemas, fieldNodes) {\n  // 1.  calculate if possible to delegate to given subschema\n  const proxiableSubschemas = [];\n  const nonProxiableSubschemas = [];\n  targetSubschemas.forEach(t => {\n    const selectionSet = mergedTypeInfo.selectionSets.get(t);\n    const fieldSelectionSets = mergedTypeInfo.fieldSelectionSets.get(t);\n\n    if (selectionSet != null && !subschemaTypesContainSelectionSet(mergedTypeInfo, sourceSubschemaOrSourceSubschemas, selectionSet)) {\n      nonProxiableSubschemas.push(t);\n    } else {\n      if (fieldSelectionSets == null || fieldNodes.every(fieldNode => {\n        const fieldName = fieldNode.name.value;\n        const fieldSelectionSet = fieldSelectionSets[fieldName];\n        return fieldSelectionSet == null || subschemaTypesContainSelectionSet(mergedTypeInfo, sourceSubschemaOrSourceSubschemas, fieldSelectionSet);\n      })) {\n        proxiableSubschemas.push(t);\n      } else {\n        nonProxiableSubschemas.push(t);\n      }\n    }\n  });\n  return {\n    proxiableSubschemas,\n    nonProxiableSubschemas\n  };\n});\nconst buildDelegationPlan = memoize3(function (mergedTypeInfo, fieldNodes, proxiableSubschemas) {\n  const {\n    uniqueFields,\n    nonUniqueFields\n  } = mergedTypeInfo;\n  const unproxiableFieldNodes = []; // 2. for each selection:\n\n  const delegationMap = new Map();\n  fieldNodes.forEach(fieldNode => {\n    if (fieldNode.name.value === '__typename') {\n      return;\n    } // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas\n\n\n    const uniqueSubschema = uniqueFields[fieldNode.name.value];\n\n    if (uniqueSubschema != null) {\n      if (!proxiableSubschemas.includes(uniqueSubschema)) {\n        unproxiableFieldNodes.push(fieldNode);\n        return;\n      }\n\n      const existingSubschema = delegationMap.get(uniqueSubschema);\n\n      if (existingSubschema != null) {\n        existingSubschema.push(fieldNode);\n      } else {\n        delegationMap.set(uniqueSubschema, [fieldNode]);\n      }\n\n      return;\n    } // 2b. use nonUniqueFields to assign to a possible subschema,\n    //     preferring one of the subschemas already targets of delegation\n\n\n    let nonUniqueSubschemas = nonUniqueFields[fieldNode.name.value];\n\n    if (nonUniqueSubschemas == null) {\n      unproxiableFieldNodes.push(fieldNode);\n      return;\n    }\n\n    nonUniqueSubschemas = nonUniqueSubschemas.filter(s => proxiableSubschemas.includes(s));\n\n    if (nonUniqueSubschemas == null) {\n      unproxiableFieldNodes.push(fieldNode);\n      return;\n    }\n\n    const subschemas = Array.from(delegationMap.keys());\n    const existingSubschema = nonUniqueSubschemas.find(s => subschemas.includes(s));\n\n    if (existingSubschema != null) {\n      delegationMap.get(existingSubschema).push(fieldNode);\n    } else {\n      delegationMap.set(nonUniqueSubschemas[0], [fieldNode]);\n    }\n  });\n  const finalDelegationMap = new Map();\n  delegationMap.forEach((selections, subschema) => {\n    finalDelegationMap.set(subschema, {\n      kind: Kind.SELECTION_SET,\n      selections\n    });\n  });\n  return {\n    delegationMap: finalDelegationMap,\n    unproxiableFieldNodes\n  };\n});\nconst combineSubschemas = memoize2(function (subschemaOrSubschemas, additionalSubschemas) {\n  return Array.isArray(subschemaOrSubschemas) ? subschemaOrSubschemas.concat(additionalSubschemas) : [subschemaOrSubschemas].concat(additionalSubschemas);\n});\n\nfunction mergeFields(mergedTypeInfo, typeName, object, fieldNodes, sourceSubschemaOrSourceSubschemas, targetSubschemas, context, info) {\n  if (!fieldNodes.length) {\n    return object;\n  }\n\n  const {\n    proxiableSubschemas,\n    nonProxiableSubschemas\n  } = sortSubschemasByProxiability(mergedTypeInfo, sourceSubschemaOrSourceSubschemas, targetSubschemas, fieldNodes);\n  const {\n    delegationMap,\n    unproxiableFieldNodes\n  } = buildDelegationPlan(mergedTypeInfo, fieldNodes, proxiableSubschemas);\n\n  if (!delegationMap.size) {\n    return object;\n  }\n\n  let containsPromises = false;\n  const maybePromises = [];\n  delegationMap.forEach((selectionSet, s) => {\n    const maybePromise = s.merge[typeName].resolve(object, context, info, s, selectionSet);\n    maybePromises.push(maybePromise);\n\n    if (!containsPromises && isPromise(maybePromise)) {\n      containsPromises = true;\n    }\n  });\n  return containsPromises ? Promise.all(maybePromises).then(results => mergeFields(mergedTypeInfo, typeName, mergeProxiedResults(object, ...results), unproxiableFieldNodes, combineSubschemas(sourceSubschemaOrSourceSubschemas, proxiableSubschemas), nonProxiableSubschemas, context, info)) : mergeFields(mergedTypeInfo, typeName, mergeProxiedResults(object, ...maybePromises), unproxiableFieldNodes, combineSubschemas(sourceSubschemaOrSourceSubschemas, proxiableSubschemas), nonProxiableSubschemas, context, info);\n}\n\nconst subschemaTypesContainSelectionSet = memoize3(function (mergedTypeInfo, sourceSubschemaOrSourceSubschemas, selectionSet) {\n  if (Array.isArray(sourceSubschemaOrSourceSubschemas)) {\n    return typesContainSelectionSet(sourceSubschemaOrSourceSubschemas.map(sourceSubschema => sourceSubschema.schema.getType(mergedTypeInfo.typeName)), selectionSet);\n  }\n\n  return typesContainSelectionSet([sourceSubschemaOrSourceSubschemas.schema.getType(mergedTypeInfo.typeName)], selectionSet);\n});\n\nfunction collectSubFields(info, typeName) {\n  let subFieldNodes = Object.create(null);\n  const visitedFragmentNames = Object.create(null);\n  const type = info.schema.getType(typeName);\n  const partialExecutionContext = {\n    schema: info.schema,\n    variableValues: info.variableValues,\n    fragments: info.fragments\n  };\n  info.fieldNodes.forEach(fieldNode => {\n    subFieldNodes = collectFields(partialExecutionContext, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n  });\n  const stitchingInfo = info.schema.extensions.stitchingInfo;\n  const selectionSetsByField = stitchingInfo.selectionSetsByField;\n  Object.keys(subFieldNodes).forEach(responseName => {\n    var _a;\n\n    const fieldName = subFieldNodes[responseName][0].name.value;\n    const fieldSelectionSet = (_a = selectionSetsByField === null || selectionSetsByField === void 0 ? void 0 : selectionSetsByField[typeName]) === null || _a === void 0 ? void 0 : _a[fieldName];\n\n    if (fieldSelectionSet != null) {\n      subFieldNodes = collectFields(partialExecutionContext, type, fieldSelectionSet, subFieldNodes, visitedFragmentNames);\n    }\n  });\n  return subFieldNodes;\n}\n\nconst getFieldsNotInSubschema = memoizeInfoAnd2Objects(function (info, subschema, mergedTypeInfo) {\n  const typeMap = isSubschemaConfig(subschema) ? mergedTypeInfo.typeMaps.get(subschema) : subschema.getTypeMap();\n  const typeName = mergedTypeInfo.typeName;\n  const fields = typeMap[typeName].getFields();\n  const subFieldNodes = collectSubFields(info, typeName);\n  let fieldsNotInSchema = [];\n  Object.keys(subFieldNodes).forEach(responseName => {\n    const fieldName = subFieldNodes[responseName][0].name.value;\n\n    if (!(fieldName in fields)) {\n      fieldsNotInSchema = fieldsNotInSchema.concat(subFieldNodes[responseName]);\n    }\n  });\n  return fieldsNotInSchema;\n});\n\nfunction handleObject(type, object, errors, subschema, context, info, skipTypeMerging) {\n  var _a;\n\n  const stitchingInfo = (_a = info === null || info === void 0 ? void 0 : info.schema.extensions) === null || _a === void 0 ? void 0 : _a.stitchingInfo;\n  setErrors(object, errors.map(error => slicedError(error)));\n  setObjectSubschema(object, subschema);\n\n  if (skipTypeMerging || !stitchingInfo) {\n    return object;\n  }\n\n  const typeName = isAbstractType(type) ? info.schema.getTypeMap()[object.__typename].name : type.name;\n  const mergedTypeInfo = stitchingInfo.mergedTypes[typeName];\n  let targetSubschemas;\n\n  if (mergedTypeInfo != null) {\n    targetSubschemas = mergedTypeInfo.targetSubschemas.get(subschema);\n  }\n\n  if (!targetSubschemas) {\n    return object;\n  }\n\n  const fieldNodes = getFieldsNotInSubschema(info, subschema, mergedTypeInfo);\n  return mergeFields(mergedTypeInfo, typeName, object, fieldNodes, subschema, targetSubschemas, context, info);\n}\n\nfunction handleList(type, list, errors, subschema, context, info, skipTypeMerging) {\n  const childErrors = getErrorsByPathSegment(errors);\n  return list.map((listMember, index) => handleListMember(getNullableType(type.ofType), listMember, index in childErrors ? childErrors[index] : [], subschema, context, info, skipTypeMerging));\n}\n\nfunction handleListMember(type, listMember, errors, subschema, context, info, skipTypeMerging) {\n  if (listMember == null) {\n    return handleNull(errors);\n  }\n\n  if (isLeafType(type)) {\n    return type.parseValue(listMember);\n  } else if (isCompositeType(type)) {\n    return handleObject(type, listMember, errors, subschema, context, info, skipTypeMerging);\n  } else if (isListType(type)) {\n    return handleList(type, listMember, errors, subschema, context, info, skipTypeMerging);\n  }\n}\n\nfunction handleResult(result, errors, subschema, context, info, returnType = info.returnType, skipTypeMerging) {\n  const type = getNullableType(returnType);\n\n  if (result == null) {\n    return handleNull(errors);\n  }\n\n  if (isLeafType(type)) {\n    return type.parseValue(result);\n  } else if (isCompositeType(type)) {\n    return handleObject(type, result, errors, subschema, context, info, skipTypeMerging);\n  } else if (isListType(type)) {\n    return handleList(type, result, errors, subschema, context, info, skipTypeMerging);\n  }\n}\n\nclass CheckResultAndHandleErrors {\n  constructor(info, fieldName, subschema, context, returnType = info.returnType, typeMerge) {\n    this.context = context;\n    this.info = info;\n    this.fieldName = fieldName;\n    this.subschema = subschema;\n    this.returnType = returnType;\n    this.typeMerge = typeMerge;\n  }\n\n  transformResult(result) {\n    return checkResultAndHandleErrors(result, this.context != null ? this.context : {}, this.info, this.fieldName, this.subschema, this.returnType, this.typeMerge);\n  }\n\n}\n\nfunction checkResultAndHandleErrors(result, context, info, responseKey = getResponseKeyFromInfo(info), subschema, returnType = info.returnType, skipTypeMerging) {\n  const errors = result.errors != null ? result.errors : [];\n  const data = result.data != null ? result.data[responseKey] : undefined;\n  return handleResult(data, errors, subschema, context, info, returnType, skipTypeMerging);\n}\n\nclass AddArgumentsAsVariables {\n  constructor(targetSchema, args) {\n    this.targetSchema = targetSchema;\n    this.args = Object.entries(args).reduce((prev, [key, val]) => ({ ...prev,\n      [key]: val\n    }), {});\n  }\n\n  transformRequest(originalRequest) {\n    const {\n      document,\n      variables\n    } = addVariablesToRootField(this.targetSchema, originalRequest, this.args);\n    return { ...originalRequest,\n      document,\n      variables\n    };\n  }\n\n}\n\nfunction addVariablesToRootField(targetSchema, originalRequest, args) {\n  const document = originalRequest.document;\n  const variableValues = originalRequest.variables;\n  const operations = document.definitions.filter(def => def.kind === Kind.OPERATION_DEFINITION);\n  const fragments = document.definitions.filter(def => def.kind === Kind.FRAGMENT_DEFINITION);\n  const newOperations = operations.map(operation => {\n    const variableDefinitionMap = operation.variableDefinitions.reduce((prev, def) => ({ ...prev,\n      [def.variable.name.value]: def\n    }), {});\n    let type;\n\n    if (operation.operation === 'subscription') {\n      type = targetSchema.getSubscriptionType();\n    } else if (operation.operation === 'mutation') {\n      type = targetSchema.getMutationType();\n    } else {\n      type = targetSchema.getQueryType();\n    }\n\n    const newSelectionSet = [];\n    operation.selectionSet.selections.forEach(selection => {\n      if (selection.kind === Kind.FIELD) {\n        const argumentNodes = selection.arguments;\n        const argumentNodeMap = argumentNodes.reduce((prev, argument) => ({ ...prev,\n          [argument.name.value]: argument\n        }), {});\n        const targetField = type.getFields()[selection.name.value]; // excludes __typename\n\n        if (targetField != null) {\n          updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, args);\n        }\n\n        newSelectionSet.push({ ...selection,\n          arguments: Object.keys(argumentNodeMap).map(argName => argumentNodeMap[argName])\n        });\n      } else {\n        newSelectionSet.push(selection);\n      }\n    });\n    return { ...operation,\n      variableDefinitions: Object.keys(variableDefinitionMap).map(varName => variableDefinitionMap[varName]),\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: newSelectionSet\n      }\n    };\n  });\n  return {\n    document: { ...document,\n      definitions: [...newOperations, ...fragments]\n    },\n    variables: variableValues\n  };\n}\n\nfunction updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, newArgs) {\n  targetField.args.forEach(argument => {\n    const argName = argument.name;\n    const argType = argument.type;\n\n    if (argName in newArgs) {\n      updateArgument(argName, argType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(argType, newArgs[argName]));\n    }\n  });\n}\n\nfunction defaultDelegationBinding(delegationContext) {\n  var _a;\n\n  const {\n    subschema: schemaOrSubschemaConfig,\n    targetSchema,\n    fieldName,\n    args,\n    context,\n    info,\n    returnType,\n    transforms = [],\n    skipTypeMerging\n  } = delegationContext;\n  const stitchingInfo = (_a = info === null || info === void 0 ? void 0 : info.schema.extensions) === null || _a === void 0 ? void 0 : _a.stitchingInfo;\n  let transformedSchema = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.transformedSchemas.get(schemaOrSubschemaConfig);\n\n  if (transformedSchema != null) {\n    delegationContext.transformedSchema = transformedSchema;\n  } else {\n    transformedSchema = delegationContext.transformedSchema;\n  }\n\n  let delegationTransforms = [new CheckResultAndHandleErrors(info, fieldName, schemaOrSubschemaConfig, context, returnType, skipTypeMerging)];\n\n  if (stitchingInfo != null) {\n    delegationTransforms = delegationTransforms.concat([new AddSelectionSets(info.schema, returnType, {}, stitchingInfo.selectionSetsByField, stitchingInfo.dynamicSelectionSetsByField), new WrapConcreteTypes(returnType, transformedSchema), new ExpandAbstractTypes(info.schema, transformedSchema)]);\n  } else if (info != null) {\n    delegationTransforms = delegationTransforms.concat([new WrapConcreteTypes(returnType, transformedSchema), new ExpandAbstractTypes(info.schema, transformedSchema)]);\n  } else {\n    delegationTransforms.push(new WrapConcreteTypes(returnType, transformedSchema));\n  }\n\n  delegationTransforms = delegationTransforms.concat(transforms.slice().reverse());\n\n  if (stitchingInfo != null) {\n    delegationTransforms.push(new AddFragmentsByField(targetSchema, stitchingInfo.fragmentsByField));\n  }\n\n  if (args != null) {\n    delegationTransforms.push(new AddArgumentsAsVariables(targetSchema, args));\n  }\n\n  delegationTransforms = delegationTransforms.concat([new FilterToSchema(targetSchema), new AddTypenameToAbstract(targetSchema)]);\n  return delegationTransforms;\n}\n\nclass Transformer {\n  constructor(context, binding = defaultDelegationBinding) {\n    this.transformations = [];\n    this.delegationContext = context;\n    const delegationTransforms = binding(this.delegationContext);\n    delegationTransforms.forEach(transform => this.addTransform(transform, {}));\n  }\n\n  addTransform(transform, context = {}) {\n    this.transformations.push({\n      transform,\n      context\n    });\n  }\n\n  transformRequest(originalRequest) {\n    return this.transformations.reduce((request, transformation) => transformation.transform.transformRequest != null ? transformation.transform.transformRequest(request, this.delegationContext, transformation.context) : request, originalRequest);\n  }\n\n  transformResult(originalResult) {\n    return this.transformations.reduceRight((result, transformation) => transformation.transform.transformResult != null ? transformation.transform.transformResult(result, this.delegationContext, transformation.context) : result, originalResult);\n  }\n\n} // adapted from https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-source-graphql/src/batching/merge-queries.js\n\n\nfunction createPrefix(index) {\n  return `graphqlTools${index}_`;\n}\n\nfunction parseKey(prefixedKey) {\n  const match = /^graphqlTools([\\d]+)_(.*)$/.exec(prefixedKey);\n\n  if (match && match.length === 3 && !isNaN(Number(match[1])) && match[2]) {\n    return {\n      index: Number(match[1]),\n      originalKey: match[2]\n    };\n  }\n\n  return null;\n} // adapted from https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-source-graphql/src/batching/merge-queries.js\n\n/**\n * Merge multiple queries into a single query in such a way that query results\n * can be split and transformed as if they were obtained by running original queries.\n *\n * Merging algorithm involves several transformations:\n *  1. Replace top-level fragment spreads with inline fragments (... on Query {})\n *  2. Add unique aliases to all top-level query fields (including those on inline fragments)\n *  3. Prefix all variable definitions and variable usages\n *  4. Prefix names (and spreads) of fragments\n *\n * i.e transform:\n *   [\n *     `query Foo($id: ID!) { foo, bar(id: $id), ...FooQuery }\n *     fragment FooQuery on Query { baz }`,\n *\n *    `query Bar($id: ID!) { foo: baz, bar(id: $id), ... on Query { baz } }`\n *   ]\n * to:\n *   query (\n *     $graphqlTools1_id: ID!\n *     $graphqlTools2_id: ID!\n *   ) {\n *     graphqlTools1_foo: foo,\n *     graphqlTools1_bar: bar(id: $graphqlTools1_id)\n *     ... on Query {\n *       graphqlTools1__baz: baz\n *     }\n *     graphqlTools1__foo: baz\n *     graphqlTools1__bar: bar(id: $graphqlTools1__id)\n *     ... on Query {\n *       graphqlTools1__baz: baz\n *     }\n *   }\n */\n\n\nfunction mergeExecutionParams(execs, extensionsReducer) {\n  const mergedVariables = Object.create(null);\n  const mergedVariableDefinitions = [];\n  const mergedSelections = [];\n  const mergedFragmentDefinitions = [];\n  let mergedExtensions = Object.create(null);\n  let operation;\n  execs.forEach((executionParams, index) => {\n    const prefixedExecutionParams = prefixExecutionParams(createPrefix(index), executionParams);\n    prefixedExecutionParams.document.definitions.forEach(def => {\n      var _a;\n\n      if (isOperationDefinition(def)) {\n        operation = def.operation;\n        mergedSelections.push(...def.selectionSet.selections);\n        mergedVariableDefinitions.push(...((_a = def.variableDefinitions) !== null && _a !== void 0 ? _a : []));\n      }\n\n      if (isFragmentDefinition(def)) {\n        mergedFragmentDefinitions.push(def);\n      }\n    });\n    Object.assign(mergedVariables, prefixedExecutionParams.variables);\n    mergedExtensions = extensionsReducer(mergedExtensions, executionParams);\n  });\n  const mergedOperationDefinition = {\n    kind: Kind.OPERATION_DEFINITION,\n    operation,\n    variableDefinitions: mergedVariableDefinitions,\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: mergedSelections\n    }\n  };\n  return {\n    document: {\n      kind: Kind.DOCUMENT,\n      definitions: [mergedOperationDefinition, ...mergedFragmentDefinitions]\n    },\n    variables: mergedVariables,\n    extensions: mergedExtensions,\n    context: execs[0].context,\n    info: execs[0].info\n  };\n}\n\nfunction prefixExecutionParams(prefix, executionParams) {\n  let document = aliasTopLevelFields(prefix, executionParams.document);\n  const variableNames = Object.keys(executionParams.variables);\n\n  if (variableNames.length === 0) {\n    return { ...executionParams,\n      document\n    };\n  }\n\n  document = visit(document, {\n    [Kind.VARIABLE]: node => prefixNodeName(node, prefix),\n    [Kind.FRAGMENT_DEFINITION]: node => prefixNodeName(node, prefix),\n    [Kind.FRAGMENT_SPREAD]: node => prefixNodeName(node, prefix)\n  });\n  const prefixedVariables = variableNames.reduce((acc, name) => {\n    acc[prefix + name] = executionParams.variables[name];\n    return acc;\n  }, Object.create(null));\n  return {\n    document,\n    variables: prefixedVariables\n  };\n}\n/**\n * Adds prefixed aliases to top-level fields of the query.\n *\n * @see aliasFieldsInSelection for implementation details\n */\n\n\nfunction aliasTopLevelFields(prefix, document) {\n  const transformer = {\n    [Kind.OPERATION_DEFINITION]: def => {\n      const {\n        selections\n      } = def.selectionSet;\n      return { ...def,\n        selectionSet: { ...def.selectionSet,\n          selections: aliasFieldsInSelection(prefix, selections, document)\n        }\n      };\n    }\n  };\n  return visit(document, transformer, {\n    [Kind.DOCUMENT]: [`definitions`]\n  });\n}\n/**\n * Add aliases to fields of the selection, including top-level fields of inline fragments.\n * Fragment spreads are converted to inline fragments and their top-level fields are also aliased.\n *\n * Note that this method is shallow. It adds aliases only to the top-level fields and doesn't\n * descend to field sub-selections.\n *\n * For example, transforms:\n *   {\n *     foo\n *     ... on Query { foo }\n *     ...FragmentWithBarField\n *   }\n * To:\n *   {\n *     graphqlTools1_foo: foo\n *     ... on Query { graphqlTools1_foo: foo }\n *     ... on Query { graphqlTools1_bar: bar }\n *   }\n */\n\n\nfunction aliasFieldsInSelection(prefix, selections, document) {\n  return selections.map(selection => {\n    switch (selection.kind) {\n      case Kind.INLINE_FRAGMENT:\n        return aliasFieldsInInlineFragment(prefix, selection, document);\n\n      case Kind.FRAGMENT_SPREAD:\n        {\n          const inlineFragment = inlineFragmentSpread(selection, document);\n          return aliasFieldsInInlineFragment(prefix, inlineFragment, document);\n        }\n\n      case Kind.FIELD:\n      default:\n        return aliasField(selection, prefix);\n    }\n  });\n}\n/**\n * Add aliases to top-level fields of the inline fragment.\n * Returns new inline fragment node.\n *\n * For Example, transforms:\n *   ... on Query { foo, ... on Query { bar: foo } }\n * To\n *   ... on Query { graphqlTools1_foo: foo, ... on Query { graphqlTools1_bar: foo } }\n */\n\n\nfunction aliasFieldsInInlineFragment(prefix, fragment, document) {\n  const {\n    selections\n  } = fragment.selectionSet;\n  return { ...fragment,\n    selectionSet: { ...fragment.selectionSet,\n      selections: aliasFieldsInSelection(prefix, selections, document)\n    }\n  };\n}\n/**\n * Replaces fragment spread with inline fragment\n *\n * Example:\n *   query { ...Spread }\n *   fragment Spread on Query { bar }\n *\n * Transforms to:\n *   query { ... on Query { bar } }\n */\n\n\nfunction inlineFragmentSpread(spread, document) {\n  const fragment = document.definitions.find(def => isFragmentDefinition(def) && def.name.value === spread.name.value);\n\n  if (!fragment) {\n    throw new Error(`Fragment ${spread.name.value} does not exist`);\n  }\n\n  const {\n    typeCondition,\n    selectionSet\n  } = fragment;\n  return {\n    kind: Kind.INLINE_FRAGMENT,\n    typeCondition,\n    selectionSet,\n    directives: spread.directives\n  };\n}\n\nfunction prefixNodeName(namedNode, prefix) {\n  return { ...namedNode,\n    name: { ...namedNode.name,\n      value: prefix + namedNode.name.value\n    }\n  };\n}\n/**\n * Returns a new FieldNode with prefixed alias\n *\n * Example. Given prefix === \"graphqlTools1_\" transforms:\n *   { foo } -> { graphqlTools1_foo: foo }\n *   { foo: bar } -> { graphqlTools1_foo: bar }\n */\n\n\nfunction aliasField(field, aliasPrefix) {\n  const aliasNode = field.alias ? field.alias : field.name;\n  return { ...field,\n    alias: { ...aliasNode,\n      value: aliasPrefix + aliasNode.value\n    }\n  };\n}\n\nfunction isOperationDefinition(def) {\n  return def.kind === Kind.OPERATION_DEFINITION;\n}\n\nfunction isFragmentDefinition(def) {\n  return def.kind === Kind.FRAGMENT_DEFINITION;\n} // adapted from https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-source-graphql/src/batching/merge-queries.js\n\n/**\n * Split and transform result of the query produced by the `merge` function\n */\n\n\nfunction splitResult(mergedResult, numResults) {\n  const splitResults = [];\n\n  for (let i = 0; i < numResults; i++) {\n    splitResults.push({});\n  }\n\n  const data = mergedResult.data;\n\n  if (data) {\n    Object.keys(data).forEach(prefixedKey => {\n      const {\n        index,\n        originalKey\n      } = parseKey(prefixedKey);\n\n      if (!splitResults[index].data) {\n        splitResults[index].data = {\n          [originalKey]: data[prefixedKey]\n        };\n      } else {\n        splitResults[index].data[originalKey] = data[prefixedKey];\n      }\n    });\n  }\n\n  const errors = mergedResult.errors;\n\n  if (errors) {\n    const newErrors = Object.create(null);\n    errors.forEach(error => {\n      if (error.path) {\n        const parsedKey = parseKey(error.path[0]);\n\n        if (parsedKey) {\n          const {\n            index,\n            originalKey\n          } = parsedKey;\n          const newError = relocatedError(error, [originalKey, ...error.path.slice(1)]);\n\n          if (!newErrors[index]) {\n            newErrors[index] = [newError];\n          } else {\n            newErrors[index].push(newError);\n          }\n\n          return;\n        }\n      }\n\n      splitResults.forEach((_splitResult, index) => {\n        if (!newErrors[index]) {\n          newErrors[index] = [error];\n        } else {\n          newErrors[index].push(error);\n        }\n      });\n    });\n    Object.keys(newErrors).forEach(index => {\n      splitResults[index].errors = newErrors[index];\n    });\n  }\n\n  return splitResults;\n}\n\nconst getBatchingExecutor = memoize2of3(function (_context, endpoint, executor) {\n  var _a, _b, _c;\n\n  const loader = new DataLoader(createLoadFn(executor !== null && executor !== void 0 ? executor : endpoint.executor, (_b = (_a = endpoint.batchingOptions) === null || _a === void 0 ? void 0 : _a.extensionsReducer) !== null && _b !== void 0 ? _b : defaultExtensionsReducer), (_c = endpoint.batchingOptions) === null || _c === void 0 ? void 0 : _c.dataLoaderOptions);\n  return executionParams => loader.load(executionParams);\n});\n\nfunction createLoadFn(executor, extensionsReducer) {\n  return async execs => {\n    const execBatches = [];\n    let index = 0;\n    const exec = execs[index];\n    let currentBatch = [exec];\n    execBatches.push(currentBatch);\n    const operationType = getOperationAST(exec.document, undefined).operation;\n\n    while (++index < execs.length) {\n      const currentOperationType = getOperationAST(execs[index].document, undefined).operation;\n\n      if (operationType === currentOperationType) {\n        currentBatch.push(execs[index]);\n      } else {\n        currentBatch = [execs[index]];\n        execBatches.push(currentBatch);\n      }\n    }\n\n    let containsPromises = false;\n    const executionResults = [];\n    execBatches.forEach(execBatch => {\n      const mergedExecutionParams = mergeExecutionParams(execBatch, extensionsReducer);\n      const executionResult = executor(mergedExecutionParams);\n\n      if (isPromise(executionResult)) {\n        containsPromises = true;\n      }\n\n      executionResults.push(executionResult);\n    });\n\n    if (containsPromises) {\n      return Promise.all(executionResults).then(resultBatches => {\n        let results = [];\n        resultBatches.forEach((resultBatch, index) => {\n          results = results.concat(splitResult(resultBatch, execBatches[index].length));\n        });\n        return results;\n      });\n    }\n\n    let results = [];\n    executionResults.forEach((resultBatch, index) => {\n      results = results.concat(splitResult(resultBatch, execBatches[index].length));\n    });\n    return results;\n  };\n}\n\nfunction defaultExtensionsReducer(mergedExtensions, executionParams) {\n  const newExtensions = executionParams.extensions;\n\n  if (newExtensions != null) {\n    Object.assign(mergedExtensions, newExtensions);\n  }\n\n  return mergedExtensions;\n}\n\nfunction delegateToSchema(options) {\n  if (isSchema(options)) {\n    throw new Error('Passing positional arguments to delegateToSchema is deprecated. ' + 'Please pass named parameters instead.');\n  }\n\n  const {\n    info,\n    operationName,\n    operation = getDelegatingOperation(info.parentType, info.schema),\n    fieldName = info.fieldName,\n    returnType = info.returnType,\n    selectionSet,\n    fieldNodes\n  } = options;\n  const request = createRequestFromInfo({\n    info,\n    operation,\n    fieldName,\n    selectionSet,\n    fieldNodes,\n    operationName\n  });\n  return delegateRequest({ ...options,\n    request,\n    operation,\n    fieldName,\n    returnType\n  });\n}\n\nfunction getDelegationReturnType(targetSchema, operation, fieldName) {\n  let rootType;\n\n  if (operation === 'query') {\n    rootType = targetSchema.getQueryType();\n  } else if (operation === 'mutation') {\n    rootType = targetSchema.getMutationType();\n  } else {\n    rootType = targetSchema.getSubscriptionType();\n  }\n\n  return rootType.getFields()[fieldName].type;\n}\n\nfunction delegateRequest({\n  request,\n  schema: subschemaOrSubschemaConfig,\n  rootValue,\n  info,\n  operation,\n  fieldName,\n  args,\n  returnType,\n  context,\n  transforms = [],\n  transformedSchema,\n  skipValidation,\n  skipTypeMerging,\n  binding\n}) {\n  var _a, _b, _c;\n\n  let operationDefinition;\n  let targetOperation;\n  let targetFieldName;\n\n  if (operation == null) {\n    operationDefinition = getOperationAST(request.document, undefined);\n    targetOperation = operationDefinition.operation;\n  } else {\n    targetOperation = operation;\n  }\n\n  if (fieldName == null) {\n    operationDefinition = operationDefinition !== null && operationDefinition !== void 0 ? operationDefinition : getOperationAST(request.document, undefined);\n    targetFieldName = operationDefinition.selectionSet.selections[0].name.value;\n  } else {\n    targetFieldName = fieldName;\n  }\n\n  let targetSchema;\n  let targetRootValue;\n  let subschemaConfig;\n  let endpoint;\n  let allTransforms;\n\n  if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\n    subschemaConfig = subschemaOrSubschemaConfig;\n    targetSchema = subschemaConfig.schema;\n    allTransforms = subschemaOrSubschemaConfig.transforms != null ? subschemaOrSubschemaConfig.transforms.concat(transforms) : transforms;\n\n    if (typeof subschemaConfig.endpoint === 'object') {\n      endpoint = subschemaConfig.endpoint;\n    } else if (typeof subschemaConfig.endpoint === 'string') {\n      const stitchingInfo = (_a = info === null || info === void 0 ? void 0 : info.schema.extensions) === null || _a === void 0 ? void 0 : _a.stitchingInfo;\n      endpoint = stitchingInfo.endpoints[subschemaConfig.endpoint];\n    } else {\n      endpoint = subschemaConfig;\n    }\n\n    targetRootValue = (_b = rootValue !== null && rootValue !== void 0 ? rootValue : endpoint === null || endpoint === void 0 ? void 0 : endpoint.rootValue) !== null && _b !== void 0 ? _b : info === null || info === void 0 ? void 0 : info.rootValue;\n  } else {\n    targetSchema = subschemaOrSubschemaConfig;\n    targetRootValue = rootValue !== null && rootValue !== void 0 ? rootValue : info === null || info === void 0 ? void 0 : info.rootValue;\n    allTransforms = transforms;\n  }\n\n  const delegationContext = {\n    subschema: subschemaOrSubschemaConfig,\n    targetSchema,\n    operation: targetOperation,\n    fieldName: targetFieldName,\n    args,\n    context,\n    info,\n    returnType: (_c = returnType !== null && returnType !== void 0 ? returnType : info === null || info === void 0 ? void 0 : info.returnType) !== null && _c !== void 0 ? _c : getDelegationReturnType(targetSchema, targetOperation, targetFieldName),\n    transforms: allTransforms,\n    transformedSchema: transformedSchema !== null && transformedSchema !== void 0 ? transformedSchema : targetSchema,\n    skipTypeMerging\n  };\n  const transformer = new Transformer(delegationContext, binding);\n  const processedRequest = transformer.transformRequest(request);\n\n  if (!skipValidation) {\n    validateRequest(targetSchema, processedRequest.document);\n  }\n\n  if (targetOperation === 'query' || targetOperation === 'mutation') {\n    let executor = (endpoint === null || endpoint === void 0 ? void 0 : endpoint.executor) || createDefaultExecutor(targetSchema, (subschemaConfig === null || subschemaConfig === void 0 ? void 0 : subschemaConfig.rootValue) || targetRootValue);\n\n    if (endpoint === null || endpoint === void 0 ? void 0 : endpoint.batch) {\n      executor = getBatchingExecutor(context, endpoint, executor);\n    }\n\n    const executionResult = executor({ ...processedRequest,\n      context,\n      info\n    });\n\n    if (isPromise(executionResult)) {\n      return executionResult.then(originalResult => transformer.transformResult(originalResult));\n    }\n\n    return transformer.transformResult(executionResult);\n  }\n\n  const subscriber = (endpoint === null || endpoint === void 0 ? void 0 : endpoint.subscriber) || createDefaultSubscriber(targetSchema, (subschemaConfig === null || subschemaConfig === void 0 ? void 0 : subschemaConfig.rootValue) || targetRootValue);\n  return subscriber({ ...processedRequest,\n    context,\n    info\n  }).then(subscriptionResult => {\n    if (Symbol.asyncIterator in subscriptionResult) {\n      // \"subscribe\" to the subscription result and map the result through the transforms\n      return mapAsyncIterator(subscriptionResult, originalResult => ({\n        [targetFieldName]: transformer.transformResult(originalResult)\n      }));\n    }\n\n    return transformer.transformResult(subscriptionResult);\n  });\n}\n\nfunction validateRequest(targetSchema, document) {\n  const errors = validate(targetSchema, document);\n\n  if (errors.length > 0) {\n    if (errors.length > 1) {\n      const combinedError = new AggregateError(errors);\n      throw combinedError;\n    }\n\n    const error = errors[0];\n    throw error.originalError || error;\n  }\n}\n\nfunction createDefaultExecutor(schema, rootValue) {\n  return ({\n    document,\n    context,\n    variables,\n    info\n  }) => execute({\n    schema,\n    document,\n    contextValue: context,\n    variableValues: variables,\n    rootValue: rootValue !== null && rootValue !== void 0 ? rootValue : info === null || info === void 0 ? void 0 : info.rootValue\n  });\n}\n\nfunction createDefaultSubscriber(schema, rootValue) {\n  return ({\n    document,\n    context,\n    variables,\n    info\n  }) => subscribe({\n    schema,\n    document,\n    contextValue: context,\n    variableValues: variables,\n    rootValue: rootValue !== null && rootValue !== void 0 ? rootValue : info === null || info === void 0 ? void 0 : info.rootValue\n  });\n}\n/**\n * Resolver that knows how to:\n * a) handle aliases for proxied schemas\n * b) handle errors from proxied schemas\n * c) handle external to internal enum coversion\n */\n\n\nfunction defaultMergedResolver(parent, args, context, info) {\n  if (!parent) {\n    return null;\n  }\n\n  const responseKey = getResponseKeyFromInfo(info);\n  const errors = getErrors(parent, responseKey); // check to see if parent is not a proxied result, i.e. if parent resolver was manually overwritten\n  // See https://github.com/apollographql/graphql-tools/issues/967\n\n  if (!errors) {\n    return defaultFieldResolver(parent, args, context, info);\n  }\n\n  const result = parent[responseKey];\n  const subschema = getSubschema(parent, responseKey);\n  return handleResult(result, errors, subschema, context, info);\n}\n\nfunction unwrapResult(parent, path) {\n  let newParent = parent;\n  const pathLength = path.length;\n\n  for (let i = 0; i < pathLength; i++) {\n    const responseKey = path[i];\n    const errors = getErrors(newParent, responseKey);\n    const subschema = getSubschema(newParent, responseKey);\n    const object = newParent[responseKey];\n\n    if (object == null) {\n      return handleNull(errors);\n    }\n\n    setErrors(object, errors.map(error => relocatedError(error, error.path != null ? error.path.slice(1) : undefined)));\n    setObjectSubschema(object, subschema);\n    newParent = object;\n  }\n\n  return newParent;\n}\n\nfunction dehoistResult(parent, delimeter = '__gqltf__') {\n  const result = Object.create(null);\n  Object.keys(parent).forEach(alias => {\n    let obj = result;\n    const fieldNames = alias.split(delimeter);\n    const fieldName = fieldNames.pop();\n    fieldNames.forEach(key => {\n      obj = obj[key] = obj[key] || Object.create(null);\n    });\n    obj[fieldName] = parent[alias];\n  });\n  result[ERROR_SYMBOL] = parent[ERROR_SYMBOL].map(error => {\n    if (error.path != null) {\n      const path = error.path.slice();\n      const pathSegment = path.shift();\n      const expandedPathSegment = pathSegment.split(delimeter);\n      return relocatedError(error, expandedPathSegment.concat(path));\n    }\n\n    return error;\n  });\n  result[OBJECT_SUBSCHEMA_SYMBOL] = parent[OBJECT_SUBSCHEMA_SYMBOL];\n  return result;\n}\n\nfunction createMergedResolver({\n  fromPath,\n  dehoist,\n  delimeter = '__gqltf__'\n}) {\n  const parentErrorResolver = (parent, args, context, info) => parent instanceof Error ? parent : defaultMergedResolver(parent, args, context, info);\n\n  const unwrappingResolver = fromPath != null ? (parent, args, context, info) => parentErrorResolver(unwrapResult(parent, fromPath), args, context, info) : parentErrorResolver;\n  const dehoistingResolver = dehoist ? (parent, args, context, info) => unwrappingResolver(dehoistResult(parent, delimeter), args, context, info) : unwrappingResolver;\n\n  const noParentResolver = (parent, args, context, info) => parent ? dehoistingResolver(parent, args, context, info) : {};\n\n  return noParentResolver;\n}\n\nclass AddSelectionSetsByField {\n  constructor(schema, mapping) {\n    this.schema = schema;\n    this.mapping = mapping;\n  }\n\n  transformRequest(originalRequest) {\n    const document = addSelectionSetsByField(this.schema, originalRequest.document, this.mapping);\n    return { ...originalRequest,\n      document\n    };\n  }\n\n}\n\nfunction addSelectionSetsByField(schema, document, mapping) {\n  const typeInfo = new TypeInfo(schema);\n  return visit(document, visitWithTypeInfo(typeInfo, {\n    [Kind.SELECTION_SET](node) {\n      const parentType = typeInfo.getParentType();\n\n      if (parentType != null) {\n        const parentTypeName = parentType.name;\n        let selections = node.selections;\n\n        if (parentTypeName in mapping) {\n          node.selections.forEach(selection => {\n            if (selection.kind === Kind.FIELD) {\n              const name = selection.name.value;\n              const selectionSet = mapping[parentTypeName][name];\n\n              if (selectionSet != null) {\n                selections = selections.concat(selectionSet.selections);\n              }\n            }\n          });\n        }\n\n        if (selections !== node.selections) {\n          return { ...node,\n            selections\n          };\n        }\n      }\n    }\n\n  }));\n}\n\nclass AddSelectionSetsByType {\n  constructor(targetSchema, mapping) {\n    this.targetSchema = targetSchema;\n    this.mapping = mapping;\n  }\n\n  transformRequest(originalRequest) {\n    const document = addSelectionSetsByType(this.targetSchema, originalRequest.document, this.mapping);\n    return { ...originalRequest,\n      document\n    };\n  }\n\n}\n\nfunction addSelectionSetsByType(targetSchema, document, mapping) {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(document, visitWithTypeInfo(typeInfo, {\n    [Kind.SELECTION_SET](node) {\n      const parentType = typeInfo.getParentType();\n\n      if (parentType != null) {\n        const parentTypeName = parentType.name;\n        let selections = node.selections;\n\n        if (parentTypeName in mapping) {\n          const selectionSet = mapping[parentTypeName];\n\n          if (selectionSet != null) {\n            selections = selections.concat(selectionSet.selections);\n          }\n        }\n\n        if (selections !== node.selections) {\n          return { ...node,\n            selections\n          };\n        }\n      }\n    }\n\n  }));\n}\n\nclass ReplaceFieldWithFragment {\n  constructor(targetSchema, fragments) {\n    this.targetSchema = targetSchema;\n    this.mapping = {};\n\n    for (const {\n      field,\n      fragment\n    } of fragments) {\n      const parsedFragment = parseFragmentToInlineFragment(fragment);\n      const actualTypeName = parsedFragment.typeCondition.name.value;\n\n      if (!(actualTypeName in this.mapping)) {\n        this.mapping[actualTypeName] = Object.create(null);\n      }\n\n      const typeMapping = this.mapping[actualTypeName];\n\n      if (!(field in typeMapping)) {\n        typeMapping[field] = [parsedFragment];\n      } else {\n        typeMapping[field].push(parsedFragment);\n      }\n    }\n  }\n\n  transformRequest(originalRequest) {\n    const document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);\n    return { ...originalRequest,\n      document\n    };\n  }\n\n}\n\nfunction replaceFieldsWithFragments(targetSchema, document, mapping) {\n  const typeInfo = new TypeInfo(targetSchema);\n  return visit(document, visitWithTypeInfo(typeInfo, {\n    [Kind.SELECTION_SET](node) {\n      const parentType = typeInfo.getParentType();\n\n      if (parentType != null) {\n        const parentTypeName = parentType.name;\n        let selections = node.selections;\n\n        if (parentTypeName in mapping) {\n          node.selections.forEach(selection => {\n            if (selection.kind === Kind.FIELD) {\n              const name = selection.name.value;\n              const fragments = mapping[parentTypeName][name];\n\n              if (fragments != null && fragments.length > 0) {\n                const fragment = concatInlineFragments(parentTypeName, fragments);\n                selections = selections.concat(fragment);\n              }\n            }\n          });\n        }\n\n        if (selections !== node.selections) {\n          return { ...node,\n            selections\n          };\n        }\n      }\n    }\n\n  }));\n}\n\nfunction parseFragmentToInlineFragment(definitions) {\n  if (definitions.trim().startsWith('fragment')) {\n    const document = parse(definitions);\n\n    for (const definition of document.definitions) {\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: definition.typeCondition,\n          selectionSet: definition.selectionSet\n        };\n      }\n    }\n  }\n\n  const query = parse(`{${definitions}}`).definitions[0];\n\n  for (const selection of query.selectionSet.selections) {\n    if (selection.kind === Kind.INLINE_FRAGMENT) {\n      return selection;\n    }\n  }\n\n  throw new Error('Could not parse fragment');\n}\n\nexport { AddArgumentsAsVariables, AddFragmentsByField, AddSelectionSetsByType as AddMergedTypeSelectionSets, AddSelectionSets, AddSelectionSetsByField, AddTypenameToAbstract, CheckResultAndHandleErrors, ExpandAbstractTypes, FilterToSchema, ReplaceFieldWithFragment, Subschema, VisitSelectionSets, checkResultAndHandleErrors, createMergedResolver, createRequest, createRequestFromInfo, defaultDelegationBinding, defaultMergedResolver, delegateRequest, delegateToSchema, getSubschema, handleResult, isSubschema, isSubschemaConfig };","map":{"version":3,"sources":["../../../dist/delegate/src/symbols.js","../../../dist/delegate/src/Subschema.js","../../../dist/delegate/src/createRequest.js","../../../dist/delegate/src/memoize.js","../../../dist/delegate/src/transforms/VisitSelectionSets.js","../../../dist/delegate/src/transforms/AddSelectionSets.js","../../../dist/delegate/src/transforms/ExpandAbstractTypes.js","../../../dist/delegate/src/transforms/WrapConcreteTypes.js","../../../dist/delegate/src/transforms/FilterToSchema.js","../../../dist/delegate/src/transforms/AddFragmentsByField.js","../../../dist/delegate/src/transforms/AddTypenameToAbstract.js","../../../dist/delegate/src/results/handleNull.js","../../../dist/delegate/src/results/mergeProxiedResults.js","../../../dist/delegate/src/results/mergeFields.js","../../../dist/delegate/src/results/getFieldsNotInSubschema.js","../../../dist/delegate/src/results/handleObject.js","../../../dist/delegate/src/results/handleList.js","../../../dist/delegate/src/results/handleResult.js","../../../dist/delegate/src/transforms/CheckResultAndHandleErrors.js","../../../dist/delegate/src/transforms/AddArgumentsAsVariables.js","../../../dist/delegate/src/delegationBindings.js","../../../dist/delegate/src/Transformer.js","../../../dist/delegate/src/prefix.js","../../../dist/delegate/src/mergeExecutionParams.js","../../../dist/delegate/src/splitResult.js","../../../dist/delegate/src/getBatchingExecutor.js","../../../dist/delegate/src/delegateToSchema.js","../../../dist/delegate/src/defaultMergedResolver.js","../../../dist/delegate/src/createMergedResolver.js","../../../dist/delegate/src/transforms/AddSelectionSetsByField.js","../../../dist/delegate/src/transforms/AddSelectionSetsByType.js","../../../dist/delegate/src/transforms/ReplaceFieldWithFragment.js"],"names":[],"mappings":"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","sourcesContent":["export const OBJECT_SUBSCHEMA_SYMBOL = Symbol('initialSubschema');\nexport const FIELD_SUBSCHEMA_MAP_SYMBOL = Symbol('subschemaMap');\n//# sourceMappingURL=symbols.js.map","import { applySchemaTransforms } from '@graphql-tools/utils';\nimport { FIELD_SUBSCHEMA_MAP_SYMBOL, OBJECT_SUBSCHEMA_SYMBOL } from './symbols';\nexport function getSubschema(result, responseKey) {\n    const subschema = result[FIELD_SUBSCHEMA_MAP_SYMBOL] && result[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];\n    return subschema || result[OBJECT_SUBSCHEMA_SYMBOL];\n}\nexport function setObjectSubschema(result, subschema) {\n    result[OBJECT_SUBSCHEMA_SYMBOL] = subschema;\n}\nexport function isSubschemaConfig(value) {\n    return Boolean(value.schema && value.permutations === undefined);\n}\nexport function isSubschema(value) {\n    return Boolean(value.transformedSchema);\n}\nexport class Subschema {\n    constructor(config) {\n        var _a;\n        this.schema = config.schema;\n        this.executor = config.executor;\n        this.subscriber = config.subscriber;\n        this.createProxyingResolver = config.createProxyingResolver;\n        this.transforms = (_a = config.transforms) !== null && _a !== void 0 ? _a : [];\n        this.merge = config.merge;\n        this.transformedSchema = applySchemaTransforms(this.schema, this.transforms);\n    }\n}\n//# sourceMappingURL=Subschema.js.map","import { Kind, typeFromAST, } from 'graphql';\nimport { serializeInputValue, updateArgument } from '@graphql-tools/utils';\nexport function getDelegatingOperation(parentType, schema) {\n    if (parentType === schema.getMutationType()) {\n        return 'mutation';\n    }\n    else if (parentType === schema.getSubscriptionType()) {\n        return 'subscription';\n    }\n    return 'query';\n}\nexport function createRequestFromInfo({ info, operationName, operation = getDelegatingOperation(info.parentType, info.schema), fieldName = info.fieldName, selectionSet, fieldNodes = info.fieldNodes, }) {\n    return createRequest({\n        sourceSchema: info.schema,\n        sourceParentType: info.parentType,\n        sourceFieldName: info.fieldName,\n        fragments: info.fragments,\n        variableDefinitions: info.operation.variableDefinitions,\n        variableValues: info.variableValues,\n        targetOperationName: operationName,\n        targetOperation: operation,\n        targetFieldName: fieldName,\n        selectionSet,\n        fieldNodes,\n    });\n}\nexport function createRequest({ sourceSchema, sourceParentType, sourceFieldName, fragments, variableDefinitions, variableValues, targetOperationName, targetOperation, targetFieldName, selectionSet, fieldNodes, }) {\n    var _a;\n    let newSelectionSet;\n    let argumentNodeMap;\n    if (selectionSet != null) {\n        newSelectionSet = selectionSet;\n        argumentNodeMap = Object.create(null);\n    }\n    else {\n        const selections = fieldNodes.reduce((acc, fieldNode) => (fieldNode.selectionSet != null ? acc.concat(fieldNode.selectionSet.selections) : acc), []);\n        newSelectionSet = selections.length\n            ? {\n                kind: Kind.SELECTION_SET,\n                selections,\n            }\n            : undefined;\n        argumentNodeMap = {};\n        const args = (_a = fieldNodes[0]) === null || _a === void 0 ? void 0 : _a.arguments;\n        if (args) {\n            argumentNodeMap = args.reduce((prev, curr) => ({\n                ...prev,\n                [curr.name.value]: curr,\n            }), argumentNodeMap);\n        }\n    }\n    const newVariables = Object.create(null);\n    const variableDefinitionMap = Object.create(null);\n    if (sourceSchema != null && variableDefinitions != null) {\n        variableDefinitions.forEach(def => {\n            const varName = def.variable.name.value;\n            variableDefinitionMap[varName] = def;\n            const varType = typeFromAST(sourceSchema, def.type);\n            const serializedValue = serializeInputValue(varType, variableValues[varName]);\n            if (serializedValue !== undefined) {\n                newVariables[varName] = serializedValue;\n            }\n        });\n    }\n    if (sourceParentType != null) {\n        updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, newVariables);\n    }\n    const rootfieldNode = {\n        kind: Kind.FIELD,\n        arguments: Object.keys(argumentNodeMap).map(argName => argumentNodeMap[argName]),\n        name: {\n            kind: Kind.NAME,\n            value: targetFieldName || fieldNodes[0].name.value,\n        },\n        selectionSet: newSelectionSet,\n    };\n    const operationName = targetOperationName\n        ? {\n            kind: Kind.NAME,\n            value: targetOperationName,\n        }\n        : undefined;\n    const operationDefinition = {\n        kind: Kind.OPERATION_DEFINITION,\n        name: operationName,\n        operation: targetOperation,\n        variableDefinitions: Object.keys(variableDefinitionMap).map(varName => variableDefinitionMap[varName]),\n        selectionSet: {\n            kind: Kind.SELECTION_SET,\n            selections: [rootfieldNode],\n        },\n    };\n    let definitions = [operationDefinition];\n    if (fragments != null) {\n        definitions = definitions.concat(Object.keys(fragments).map(fragmentName => fragments[fragmentName]));\n    }\n    const document = {\n        kind: Kind.DOCUMENT,\n        definitions,\n    };\n    return {\n        document,\n        variables: newVariables,\n    };\n}\nfunction updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, variableValues) {\n    const sourceField = sourceParentType.getFields()[sourceFieldName];\n    sourceField.args.forEach((argument) => {\n        const argName = argument.name;\n        const sourceArgType = argument.type;\n        if (argumentNodeMap[argName] === undefined) {\n            const defaultValue = argument.defaultValue;\n            if (defaultValue !== undefined) {\n                updateArgument(argName, sourceArgType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(sourceArgType, defaultValue));\n            }\n        }\n    });\n}\n//# sourceMappingURL=createRequest.js.map","export function memoizeInfoAnd2Objects(fn) {\n    let cache1;\n    function memoized(a1, a2, a3) {\n        if (!cache1) {\n            cache1 = new WeakMap();\n            const cache2 = new WeakMap();\n            cache1.set(a1.fieldNodes, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        let cache2 = cache1.get(a1.fieldNodes);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            cache1.set(a1.fieldNodes, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        const cachedValue = cache3.get(a3);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    }\n    return memoized;\n}\nexport function memoize4(fn) {\n    let cache1;\n    function memoized(a1, a2, a3, a4) {\n        if (!cache1) {\n            cache1 = new WeakMap();\n            const cache2 = new WeakMap();\n            cache1.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        let cache2 = cache1.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            cache1.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cache4 = cache3.get(a3);\n        if (!cache4) {\n            const cache4 = new WeakMap();\n            cache3.set(a3, cache4);\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        const cachedValue = cache4.get(a4);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3, a4);\n            cache4.set(a4, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    }\n    return memoized;\n}\nexport function memoize3(fn) {\n    let cache1;\n    function memoized(a1, a2, a3) {\n        if (!cache1) {\n            cache1 = new WeakMap();\n            const cache2 = new WeakMap();\n            cache1.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        let cache2 = cache1.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            cache1.set(a1, cache2);\n            const cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        let cache3 = cache2.get(a2);\n        if (!cache3) {\n            cache3 = new WeakMap();\n            cache2.set(a2, cache3);\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        const cachedValue = cache3.get(a3);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3);\n            cache3.set(a3, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    }\n    return memoized;\n}\nexport function memoize2(fn) {\n    let cache1;\n    function memoized(a1, a2) {\n        if (!cache1) {\n            cache1 = new WeakMap();\n            const cache2 = new WeakMap();\n            cache1.set(a1, cache2);\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        let cache2 = cache1.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            cache1.set(a1, cache2);\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    }\n    return memoized;\n}\nexport function memoize2of3(fn) {\n    let cache1;\n    function memoized(a1, a2, a3) {\n        if (!cache1) {\n            cache1 = new WeakMap();\n            const cache2 = new WeakMap();\n            cache1.set(a1, cache2);\n            const newValue = fn(a1, a2, a3);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        let cache2 = cache1.get(a1);\n        if (!cache2) {\n            cache2 = new WeakMap();\n            cache1.set(a1, cache2);\n            const newValue = fn(a1, a2, a3);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        const cachedValue = cache2.get(a2);\n        if (cachedValue === undefined) {\n            const newValue = fn(a1, a2, a3);\n            cache2.set(a2, newValue);\n            return newValue;\n        }\n        return cachedValue;\n    }\n    return memoized;\n}\n//# sourceMappingURL=memoize.js.map","import { Kind, TypeInfo, visit, visitWithTypeInfo, } from 'graphql';\nimport { collectFields } from '@graphql-tools/utils';\nexport default class VisitSelectionSets {\n    constructor(schema, initialType, visitor) {\n        this.schema = schema;\n        this.initialType = initialType;\n        this.visitor = visitor;\n    }\n    transformRequest(originalRequest) {\n        const document = visitSelectionSets(originalRequest, this.schema, this.initialType, this.visitor);\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n}\nfunction visitSelectionSets(request, schema, initialType, visitor) {\n    const { document, variables } = request;\n    const operations = [];\n    const fragments = Object.create(null);\n    document.definitions.forEach(def => {\n        if (def.kind === Kind.OPERATION_DEFINITION) {\n            operations.push(def);\n        }\n        else if (def.kind === Kind.FRAGMENT_DEFINITION) {\n            fragments[def.name.value] = def;\n        }\n    });\n    const partialExecutionContext = {\n        schema,\n        variableValues: variables,\n        fragments,\n    };\n    const typeInfo = new TypeInfo(schema, undefined, initialType);\n    const newDefinitions = operations.map(operation => {\n        const type = operation.operation === 'query'\n            ? schema.getQueryType()\n            : operation.operation === 'mutation'\n                ? schema.getMutationType()\n                : schema.getSubscriptionType();\n        const fields = collectFields(partialExecutionContext, type, operation.selectionSet, Object.create(null), Object.create(null));\n        const newSelections = [];\n        Object.keys(fields).forEach(responseKey => {\n            const fieldNodes = fields[responseKey];\n            fieldNodes.forEach(fieldNode => {\n                const selectionSet = fieldNode.selectionSet;\n                if (selectionSet == null) {\n                    newSelections.push(fieldNode);\n                    return;\n                }\n                const newSelectionSet = visit(selectionSet, visitWithTypeInfo(typeInfo, {\n                    [Kind.SELECTION_SET]: node => visitor(node, typeInfo),\n                }));\n                if (newSelectionSet === selectionSet) {\n                    newSelections.push(fieldNode);\n                    return;\n                }\n                newSelections.push({\n                    ...fieldNode,\n                    selectionSet: newSelectionSet,\n                });\n            });\n        });\n        return {\n            ...operation,\n            selectionSet: {\n                kind: Kind.SELECTION_SET,\n                selections: newSelections,\n            },\n        };\n    });\n    Object.values(fragments).forEach(fragment => {\n        newDefinitions.push(visit(fragment, visitWithTypeInfo(typeInfo, {\n            [Kind.SELECTION_SET]: node => visitor(node, typeInfo),\n        })));\n    });\n    return {\n        ...document,\n        definitions: newDefinitions,\n    };\n}\n//# sourceMappingURL=VisitSelectionSets.js.map","import { Kind, print, } from 'graphql';\nimport { memoize2 } from '../memoize';\nimport VisitSelectionSets from './VisitSelectionSets';\nexport default class AddSelectionSets {\n    constructor(sourceSchema, initialType, selectionSetsByType, selectionSetsByField, dynamicSelectionSetsByField) {\n        this.transformer = new VisitSelectionSets(sourceSchema, initialType, (node, typeInfo) => visitSelectionSet(node, typeInfo, selectionSetsByType, selectionSetsByField, dynamicSelectionSetsByField));\n    }\n    transformRequest(originalRequest) {\n        return this.transformer.transformRequest(originalRequest);\n    }\n}\nfunction visitSelectionSet(node, typeInfo, selectionSetsByType, selectionSetsByField, dynamicSelectionSetsByField) {\n    const parentType = typeInfo.getParentType();\n    const newSelections = new Map();\n    if (parentType != null) {\n        const parentTypeName = parentType.name;\n        addSelectionsToMap(newSelections, node);\n        if (parentTypeName in selectionSetsByType) {\n            const selectionSet = selectionSetsByType[parentTypeName];\n            addSelectionsToMap(newSelections, selectionSet);\n        }\n        if (parentTypeName in selectionSetsByField) {\n            node.selections.forEach(selection => {\n                if (selection.kind === Kind.FIELD) {\n                    const name = selection.name.value;\n                    const selectionSet = selectionSetsByField[parentTypeName][name];\n                    if (selectionSet != null) {\n                        addSelectionsToMap(newSelections, selectionSet);\n                    }\n                }\n            });\n        }\n        if (parentTypeName in dynamicSelectionSetsByField) {\n            node.selections.forEach(selection => {\n                if (selection.kind === Kind.FIELD) {\n                    const name = selection.name.value;\n                    const dynamicSelectionSets = dynamicSelectionSetsByField[parentTypeName][name];\n                    if (dynamicSelectionSets != null) {\n                        dynamicSelectionSets.forEach(selectionSetFn => {\n                            const selectionSet = selectionSetFn(selection);\n                            if (selectionSet != null) {\n                                addSelectionsToMap(newSelections, selectionSet);\n                            }\n                        });\n                    }\n                }\n            });\n        }\n        return {\n            ...node,\n            selections: Array.from(newSelections.values()),\n        };\n    }\n}\nconst addSelectionsToMap = memoize2(function (map, selectionSet) {\n    selectionSet.selections.forEach(selection => {\n        map.set(print(selection), selection);\n    });\n});\n//# sourceMappingURL=AddSelectionSets.js.map","import { Kind, TypeInfo, getNamedType, isAbstractType, isInterfaceType, visit, visitWithTypeInfo, } from 'graphql';\nimport { implementsAbstractType } from '@graphql-tools/utils';\nexport default class ExpandAbstractTypes {\n    constructor(sourceSchema, targetSchema) {\n        this.targetSchema = targetSchema;\n        const { possibleTypesMap, interfaceExtensionsMap } = extractPossibleTypes(sourceSchema, targetSchema);\n        this.possibleTypesMap = possibleTypesMap;\n        this.reversePossibleTypesMap = flipMapping(this.possibleTypesMap);\n        this.interfaceExtensionsMap = interfaceExtensionsMap;\n    }\n    transformRequest(originalRequest) {\n        const document = expandAbstractTypes(this.targetSchema, this.possibleTypesMap, this.reversePossibleTypesMap, this.interfaceExtensionsMap, originalRequest.document);\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n}\nfunction extractPossibleTypes(sourceSchema, targetSchema) {\n    const typeMap = sourceSchema.getTypeMap();\n    const possibleTypesMap = Object.create(null);\n    const interfaceExtensionsMap = Object.create(null);\n    Object.keys(typeMap).forEach(typeName => {\n        const type = typeMap[typeName];\n        if (isAbstractType(type)) {\n            const targetType = targetSchema.getType(typeName);\n            if (isInterfaceType(type) && isInterfaceType(targetType)) {\n                const targetTypeFields = targetType.getFields();\n                const extensionFields = Object.create(null);\n                Object.keys(type.getFields()).forEach((fieldName) => {\n                    if (!targetTypeFields[fieldName]) {\n                        extensionFields[fieldName] = true;\n                    }\n                });\n                if (Object.keys(extensionFields).length) {\n                    interfaceExtensionsMap[typeName] = extensionFields;\n                }\n            }\n            if (!isAbstractType(targetType) || typeName in interfaceExtensionsMap) {\n                const implementations = sourceSchema.getPossibleTypes(type);\n                possibleTypesMap[typeName] = implementations\n                    .filter(impl => targetSchema.getType(impl.name))\n                    .map(impl => impl.name);\n            }\n        }\n    });\n    return { possibleTypesMap, interfaceExtensionsMap };\n}\nfunction flipMapping(mapping) {\n    const result = Object.create(null);\n    Object.keys(mapping).forEach(typeName => {\n        const toTypeNames = mapping[typeName];\n        toTypeNames.forEach(toTypeName => {\n            if (!(toTypeName in result)) {\n                result[toTypeName] = [];\n            }\n            result[toTypeName].push(typeName);\n        });\n    });\n    return result;\n}\nfunction expandAbstractTypes(targetSchema, possibleTypesMap, reversePossibleTypesMap, interfaceExtensionsMap, document) {\n    const operations = document.definitions.filter(def => def.kind === Kind.OPERATION_DEFINITION);\n    const fragments = document.definitions.filter(def => def.kind === Kind.FRAGMENT_DEFINITION);\n    const existingFragmentNames = fragments.map(fragment => fragment.name.value);\n    let fragmentCounter = 0;\n    const generateFragmentName = (typeName) => {\n        let fragmentName;\n        do {\n            fragmentName = `_${typeName}_Fragment${fragmentCounter.toString()}`;\n            fragmentCounter++;\n        } while (existingFragmentNames.indexOf(fragmentName) !== -1);\n        return fragmentName;\n    };\n    const generateInlineFragment = (typeName, selectionSet) => {\n        return {\n            kind: Kind.INLINE_FRAGMENT,\n            typeCondition: {\n                kind: Kind.NAMED_TYPE,\n                name: {\n                    kind: Kind.NAME,\n                    value: typeName,\n                },\n            },\n            selectionSet,\n        };\n    };\n    const newFragments = [];\n    const fragmentReplacements = Object.create(null);\n    fragments.forEach((fragment) => {\n        newFragments.push(fragment);\n        const possibleTypes = possibleTypesMap[fragment.typeCondition.name.value];\n        if (possibleTypes != null) {\n            fragmentReplacements[fragment.name.value] = [];\n            possibleTypes.forEach(possibleTypeName => {\n                const name = generateFragmentName(possibleTypeName);\n                existingFragmentNames.push(name);\n                const newFragment = {\n                    kind: Kind.FRAGMENT_DEFINITION,\n                    name: {\n                        kind: Kind.NAME,\n                        value: name,\n                    },\n                    typeCondition: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: possibleTypeName,\n                        },\n                    },\n                    selectionSet: fragment.selectionSet,\n                };\n                newFragments.push(newFragment);\n                fragmentReplacements[fragment.name.value].push({\n                    fragmentName: name,\n                    typeName: possibleTypeName,\n                });\n            });\n        }\n    });\n    const newDocument = {\n        ...document,\n        definitions: [...operations, ...newFragments],\n    };\n    const typeInfo = new TypeInfo(targetSchema);\n    return visit(newDocument, visitWithTypeInfo(typeInfo, {\n        [Kind.SELECTION_SET](node) {\n            let newSelections = node.selections;\n            const addedSelections = [];\n            const maybeType = typeInfo.getParentType();\n            if (maybeType != null) {\n                const parentType = getNamedType(maybeType);\n                const interfaceExtension = interfaceExtensionsMap[parentType.name];\n                const interfaceExtensionFields = [];\n                node.selections.forEach((selection) => {\n                    if (selection.kind === Kind.INLINE_FRAGMENT) {\n                        if (selection.typeCondition != null) {\n                            const possibleTypes = possibleTypesMap[selection.typeCondition.name.value];\n                            if (possibleTypes != null) {\n                                possibleTypes.forEach(possibleType => {\n                                    const maybePossibleType = targetSchema.getType(possibleType);\n                                    if (maybePossibleType != null &&\n                                        implementsAbstractType(targetSchema, parentType, maybePossibleType)) {\n                                        addedSelections.push(generateInlineFragment(possibleType, selection.selectionSet));\n                                    }\n                                });\n                            }\n                        }\n                    }\n                    else if (selection.kind === Kind.FRAGMENT_SPREAD) {\n                        const fragmentName = selection.name.value;\n                        if (fragmentName in fragmentReplacements) {\n                            fragmentReplacements[fragmentName].forEach(replacement => {\n                                const typeName = replacement.typeName;\n                                const maybeReplacementType = targetSchema.getType(typeName);\n                                if (maybeReplacementType != null && implementsAbstractType(targetSchema, parentType, maybeType)) {\n                                    addedSelections.push({\n                                        kind: Kind.FRAGMENT_SPREAD,\n                                        name: {\n                                            kind: Kind.NAME,\n                                            value: replacement.fragmentName,\n                                        },\n                                    });\n                                }\n                            });\n                        }\n                    }\n                    else if (interfaceExtension != null &&\n                        interfaceExtension[selection.name.value] &&\n                        selection.kind === Kind.FIELD) {\n                        interfaceExtensionFields.push(selection);\n                    }\n                });\n                if (parentType.name in reversePossibleTypesMap) {\n                    addedSelections.push({\n                        kind: Kind.FIELD,\n                        name: {\n                            kind: Kind.NAME,\n                            value: '__typename',\n                        },\n                    });\n                }\n                if (interfaceExtensionFields.length) {\n                    const possibleTypes = possibleTypesMap[parentType.name];\n                    if (possibleTypes != null) {\n                        possibleTypes.forEach(possibleType => {\n                            addedSelections.push(generateInlineFragment(possibleType, {\n                                kind: Kind.SELECTION_SET,\n                                selections: interfaceExtensionFields,\n                            }));\n                        });\n                        newSelections = newSelections.filter((selection) => !(selection.kind === Kind.FIELD && interfaceExtension[selection.name.value]));\n                    }\n                }\n            }\n            if (addedSelections.length) {\n                return {\n                    ...node,\n                    selections: newSelections.concat(addedSelections),\n                };\n            }\n        },\n    }));\n}\n//# sourceMappingURL=ExpandAbstractTypes.js.map","import { Kind, getNamedType, isAbstractType, TypeInfo, visit, visitWithTypeInfo, isObjectType, } from 'graphql';\n// For motivation, see https://github.com/ardatan/graphql-tools/issues/751\nexport default class WrapConcreteTypes {\n    constructor(returnType, targetSchema) {\n        this.returnType = returnType;\n        this.targetSchema = targetSchema;\n    }\n    transformRequest(originalRequest) {\n        const document = wrapConcreteTypes(this.returnType, this.targetSchema, originalRequest.document);\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n}\nfunction wrapConcreteTypes(returnType, targetSchema, document) {\n    const namedType = getNamedType(returnType);\n    if (!isObjectType(namedType)) {\n        return document;\n    }\n    const queryRootType = targetSchema.getQueryType();\n    const mutationRootType = targetSchema.getMutationType();\n    const subscriptionRootType = targetSchema.getSubscriptionType();\n    const typeInfo = new TypeInfo(targetSchema);\n    const newDocument = visit(document, visitWithTypeInfo(typeInfo, {\n        [Kind.FIELD](node) {\n            const maybeType = typeInfo.getParentType();\n            if (maybeType == null) {\n                return false;\n            }\n            const parentType = getNamedType(maybeType);\n            if (parentType !== queryRootType && parentType !== mutationRootType && parentType !== subscriptionRootType) {\n                return false;\n            }\n            if (!isAbstractType(getNamedType(typeInfo.getType()))) {\n                return false;\n            }\n            return {\n                ...node,\n                selectionSet: {\n                    kind: Kind.SELECTION_SET,\n                    selections: [\n                        {\n                            kind: Kind.INLINE_FRAGMENT,\n                            typeCondition: {\n                                kind: Kind.NAMED_TYPE,\n                                name: {\n                                    kind: Kind.NAME,\n                                    value: namedType.name,\n                                },\n                            },\n                            selectionSet: node.selectionSet,\n                        },\n                    ],\n                },\n            };\n        },\n    }));\n    return newDocument;\n}\n//# sourceMappingURL=WrapConcreteTypes.js.map","import { Kind, TypeNameMetaFieldDef, visit, TypeInfo, visitWithTypeInfo, getNamedType, isObjectType, isInterfaceType, } from 'graphql';\nimport { implementsAbstractType } from '@graphql-tools/utils';\nexport default class FilterToSchema {\n    constructor(targetSchema) {\n        this.targetSchema = targetSchema;\n    }\n    transformRequest(originalRequest) {\n        return {\n            ...originalRequest,\n            ...filterToSchema(this.targetSchema, originalRequest.document, originalRequest.variables),\n        };\n    }\n}\nfunction filterToSchema(targetSchema, document, variables) {\n    const operations = document.definitions.filter(def => def.kind === Kind.OPERATION_DEFINITION);\n    const fragments = document.definitions.filter(def => def.kind === Kind.FRAGMENT_DEFINITION);\n    let usedVariables = [];\n    let usedFragments = [];\n    const newOperations = [];\n    let newFragments = [];\n    const validFragments = fragments.filter((fragment) => {\n        const typeName = fragment.typeCondition.name.value;\n        return Boolean(targetSchema.getType(typeName));\n    });\n    const validFragmentsWithType = validFragments.reduce((prev, fragment) => ({\n        ...prev,\n        [fragment.name.value]: targetSchema.getType(fragment.typeCondition.name.value),\n    }), {});\n    let fragmentSet = Object.create(null);\n    operations.forEach((operation) => {\n        let type;\n        if (operation.operation === 'subscription') {\n            type = targetSchema.getSubscriptionType();\n        }\n        else if (operation.operation === 'mutation') {\n            type = targetSchema.getMutationType();\n        }\n        else {\n            type = targetSchema.getQueryType();\n        }\n        const { selectionSet, usedFragments: operationUsedFragments, usedVariables: operationUsedVariables, } = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet);\n        usedFragments = union(usedFragments, operationUsedFragments);\n        const { usedVariables: collectedUsedVariables, newFragments: collectedNewFragments, fragmentSet: collectedFragmentSet, } = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments);\n        const operationOrFragmentVariables = union(operationUsedVariables, collectedUsedVariables);\n        usedVariables = union(usedVariables, operationOrFragmentVariables);\n        newFragments = collectedNewFragments;\n        fragmentSet = collectedFragmentSet;\n        const variableDefinitions = operation.variableDefinitions.filter((variable) => operationOrFragmentVariables.indexOf(variable.variable.name.value) !== -1);\n        newOperations.push({\n            kind: Kind.OPERATION_DEFINITION,\n            operation: operation.operation,\n            name: operation.name,\n            directives: operation.directives,\n            variableDefinitions,\n            selectionSet,\n        });\n    });\n    const newVariables = usedVariables.reduce((acc, variableName) => {\n        const variableValue = variables[variableName];\n        if (variableValue !== undefined) {\n            acc[variableName] = variableValue;\n        }\n        return acc;\n    }, {});\n    return {\n        document: {\n            kind: Kind.DOCUMENT,\n            definitions: [...newOperations, ...newFragments],\n        },\n        variables: newVariables,\n    };\n}\nfunction collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {\n    let remainingFragments = usedFragments.slice();\n    let usedVariables = [];\n    const newFragments = [];\n    while (remainingFragments.length !== 0) {\n        const nextFragmentName = remainingFragments.pop();\n        const fragment = validFragments.find(fr => fr.name.value === nextFragmentName);\n        if (fragment != null) {\n            const name = nextFragmentName;\n            const typeName = fragment.typeCondition.name.value;\n            const type = targetSchema.getType(typeName);\n            const { selectionSet, usedFragments: fragmentUsedFragments, usedVariables: fragmentUsedVariables, } = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet);\n            remainingFragments = union(remainingFragments, fragmentUsedFragments);\n            usedVariables = union(usedVariables, fragmentUsedVariables);\n            if (!(name in fragmentSet)) {\n                fragmentSet[name] = true;\n                newFragments.push({\n                    kind: Kind.FRAGMENT_DEFINITION,\n                    name: {\n                        kind: Kind.NAME,\n                        value: name,\n                    },\n                    typeCondition: fragment.typeCondition,\n                    selectionSet,\n                });\n            }\n        }\n    }\n    return {\n        usedVariables,\n        newFragments,\n        fragmentSet,\n    };\n}\nfunction filterSelectionSet(schema, type, validFragments, selectionSet) {\n    const usedFragments = [];\n    const usedVariables = [];\n    const typeInfo = new TypeInfo(schema, undefined, type);\n    const filteredSelectionSet = visit(selectionSet, visitWithTypeInfo(typeInfo, {\n        [Kind.FIELD]: {\n            enter(node) {\n                const parentType = typeInfo.getParentType();\n                if (isObjectType(parentType) || isInterfaceType(parentType)) {\n                    const fields = parentType.getFields();\n                    const field = node.name.value === '__typename' ? TypeNameMetaFieldDef : fields[node.name.value];\n                    if (!field) {\n                        return null;\n                    }\n                    const argNames = (field.args != null ? field.args : []).map(arg => arg.name);\n                    if (node.arguments != null) {\n                        const args = node.arguments.filter((arg) => argNames.indexOf(arg.name.value) !== -1);\n                        if (args.length !== node.arguments.length) {\n                            return {\n                                ...node,\n                                arguments: args,\n                            };\n                        }\n                    }\n                }\n            },\n            leave(node) {\n                const resolvedType = getNamedType(typeInfo.getType());\n                if (isObjectType(resolvedType) || isInterfaceType(resolvedType)) {\n                    const selections = node.selectionSet != null ? node.selectionSet.selections : null;\n                    if (selections == null || selections.length === 0) {\n                        // need to remove any added variables. Is there a better way to do this?\n                        visit(node, {\n                            [Kind.VARIABLE](variableNode) {\n                                const index = usedVariables.indexOf(variableNode.name.value);\n                                if (index !== -1) {\n                                    usedVariables.splice(index, 1);\n                                }\n                            },\n                        });\n                        return null;\n                    }\n                }\n            },\n        },\n        [Kind.FRAGMENT_SPREAD](node) {\n            if (node.name.value in validFragments) {\n                const parentType = typeInfo.getParentType();\n                const innerType = validFragments[node.name.value];\n                if (!implementsAbstractType(schema, parentType, innerType)) {\n                    return null;\n                }\n                usedFragments.push(node.name.value);\n                return;\n            }\n            return null;\n        },\n        [Kind.INLINE_FRAGMENT]: {\n            enter(node) {\n                if (node.typeCondition != null) {\n                    const parentType = typeInfo.getParentType();\n                    const innerType = schema.getType(node.typeCondition.name.value);\n                    if (!implementsAbstractType(schema, parentType, innerType)) {\n                        return null;\n                    }\n                }\n            },\n        },\n        [Kind.VARIABLE](node) {\n            usedVariables.push(node.name.value);\n        },\n    }));\n    return {\n        selectionSet: filteredSelectionSet,\n        usedFragments,\n        usedVariables,\n    };\n}\nfunction union(...arrays) {\n    const cache = Object.create(null);\n    const result = [];\n    arrays.forEach(array => {\n        array.forEach(item => {\n            if (!(item in cache)) {\n                cache[item] = true;\n                result.push(item);\n            }\n        });\n    });\n    return result;\n}\n//# sourceMappingURL=FilterToSchema.js.map","import { Kind, TypeInfo, visit, visitWithTypeInfo, } from 'graphql';\nexport default class AddFragmentsByField {\n    constructor(targetSchema, mapping) {\n        this.targetSchema = targetSchema;\n        this.mapping = mapping;\n    }\n    transformRequest(originalRequest) {\n        const document = addFragmentsByField(this.targetSchema, originalRequest.document, this.mapping);\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n}\nfunction addFragmentsByField(targetSchema, document, mapping) {\n    const typeInfo = new TypeInfo(targetSchema);\n    return visit(document, visitWithTypeInfo(typeInfo, {\n        [Kind.SELECTION_SET](node) {\n            const parentType = typeInfo.getParentType();\n            if (parentType != null) {\n                const parentTypeName = parentType.name;\n                let selections = node.selections;\n                if (parentTypeName in mapping) {\n                    node.selections.forEach(selection => {\n                        if (selection.kind === Kind.FIELD) {\n                            const name = selection.name.value;\n                            const fragment = mapping[parentTypeName][name];\n                            if (fragment != null) {\n                                selections = selections.concat(fragment);\n                            }\n                        }\n                    });\n                }\n                if (selections !== node.selections) {\n                    return {\n                        ...node,\n                        selections,\n                    };\n                }\n            }\n        },\n    }));\n}\n//# sourceMappingURL=AddFragmentsByField.js.map","import { TypeInfo, visit, visitWithTypeInfo, Kind, isAbstractType, } from 'graphql';\nexport default class AddTypenameToAbstract {\n    constructor(targetSchema) {\n        this.targetSchema = targetSchema;\n    }\n    transformRequest(originalRequest) {\n        const document = addTypenameToAbstract(this.targetSchema, originalRequest.document);\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n}\nfunction addTypenameToAbstract(targetSchema, document) {\n    const typeInfo = new TypeInfo(targetSchema);\n    return visit(document, visitWithTypeInfo(typeInfo, {\n        [Kind.SELECTION_SET](node) {\n            const parentType = typeInfo.getParentType();\n            let selections = node.selections;\n            if (parentType != null && isAbstractType(parentType)) {\n                selections = selections.concat({\n                    kind: Kind.FIELD,\n                    name: {\n                        kind: Kind.NAME,\n                        value: '__typename',\n                    },\n                });\n            }\n            if (selections !== node.selections) {\n                return {\n                    ...node,\n                    selections,\n                };\n            }\n        },\n    }));\n}\n//# sourceMappingURL=AddTypenameToAbstract.js.map","import AggregateError from '@ardatan/aggregate-error';\nimport { getErrorsByPathSegment, relocatedError } from '@graphql-tools/utils';\nexport function handleNull(errors) {\n    if (errors.length) {\n        if (errors.some(error => !error.path || error.path.length < 2)) {\n            if (errors.length > 1) {\n                const combinedError = new AggregateError(errors);\n                return combinedError;\n            }\n            const error = errors[0];\n            return error.originalError || relocatedError(error, null);\n        }\n        else if (errors.some(error => typeof error.path[1] === 'string')) {\n            const childErrors = getErrorsByPathSegment(errors);\n            const result = {};\n            Object.keys(childErrors).forEach(pathSegment => {\n                result[pathSegment] = handleNull(childErrors[pathSegment]);\n            });\n            return result;\n        }\n        const childErrors = getErrorsByPathSegment(errors);\n        const result = [];\n        Object.keys(childErrors).forEach(pathSegment => {\n            result.push(handleNull(childErrors[pathSegment]));\n        });\n        return result;\n    }\n    return null;\n}\n//# sourceMappingURL=handleNull.js.map","import { mergeDeep, ERROR_SYMBOL } from '@graphql-tools/utils';\nimport { OBJECT_SUBSCHEMA_SYMBOL, FIELD_SUBSCHEMA_MAP_SYMBOL } from '../symbols';\nexport function mergeProxiedResults(target, ...sources) {\n    const results = sources.filter(source => !(source instanceof Error));\n    const fieldSubschemaMap = results.reduce((acc, source) => {\n        const subschema = source[OBJECT_SUBSCHEMA_SYMBOL];\n        Object.keys(source).forEach(key => {\n            acc[key] = subschema;\n        });\n        return acc;\n    }, {});\n    const result = results.reduce(mergeDeep, target);\n    result[FIELD_SUBSCHEMA_MAP_SYMBOL] = target[FIELD_SUBSCHEMA_MAP_SYMBOL]\n        ? Object.assign({}, target[FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap)\n        : fieldSubschemaMap;\n    const errors = sources.map((source) => (source instanceof Error ? source : source[ERROR_SYMBOL]));\n    result[ERROR_SYMBOL] = target[ERROR_SYMBOL].concat(...errors);\n    return result;\n}\n//# sourceMappingURL=mergeProxiedResults.js.map","import { Kind } from 'graphql';\nimport isPromise from 'is-promise';\nimport { typesContainSelectionSet } from '@graphql-tools/utils';\nimport { memoize4, memoize3, memoize2 } from '../memoize';\nimport { mergeProxiedResults } from './mergeProxiedResults';\nconst sortSubschemasByProxiability = memoize4(function (mergedTypeInfo, sourceSubschemaOrSourceSubschemas, targetSubschemas, fieldNodes) {\n    // 1.  calculate if possible to delegate to given subschema\n    const proxiableSubschemas = [];\n    const nonProxiableSubschemas = [];\n    targetSubschemas.forEach(t => {\n        const selectionSet = mergedTypeInfo.selectionSets.get(t);\n        const fieldSelectionSets = mergedTypeInfo.fieldSelectionSets.get(t);\n        if (selectionSet != null &&\n            !subschemaTypesContainSelectionSet(mergedTypeInfo, sourceSubschemaOrSourceSubschemas, selectionSet)) {\n            nonProxiableSubschemas.push(t);\n        }\n        else {\n            if (fieldSelectionSets == null ||\n                fieldNodes.every(fieldNode => {\n                    const fieldName = fieldNode.name.value;\n                    const fieldSelectionSet = fieldSelectionSets[fieldName];\n                    return (fieldSelectionSet == null ||\n                        subschemaTypesContainSelectionSet(mergedTypeInfo, sourceSubschemaOrSourceSubschemas, fieldSelectionSet));\n                })) {\n                proxiableSubschemas.push(t);\n            }\n            else {\n                nonProxiableSubschemas.push(t);\n            }\n        }\n    });\n    return {\n        proxiableSubschemas,\n        nonProxiableSubschemas,\n    };\n});\nconst buildDelegationPlan = memoize3(function (mergedTypeInfo, fieldNodes, proxiableSubschemas) {\n    const { uniqueFields, nonUniqueFields } = mergedTypeInfo;\n    const unproxiableFieldNodes = [];\n    // 2. for each selection:\n    const delegationMap = new Map();\n    fieldNodes.forEach(fieldNode => {\n        if (fieldNode.name.value === '__typename') {\n            return;\n        }\n        // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas\n        const uniqueSubschema = uniqueFields[fieldNode.name.value];\n        if (uniqueSubschema != null) {\n            if (!proxiableSubschemas.includes(uniqueSubschema)) {\n                unproxiableFieldNodes.push(fieldNode);\n                return;\n            }\n            const existingSubschema = delegationMap.get(uniqueSubschema);\n            if (existingSubschema != null) {\n                existingSubschema.push(fieldNode);\n            }\n            else {\n                delegationMap.set(uniqueSubschema, [fieldNode]);\n            }\n            return;\n        }\n        // 2b. use nonUniqueFields to assign to a possible subschema,\n        //     preferring one of the subschemas already targets of delegation\n        let nonUniqueSubschemas = nonUniqueFields[fieldNode.name.value];\n        if (nonUniqueSubschemas == null) {\n            unproxiableFieldNodes.push(fieldNode);\n            return;\n        }\n        nonUniqueSubschemas = nonUniqueSubschemas.filter(s => proxiableSubschemas.includes(s));\n        if (nonUniqueSubschemas == null) {\n            unproxiableFieldNodes.push(fieldNode);\n            return;\n        }\n        const subschemas = Array.from(delegationMap.keys());\n        const existingSubschema = nonUniqueSubschemas.find(s => subschemas.includes(s));\n        if (existingSubschema != null) {\n            delegationMap.get(existingSubschema).push(fieldNode);\n        }\n        else {\n            delegationMap.set(nonUniqueSubschemas[0], [fieldNode]);\n        }\n    });\n    const finalDelegationMap = new Map();\n    delegationMap.forEach((selections, subschema) => {\n        finalDelegationMap.set(subschema, {\n            kind: Kind.SELECTION_SET,\n            selections,\n        });\n    });\n    return {\n        delegationMap: finalDelegationMap,\n        unproxiableFieldNodes,\n    };\n});\nconst combineSubschemas = memoize2(function (subschemaOrSubschemas, additionalSubschemas) {\n    return Array.isArray(subschemaOrSubschemas)\n        ? subschemaOrSubschemas.concat(additionalSubschemas)\n        : [subschemaOrSubschemas].concat(additionalSubschemas);\n});\nexport function mergeFields(mergedTypeInfo, typeName, object, fieldNodes, sourceSubschemaOrSourceSubschemas, targetSubschemas, context, info) {\n    if (!fieldNodes.length) {\n        return object;\n    }\n    const { proxiableSubschemas, nonProxiableSubschemas } = sortSubschemasByProxiability(mergedTypeInfo, sourceSubschemaOrSourceSubschemas, targetSubschemas, fieldNodes);\n    const { delegationMap, unproxiableFieldNodes } = buildDelegationPlan(mergedTypeInfo, fieldNodes, proxiableSubschemas);\n    if (!delegationMap.size) {\n        return object;\n    }\n    let containsPromises = false;\n    const maybePromises = [];\n    delegationMap.forEach((selectionSet, s) => {\n        const maybePromise = s.merge[typeName].resolve(object, context, info, s, selectionSet);\n        maybePromises.push(maybePromise);\n        if (!containsPromises && isPromise(maybePromise)) {\n            containsPromises = true;\n        }\n    });\n    return containsPromises\n        ? Promise.all(maybePromises).then(results => mergeFields(mergedTypeInfo, typeName, mergeProxiedResults(object, ...results), unproxiableFieldNodes, combineSubschemas(sourceSubschemaOrSourceSubschemas, proxiableSubschemas), nonProxiableSubschemas, context, info))\n        : mergeFields(mergedTypeInfo, typeName, mergeProxiedResults(object, ...maybePromises), unproxiableFieldNodes, combineSubschemas(sourceSubschemaOrSourceSubschemas, proxiableSubschemas), nonProxiableSubschemas, context, info);\n}\nconst subschemaTypesContainSelectionSet = memoize3(function (mergedTypeInfo, sourceSubschemaOrSourceSubschemas, selectionSet) {\n    if (Array.isArray(sourceSubschemaOrSourceSubschemas)) {\n        return typesContainSelectionSet(sourceSubschemaOrSourceSubschemas.map(sourceSubschema => sourceSubschema.schema.getType(mergedTypeInfo.typeName)), selectionSet);\n    }\n    return typesContainSelectionSet([sourceSubschemaOrSourceSubschemas.schema.getType(mergedTypeInfo.typeName)], selectionSet);\n});\n//# sourceMappingURL=mergeFields.js.map","import { collectFields } from '@graphql-tools/utils';\nimport { isSubschemaConfig } from '../Subschema';\nimport { memoizeInfoAnd2Objects } from '../memoize';\nfunction collectSubFields(info, typeName) {\n    let subFieldNodes = Object.create(null);\n    const visitedFragmentNames = Object.create(null);\n    const type = info.schema.getType(typeName);\n    const partialExecutionContext = {\n        schema: info.schema,\n        variableValues: info.variableValues,\n        fragments: info.fragments,\n    };\n    info.fieldNodes.forEach(fieldNode => {\n        subFieldNodes = collectFields(partialExecutionContext, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n    });\n    const stitchingInfo = info.schema.extensions.stitchingInfo;\n    const selectionSetsByField = stitchingInfo.selectionSetsByField;\n    Object.keys(subFieldNodes).forEach(responseName => {\n        var _a;\n        const fieldName = subFieldNodes[responseName][0].name.value;\n        const fieldSelectionSet = (_a = selectionSetsByField === null || selectionSetsByField === void 0 ? void 0 : selectionSetsByField[typeName]) === null || _a === void 0 ? void 0 : _a[fieldName];\n        if (fieldSelectionSet != null) {\n            subFieldNodes = collectFields(partialExecutionContext, type, fieldSelectionSet, subFieldNodes, visitedFragmentNames);\n        }\n    });\n    return subFieldNodes;\n}\nexport const getFieldsNotInSubschema = memoizeInfoAnd2Objects(function (info, subschema, mergedTypeInfo) {\n    const typeMap = isSubschemaConfig(subschema) ? mergedTypeInfo.typeMaps.get(subschema) : subschema.getTypeMap();\n    const typeName = mergedTypeInfo.typeName;\n    const fields = typeMap[typeName].getFields();\n    const subFieldNodes = collectSubFields(info, typeName);\n    let fieldsNotInSchema = [];\n    Object.keys(subFieldNodes).forEach(responseName => {\n        const fieldName = subFieldNodes[responseName][0].name.value;\n        if (!(fieldName in fields)) {\n            fieldsNotInSchema = fieldsNotInSchema.concat(subFieldNodes[responseName]);\n        }\n    });\n    return fieldsNotInSchema;\n});\n//# sourceMappingURL=getFieldsNotInSubschema.js.map","import { isAbstractType } from 'graphql';\nimport { setErrors, slicedError } from '@graphql-tools/utils';\nimport { setObjectSubschema } from '../Subschema';\nimport { mergeFields } from './mergeFields';\nimport { getFieldsNotInSubschema } from './getFieldsNotInSubschema';\nexport function handleObject(type, object, errors, subschema, context, info, skipTypeMerging) {\n    var _a;\n    const stitchingInfo = (_a = info === null || info === void 0 ? void 0 : info.schema.extensions) === null || _a === void 0 ? void 0 : _a.stitchingInfo;\n    setErrors(object, errors.map(error => slicedError(error)));\n    setObjectSubschema(object, subschema);\n    if (skipTypeMerging || !stitchingInfo) {\n        return object;\n    }\n    const typeName = isAbstractType(type) ? info.schema.getTypeMap()[object.__typename].name : type.name;\n    const mergedTypeInfo = stitchingInfo.mergedTypes[typeName];\n    let targetSubschemas;\n    if (mergedTypeInfo != null) {\n        targetSubschemas = mergedTypeInfo.targetSubschemas.get(subschema);\n    }\n    if (!targetSubschemas) {\n        return object;\n    }\n    const fieldNodes = getFieldsNotInSubschema(info, subschema, mergedTypeInfo);\n    return mergeFields(mergedTypeInfo, typeName, object, fieldNodes, subschema, targetSubschemas, context, info);\n}\n//# sourceMappingURL=handleObject.js.map","import { getNullableType, isLeafType, isCompositeType, isListType, } from 'graphql';\nimport { getErrorsByPathSegment } from '@graphql-tools/utils';\nimport { handleNull } from './handleNull';\nimport { handleObject } from './handleObject';\nexport function handleList(type, list, errors, subschema, context, info, skipTypeMerging) {\n    const childErrors = getErrorsByPathSegment(errors);\n    return list.map((listMember, index) => handleListMember(getNullableType(type.ofType), listMember, index in childErrors ? childErrors[index] : [], subschema, context, info, skipTypeMerging));\n}\nfunction handleListMember(type, listMember, errors, subschema, context, info, skipTypeMerging) {\n    if (listMember == null) {\n        return handleNull(errors);\n    }\n    if (isLeafType(type)) {\n        return type.parseValue(listMember);\n    }\n    else if (isCompositeType(type)) {\n        return handleObject(type, listMember, errors, subschema, context, info, skipTypeMerging);\n    }\n    else if (isListType(type)) {\n        return handleList(type, listMember, errors, subschema, context, info, skipTypeMerging);\n    }\n}\n//# sourceMappingURL=handleList.js.map","import { getNullableType, isCompositeType, isLeafType, isListType, } from 'graphql';\nimport { handleNull } from './handleNull';\nimport { handleObject } from './handleObject';\nimport { handleList } from './handleList';\nexport function handleResult(result, errors, subschema, context, info, returnType = info.returnType, skipTypeMerging) {\n    const type = getNullableType(returnType);\n    if (result == null) {\n        return handleNull(errors);\n    }\n    if (isLeafType(type)) {\n        return type.parseValue(result);\n    }\n    else if (isCompositeType(type)) {\n        return handleObject(type, result, errors, subschema, context, info, skipTypeMerging);\n    }\n    else if (isListType(type)) {\n        return handleList(type, result, errors, subschema, context, info, skipTypeMerging);\n    }\n}\n//# sourceMappingURL=handleResult.js.map","import { getResponseKeyFromInfo } from '@graphql-tools/utils';\nimport { handleResult } from '../results/handleResult';\nexport default class CheckResultAndHandleErrors {\n    constructor(info, fieldName, subschema, context, returnType = info.returnType, typeMerge) {\n        this.context = context;\n        this.info = info;\n        this.fieldName = fieldName;\n        this.subschema = subschema;\n        this.returnType = returnType;\n        this.typeMerge = typeMerge;\n    }\n    transformResult(result) {\n        return checkResultAndHandleErrors(result, this.context != null ? this.context : {}, this.info, this.fieldName, this.subschema, this.returnType, this.typeMerge);\n    }\n}\nexport function checkResultAndHandleErrors(result, context, info, responseKey = getResponseKeyFromInfo(info), subschema, returnType = info.returnType, skipTypeMerging) {\n    const errors = result.errors != null ? result.errors : [];\n    const data = result.data != null ? result.data[responseKey] : undefined;\n    return handleResult(data, errors, subschema, context, info, returnType, skipTypeMerging);\n}\n//# sourceMappingURL=CheckResultAndHandleErrors.js.map","import { Kind, } from 'graphql';\nimport { serializeInputValue, updateArgument } from '@graphql-tools/utils';\nexport default class AddArgumentsAsVariables {\n    constructor(targetSchema, args) {\n        this.targetSchema = targetSchema;\n        this.args = Object.entries(args).reduce((prev, [key, val]) => ({\n            ...prev,\n            [key]: val,\n        }), {});\n    }\n    transformRequest(originalRequest) {\n        const { document, variables } = addVariablesToRootField(this.targetSchema, originalRequest, this.args);\n        return {\n            ...originalRequest,\n            document,\n            variables,\n        };\n    }\n}\nfunction addVariablesToRootField(targetSchema, originalRequest, args) {\n    const document = originalRequest.document;\n    const variableValues = originalRequest.variables;\n    const operations = document.definitions.filter(def => def.kind === Kind.OPERATION_DEFINITION);\n    const fragments = document.definitions.filter(def => def.kind === Kind.FRAGMENT_DEFINITION);\n    const newOperations = operations.map((operation) => {\n        const variableDefinitionMap = operation.variableDefinitions.reduce((prev, def) => ({\n            ...prev,\n            [def.variable.name.value]: def,\n        }), {});\n        let type;\n        if (operation.operation === 'subscription') {\n            type = targetSchema.getSubscriptionType();\n        }\n        else if (operation.operation === 'mutation') {\n            type = targetSchema.getMutationType();\n        }\n        else {\n            type = targetSchema.getQueryType();\n        }\n        const newSelectionSet = [];\n        operation.selectionSet.selections.forEach((selection) => {\n            if (selection.kind === Kind.FIELD) {\n                const argumentNodes = selection.arguments;\n                const argumentNodeMap = argumentNodes.reduce((prev, argument) => ({\n                    ...prev,\n                    [argument.name.value]: argument,\n                }), {});\n                const targetField = type.getFields()[selection.name.value];\n                // excludes __typename\n                if (targetField != null) {\n                    updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, args);\n                }\n                newSelectionSet.push({\n                    ...selection,\n                    arguments: Object.keys(argumentNodeMap).map(argName => argumentNodeMap[argName]),\n                });\n            }\n            else {\n                newSelectionSet.push(selection);\n            }\n        });\n        return {\n            ...operation,\n            variableDefinitions: Object.keys(variableDefinitionMap).map(varName => variableDefinitionMap[varName]),\n            selectionSet: {\n                kind: Kind.SELECTION_SET,\n                selections: newSelectionSet,\n            },\n        };\n    });\n    return {\n        document: {\n            ...document,\n            definitions: [...newOperations, ...fragments],\n        },\n        variables: variableValues,\n    };\n}\nfunction updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, newArgs) {\n    targetField.args.forEach((argument) => {\n        const argName = argument.name;\n        const argType = argument.type;\n        if (argName in newArgs) {\n            updateArgument(argName, argType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(argType, newArgs[argName]));\n        }\n    });\n}\n//# sourceMappingURL=AddArgumentsAsVariables.js.map","import AddSelectionSets from './transforms/AddSelectionSets';\nimport ExpandAbstractTypes from './transforms/ExpandAbstractTypes';\nimport WrapConcreteTypes from './transforms/WrapConcreteTypes';\nimport FilterToSchema from './transforms/FilterToSchema';\nimport AddFragmentsByField from './transforms/AddFragmentsByField';\nimport AddTypenameToAbstract from './transforms/AddTypenameToAbstract';\nimport CheckResultAndHandleErrors from './transforms/CheckResultAndHandleErrors';\nimport AddArgumentsAsVariables from './transforms/AddArgumentsAsVariables';\nexport function defaultDelegationBinding(delegationContext) {\n    var _a;\n    const { subschema: schemaOrSubschemaConfig, targetSchema, fieldName, args, context, info, returnType, transforms = [], skipTypeMerging, } = delegationContext;\n    const stitchingInfo = (_a = info === null || info === void 0 ? void 0 : info.schema.extensions) === null || _a === void 0 ? void 0 : _a.stitchingInfo;\n    let transformedSchema = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.transformedSchemas.get(schemaOrSubschemaConfig);\n    if (transformedSchema != null) {\n        delegationContext.transformedSchema = transformedSchema;\n    }\n    else {\n        transformedSchema = delegationContext.transformedSchema;\n    }\n    let delegationTransforms = [\n        new CheckResultAndHandleErrors(info, fieldName, schemaOrSubschemaConfig, context, returnType, skipTypeMerging),\n    ];\n    if (stitchingInfo != null) {\n        delegationTransforms = delegationTransforms.concat([\n            new AddSelectionSets(info.schema, returnType, {}, stitchingInfo.selectionSetsByField, stitchingInfo.dynamicSelectionSetsByField),\n            new WrapConcreteTypes(returnType, transformedSchema),\n            new ExpandAbstractTypes(info.schema, transformedSchema),\n        ]);\n    }\n    else if (info != null) {\n        delegationTransforms = delegationTransforms.concat([\n            new WrapConcreteTypes(returnType, transformedSchema),\n            new ExpandAbstractTypes(info.schema, transformedSchema),\n        ]);\n    }\n    else {\n        delegationTransforms.push(new WrapConcreteTypes(returnType, transformedSchema));\n    }\n    delegationTransforms = delegationTransforms.concat(transforms.slice().reverse());\n    if (stitchingInfo != null) {\n        delegationTransforms.push(new AddFragmentsByField(targetSchema, stitchingInfo.fragmentsByField));\n    }\n    if (args != null) {\n        delegationTransforms.push(new AddArgumentsAsVariables(targetSchema, args));\n    }\n    delegationTransforms = delegationTransforms.concat([\n        new FilterToSchema(targetSchema),\n        new AddTypenameToAbstract(targetSchema),\n    ]);\n    return delegationTransforms;\n}\n//# sourceMappingURL=delegationBindings.js.map","import { defaultDelegationBinding } from './delegationBindings';\nexport class Transformer {\n    constructor(context, binding = defaultDelegationBinding) {\n        this.transformations = [];\n        this.delegationContext = context;\n        const delegationTransforms = binding(this.delegationContext);\n        delegationTransforms.forEach(transform => this.addTransform(transform, {}));\n    }\n    addTransform(transform, context = {}) {\n        this.transformations.push({ transform, context });\n    }\n    transformRequest(originalRequest) {\n        return this.transformations.reduce((request, transformation) => transformation.transform.transformRequest != null\n            ? transformation.transform.transformRequest(request, this.delegationContext, transformation.context)\n            : request, originalRequest);\n    }\n    transformResult(originalResult) {\n        return this.transformations.reduceRight((result, transformation) => transformation.transform.transformResult != null\n            ? transformation.transform.transformResult(result, this.delegationContext, transformation.context)\n            : result, originalResult);\n    }\n}\n//# sourceMappingURL=Transformer.js.map","// adapted from https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-source-graphql/src/batching/merge-queries.js\nexport function createPrefix(index) {\n    return `graphqlTools${index}_`;\n}\nexport function parseKey(prefixedKey) {\n    const match = /^graphqlTools([\\d]+)_(.*)$/.exec(prefixedKey);\n    if (match && match.length === 3 && !isNaN(Number(match[1])) && match[2]) {\n        return { index: Number(match[1]), originalKey: match[2] };\n    }\n    return null;\n}\n//# sourceMappingURL=prefix.js.map","// adapted from https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-source-graphql/src/batching/merge-queries.js\nimport { visit, Kind, } from 'graphql';\nimport { createPrefix } from './prefix';\n/**\n * Merge multiple queries into a single query in such a way that query results\n * can be split and transformed as if they were obtained by running original queries.\n *\n * Merging algorithm involves several transformations:\n *  1. Replace top-level fragment spreads with inline fragments (... on Query {})\n *  2. Add unique aliases to all top-level query fields (including those on inline fragments)\n *  3. Prefix all variable definitions and variable usages\n *  4. Prefix names (and spreads) of fragments\n *\n * i.e transform:\n *   [\n *     `query Foo($id: ID!) { foo, bar(id: $id), ...FooQuery }\n *     fragment FooQuery on Query { baz }`,\n *\n *    `query Bar($id: ID!) { foo: baz, bar(id: $id), ... on Query { baz } }`\n *   ]\n * to:\n *   query (\n *     $graphqlTools1_id: ID!\n *     $graphqlTools2_id: ID!\n *   ) {\n *     graphqlTools1_foo: foo,\n *     graphqlTools1_bar: bar(id: $graphqlTools1_id)\n *     ... on Query {\n *       graphqlTools1__baz: baz\n *     }\n *     graphqlTools1__foo: baz\n *     graphqlTools1__bar: bar(id: $graphqlTools1__id)\n *     ... on Query {\n *       graphqlTools1__baz: baz\n *     }\n *   }\n */\nexport function mergeExecutionParams(execs, extensionsReducer) {\n    const mergedVariables = Object.create(null);\n    const mergedVariableDefinitions = [];\n    const mergedSelections = [];\n    const mergedFragmentDefinitions = [];\n    let mergedExtensions = Object.create(null);\n    let operation;\n    execs.forEach((executionParams, index) => {\n        const prefixedExecutionParams = prefixExecutionParams(createPrefix(index), executionParams);\n        prefixedExecutionParams.document.definitions.forEach(def => {\n            var _a;\n            if (isOperationDefinition(def)) {\n                operation = def.operation;\n                mergedSelections.push(...def.selectionSet.selections);\n                mergedVariableDefinitions.push(...((_a = def.variableDefinitions) !== null && _a !== void 0 ? _a : []));\n            }\n            if (isFragmentDefinition(def)) {\n                mergedFragmentDefinitions.push(def);\n            }\n        });\n        Object.assign(mergedVariables, prefixedExecutionParams.variables);\n        mergedExtensions = extensionsReducer(mergedExtensions, executionParams);\n    });\n    const mergedOperationDefinition = {\n        kind: Kind.OPERATION_DEFINITION,\n        operation,\n        variableDefinitions: mergedVariableDefinitions,\n        selectionSet: {\n            kind: Kind.SELECTION_SET,\n            selections: mergedSelections,\n        },\n    };\n    return {\n        document: {\n            kind: Kind.DOCUMENT,\n            definitions: [mergedOperationDefinition, ...mergedFragmentDefinitions],\n        },\n        variables: mergedVariables,\n        extensions: mergedExtensions,\n        context: execs[0].context,\n        info: execs[0].info,\n    };\n}\nfunction prefixExecutionParams(prefix, executionParams) {\n    let document = aliasTopLevelFields(prefix, executionParams.document);\n    const variableNames = Object.keys(executionParams.variables);\n    if (variableNames.length === 0) {\n        return { ...executionParams, document };\n    }\n    document = visit(document, {\n        [Kind.VARIABLE]: (node) => prefixNodeName(node, prefix),\n        [Kind.FRAGMENT_DEFINITION]: (node) => prefixNodeName(node, prefix),\n        [Kind.FRAGMENT_SPREAD]: (node) => prefixNodeName(node, prefix),\n    });\n    const prefixedVariables = variableNames.reduce((acc, name) => {\n        acc[prefix + name] = executionParams.variables[name];\n        return acc;\n    }, Object.create(null));\n    return {\n        document,\n        variables: prefixedVariables,\n    };\n}\n/**\n * Adds prefixed aliases to top-level fields of the query.\n *\n * @see aliasFieldsInSelection for implementation details\n */\nfunction aliasTopLevelFields(prefix, document) {\n    const transformer = {\n        [Kind.OPERATION_DEFINITION]: (def) => {\n            const { selections } = def.selectionSet;\n            return {\n                ...def,\n                selectionSet: {\n                    ...def.selectionSet,\n                    selections: aliasFieldsInSelection(prefix, selections, document),\n                },\n            };\n        },\n    };\n    return visit(document, transformer, { [Kind.DOCUMENT]: [`definitions`] });\n}\n/**\n * Add aliases to fields of the selection, including top-level fields of inline fragments.\n * Fragment spreads are converted to inline fragments and their top-level fields are also aliased.\n *\n * Note that this method is shallow. It adds aliases only to the top-level fields and doesn't\n * descend to field sub-selections.\n *\n * For example, transforms:\n *   {\n *     foo\n *     ... on Query { foo }\n *     ...FragmentWithBarField\n *   }\n * To:\n *   {\n *     graphqlTools1_foo: foo\n *     ... on Query { graphqlTools1_foo: foo }\n *     ... on Query { graphqlTools1_bar: bar }\n *   }\n */\nfunction aliasFieldsInSelection(prefix, selections, document) {\n    return selections.map(selection => {\n        switch (selection.kind) {\n            case Kind.INLINE_FRAGMENT:\n                return aliasFieldsInInlineFragment(prefix, selection, document);\n            case Kind.FRAGMENT_SPREAD: {\n                const inlineFragment = inlineFragmentSpread(selection, document);\n                return aliasFieldsInInlineFragment(prefix, inlineFragment, document);\n            }\n            case Kind.FIELD:\n            default:\n                return aliasField(selection, prefix);\n        }\n    });\n}\n/**\n * Add aliases to top-level fields of the inline fragment.\n * Returns new inline fragment node.\n *\n * For Example, transforms:\n *   ... on Query { foo, ... on Query { bar: foo } }\n * To\n *   ... on Query { graphqlTools1_foo: foo, ... on Query { graphqlTools1_bar: foo } }\n */\nfunction aliasFieldsInInlineFragment(prefix, fragment, document) {\n    const { selections } = fragment.selectionSet;\n    return {\n        ...fragment,\n        selectionSet: {\n            ...fragment.selectionSet,\n            selections: aliasFieldsInSelection(prefix, selections, document),\n        },\n    };\n}\n/**\n * Replaces fragment spread with inline fragment\n *\n * Example:\n *   query { ...Spread }\n *   fragment Spread on Query { bar }\n *\n * Transforms to:\n *   query { ... on Query { bar } }\n */\nfunction inlineFragmentSpread(spread, document) {\n    const fragment = document.definitions.find(def => isFragmentDefinition(def) && def.name.value === spread.name.value);\n    if (!fragment) {\n        throw new Error(`Fragment ${spread.name.value} does not exist`);\n    }\n    const { typeCondition, selectionSet } = fragment;\n    return {\n        kind: Kind.INLINE_FRAGMENT,\n        typeCondition,\n        selectionSet,\n        directives: spread.directives,\n    };\n}\nfunction prefixNodeName(namedNode, prefix) {\n    return {\n        ...namedNode,\n        name: {\n            ...namedNode.name,\n            value: prefix + namedNode.name.value,\n        },\n    };\n}\n/**\n * Returns a new FieldNode with prefixed alias\n *\n * Example. Given prefix === \"graphqlTools1_\" transforms:\n *   { foo } -> { graphqlTools1_foo: foo }\n *   { foo: bar } -> { graphqlTools1_foo: bar }\n */\nfunction aliasField(field, aliasPrefix) {\n    const aliasNode = field.alias ? field.alias : field.name;\n    return {\n        ...field,\n        alias: {\n            ...aliasNode,\n            value: aliasPrefix + aliasNode.value,\n        },\n    };\n}\nfunction isOperationDefinition(def) {\n    return def.kind === Kind.OPERATION_DEFINITION;\n}\nfunction isFragmentDefinition(def) {\n    return def.kind === Kind.FRAGMENT_DEFINITION;\n}\n//# sourceMappingURL=mergeExecutionParams.js.map","// adapted from https://github.com/gatsbyjs/gatsby/blob/master/packages/gatsby-source-graphql/src/batching/merge-queries.js\nimport { relocatedError } from '@graphql-tools/utils';\nimport { parseKey } from './prefix';\n/**\n * Split and transform result of the query produced by the `merge` function\n */\nexport function splitResult(mergedResult, numResults) {\n    const splitResults = [];\n    for (let i = 0; i < numResults; i++) {\n        splitResults.push({});\n    }\n    const data = mergedResult.data;\n    if (data) {\n        Object.keys(data).forEach(prefixedKey => {\n            const { index, originalKey } = parseKey(prefixedKey);\n            if (!splitResults[index].data) {\n                splitResults[index].data = { [originalKey]: data[prefixedKey] };\n            }\n            else {\n                splitResults[index].data[originalKey] = data[prefixedKey];\n            }\n        });\n    }\n    const errors = mergedResult.errors;\n    if (errors) {\n        const newErrors = Object.create(null);\n        errors.forEach(error => {\n            if (error.path) {\n                const parsedKey = parseKey(error.path[0]);\n                if (parsedKey) {\n                    const { index, originalKey } = parsedKey;\n                    const newError = relocatedError(error, [originalKey, ...error.path.slice(1)]);\n                    if (!newErrors[index]) {\n                        newErrors[index] = [newError];\n                    }\n                    else {\n                        newErrors[index].push(newError);\n                    }\n                    return;\n                }\n            }\n            splitResults.forEach((_splitResult, index) => {\n                if (!newErrors[index]) {\n                    newErrors[index] = [error];\n                }\n                else {\n                    newErrors[index].push(error);\n                }\n            });\n        });\n        Object.keys(newErrors).forEach(index => {\n            splitResults[index].errors = newErrors[index];\n        });\n    }\n    return splitResults;\n}\n//# sourceMappingURL=splitResult.js.map","import { getOperationAST } from 'graphql';\nimport isPromise from 'is-promise';\nimport DataLoader from 'dataloader';\nimport { memoize2of3 } from './memoize';\nimport { mergeExecutionParams } from './mergeExecutionParams';\nimport { splitResult } from './splitResult';\nexport const getBatchingExecutor = memoize2of3(function (_context, endpoint, executor) {\n    var _a, _b, _c;\n    const loader = new DataLoader(createLoadFn(executor !== null && executor !== void 0 ? executor : endpoint.executor, (_b = (_a = endpoint.batchingOptions) === null || _a === void 0 ? void 0 : _a.extensionsReducer) !== null && _b !== void 0 ? _b : defaultExtensionsReducer), (_c = endpoint.batchingOptions) === null || _c === void 0 ? void 0 : _c.dataLoaderOptions);\n    return (executionParams) => loader.load(executionParams);\n});\nfunction createLoadFn(executor, extensionsReducer) {\n    return async (execs) => {\n        const execBatches = [];\n        let index = 0;\n        const exec = execs[index];\n        let currentBatch = [exec];\n        execBatches.push(currentBatch);\n        const operationType = getOperationAST(exec.document, undefined).operation;\n        while (++index < execs.length) {\n            const currentOperationType = getOperationAST(execs[index].document, undefined).operation;\n            if (operationType === currentOperationType) {\n                currentBatch.push(execs[index]);\n            }\n            else {\n                currentBatch = [execs[index]];\n                execBatches.push(currentBatch);\n            }\n        }\n        let containsPromises = false;\n        const executionResults = [];\n        execBatches.forEach(execBatch => {\n            const mergedExecutionParams = mergeExecutionParams(execBatch, extensionsReducer);\n            const executionResult = executor(mergedExecutionParams);\n            if (isPromise(executionResult)) {\n                containsPromises = true;\n            }\n            executionResults.push(executionResult);\n        });\n        if (containsPromises) {\n            return Promise.all(executionResults).then(resultBatches => {\n                let results = [];\n                resultBatches.forEach((resultBatch, index) => {\n                    results = results.concat(splitResult(resultBatch, execBatches[index].length));\n                });\n                return results;\n            });\n        }\n        let results = [];\n        executionResults.forEach((resultBatch, index) => {\n            results = results.concat(splitResult(resultBatch, execBatches[index].length));\n        });\n        return results;\n    };\n}\nfunction defaultExtensionsReducer(mergedExtensions, executionParams) {\n    const newExtensions = executionParams.extensions;\n    if (newExtensions != null) {\n        Object.assign(mergedExtensions, newExtensions);\n    }\n    return mergedExtensions;\n}\n//# sourceMappingURL=getBatchingExecutor.js.map","import { subscribe, execute, validate, isSchema, getOperationAST, } from 'graphql';\nimport isPromise from 'is-promise';\nimport { mapAsyncIterator } from '@graphql-tools/utils';\nimport { isSubschemaConfig } from './Subschema';\nimport { createRequestFromInfo, getDelegatingOperation } from './createRequest';\nimport { Transformer } from './Transformer';\nimport AggregateError from '@ardatan/aggregate-error';\nimport { getBatchingExecutor } from './getBatchingExecutor';\nexport function delegateToSchema(options) {\n    if (isSchema(options)) {\n        throw new Error('Passing positional arguments to delegateToSchema is deprecated. ' + 'Please pass named parameters instead.');\n    }\n    const { info, operationName, operation = getDelegatingOperation(info.parentType, info.schema), fieldName = info.fieldName, returnType = info.returnType, selectionSet, fieldNodes, } = options;\n    const request = createRequestFromInfo({\n        info,\n        operation,\n        fieldName,\n        selectionSet,\n        fieldNodes,\n        operationName,\n    });\n    return delegateRequest({\n        ...options,\n        request,\n        operation,\n        fieldName,\n        returnType,\n    });\n}\nfunction getDelegationReturnType(targetSchema, operation, fieldName) {\n    let rootType;\n    if (operation === 'query') {\n        rootType = targetSchema.getQueryType();\n    }\n    else if (operation === 'mutation') {\n        rootType = targetSchema.getMutationType();\n    }\n    else {\n        rootType = targetSchema.getSubscriptionType();\n    }\n    return rootType.getFields()[fieldName].type;\n}\nexport function delegateRequest({ request, schema: subschemaOrSubschemaConfig, rootValue, info, operation, fieldName, args, returnType, context, transforms = [], transformedSchema, skipValidation, skipTypeMerging, binding, }) {\n    var _a, _b, _c;\n    let operationDefinition;\n    let targetOperation;\n    let targetFieldName;\n    if (operation == null) {\n        operationDefinition = getOperationAST(request.document, undefined);\n        targetOperation = operationDefinition.operation;\n    }\n    else {\n        targetOperation = operation;\n    }\n    if (fieldName == null) {\n        operationDefinition = operationDefinition !== null && operationDefinition !== void 0 ? operationDefinition : getOperationAST(request.document, undefined);\n        targetFieldName = operationDefinition.selectionSet.selections[0].name.value;\n    }\n    else {\n        targetFieldName = fieldName;\n    }\n    let targetSchema;\n    let targetRootValue;\n    let subschemaConfig;\n    let endpoint;\n    let allTransforms;\n    if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\n        subschemaConfig = subschemaOrSubschemaConfig;\n        targetSchema = subschemaConfig.schema;\n        allTransforms =\n            subschemaOrSubschemaConfig.transforms != null\n                ? subschemaOrSubschemaConfig.transforms.concat(transforms)\n                : transforms;\n        if (typeof subschemaConfig.endpoint === 'object') {\n            endpoint = subschemaConfig.endpoint;\n        }\n        else if (typeof subschemaConfig.endpoint === 'string') {\n            const stitchingInfo = (_a = info === null || info === void 0 ? void 0 : info.schema.extensions) === null || _a === void 0 ? void 0 : _a.stitchingInfo;\n            endpoint = stitchingInfo.endpoints[subschemaConfig.endpoint];\n        }\n        else {\n            endpoint = subschemaConfig;\n        }\n        targetRootValue = (_b = rootValue !== null && rootValue !== void 0 ? rootValue : endpoint === null || endpoint === void 0 ? void 0 : endpoint.rootValue) !== null && _b !== void 0 ? _b : info === null || info === void 0 ? void 0 : info.rootValue;\n    }\n    else {\n        targetSchema = subschemaOrSubschemaConfig;\n        targetRootValue = rootValue !== null && rootValue !== void 0 ? rootValue : info === null || info === void 0 ? void 0 : info.rootValue;\n        allTransforms = transforms;\n    }\n    const delegationContext = {\n        subschema: subschemaOrSubschemaConfig,\n        targetSchema,\n        operation: targetOperation,\n        fieldName: targetFieldName,\n        args,\n        context,\n        info,\n        returnType: (_c = returnType !== null && returnType !== void 0 ? returnType : info === null || info === void 0 ? void 0 : info.returnType) !== null && _c !== void 0 ? _c : getDelegationReturnType(targetSchema, targetOperation, targetFieldName),\n        transforms: allTransforms,\n        transformedSchema: transformedSchema !== null && transformedSchema !== void 0 ? transformedSchema : targetSchema,\n        skipTypeMerging,\n    };\n    const transformer = new Transformer(delegationContext, binding);\n    const processedRequest = transformer.transformRequest(request);\n    if (!skipValidation) {\n        validateRequest(targetSchema, processedRequest.document);\n    }\n    if (targetOperation === 'query' || targetOperation === 'mutation') {\n        let executor = (endpoint === null || endpoint === void 0 ? void 0 : endpoint.executor) || createDefaultExecutor(targetSchema, (subschemaConfig === null || subschemaConfig === void 0 ? void 0 : subschemaConfig.rootValue) || targetRootValue);\n        if (endpoint === null || endpoint === void 0 ? void 0 : endpoint.batch) {\n            executor = getBatchingExecutor(context, endpoint, executor);\n        }\n        const executionResult = executor({\n            ...processedRequest,\n            context,\n            info,\n        });\n        if (isPromise(executionResult)) {\n            return executionResult.then(originalResult => transformer.transformResult(originalResult));\n        }\n        return transformer.transformResult(executionResult);\n    }\n    const subscriber = (endpoint === null || endpoint === void 0 ? void 0 : endpoint.subscriber) || createDefaultSubscriber(targetSchema, (subschemaConfig === null || subschemaConfig === void 0 ? void 0 : subschemaConfig.rootValue) || targetRootValue);\n    return subscriber({\n        ...processedRequest,\n        context,\n        info,\n    }).then((subscriptionResult) => {\n        if (Symbol.asyncIterator in subscriptionResult) {\n            // \"subscribe\" to the subscription result and map the result through the transforms\n            return mapAsyncIterator(subscriptionResult, originalResult => ({\n                [targetFieldName]: transformer.transformResult(originalResult),\n            }));\n        }\n        return transformer.transformResult(subscriptionResult);\n    });\n}\nfunction validateRequest(targetSchema, document) {\n    const errors = validate(targetSchema, document);\n    if (errors.length > 0) {\n        if (errors.length > 1) {\n            const combinedError = new AggregateError(errors);\n            throw combinedError;\n        }\n        const error = errors[0];\n        throw error.originalError || error;\n    }\n}\nfunction createDefaultExecutor(schema, rootValue) {\n    return ({ document, context, variables, info }) => execute({\n        schema,\n        document,\n        contextValue: context,\n        variableValues: variables,\n        rootValue: rootValue !== null && rootValue !== void 0 ? rootValue : info === null || info === void 0 ? void 0 : info.rootValue,\n    });\n}\nfunction createDefaultSubscriber(schema, rootValue) {\n    return ({ document, context, variables, info }) => subscribe({\n        schema,\n        document,\n        contextValue: context,\n        variableValues: variables,\n        rootValue: rootValue !== null && rootValue !== void 0 ? rootValue : info === null || info === void 0 ? void 0 : info.rootValue,\n    });\n}\n//# sourceMappingURL=delegateToSchema.js.map","import { defaultFieldResolver } from 'graphql';\nimport { getResponseKeyFromInfo, getErrors } from '@graphql-tools/utils';\nimport { handleResult } from './results/handleResult';\nimport { getSubschema } from './Subschema';\n/**\n * Resolver that knows how to:\n * a) handle aliases for proxied schemas\n * b) handle errors from proxied schemas\n * c) handle external to internal enum coversion\n */\nexport function defaultMergedResolver(parent, args, context, info) {\n    if (!parent) {\n        return null;\n    }\n    const responseKey = getResponseKeyFromInfo(info);\n    const errors = getErrors(parent, responseKey);\n    // check to see if parent is not a proxied result, i.e. if parent resolver was manually overwritten\n    // See https://github.com/apollographql/graphql-tools/issues/967\n    if (!errors) {\n        return defaultFieldResolver(parent, args, context, info);\n    }\n    const result = parent[responseKey];\n    const subschema = getSubschema(parent, responseKey);\n    return handleResult(result, errors, subschema, context, info);\n}\n//# sourceMappingURL=defaultMergedResolver.js.map","import { getErrors, setErrors, relocatedError, ERROR_SYMBOL } from '@graphql-tools/utils';\nimport { OBJECT_SUBSCHEMA_SYMBOL } from './symbols';\nimport { getSubschema, setObjectSubschema } from './Subschema';\nimport { defaultMergedResolver } from './defaultMergedResolver';\nimport { handleNull } from './results/handleNull';\nfunction unwrapResult(parent, path) {\n    let newParent = parent;\n    const pathLength = path.length;\n    for (let i = 0; i < pathLength; i++) {\n        const responseKey = path[i];\n        const errors = getErrors(newParent, responseKey);\n        const subschema = getSubschema(newParent, responseKey);\n        const object = newParent[responseKey];\n        if (object == null) {\n            return handleNull(errors);\n        }\n        setErrors(object, errors.map(error => relocatedError(error, error.path != null ? error.path.slice(1) : undefined)));\n        setObjectSubschema(object, subschema);\n        newParent = object;\n    }\n    return newParent;\n}\nfunction dehoistResult(parent, delimeter = '__gqltf__') {\n    const result = Object.create(null);\n    Object.keys(parent).forEach(alias => {\n        let obj = result;\n        const fieldNames = alias.split(delimeter);\n        const fieldName = fieldNames.pop();\n        fieldNames.forEach(key => {\n            obj = obj[key] = obj[key] || Object.create(null);\n        });\n        obj[fieldName] = parent[alias];\n    });\n    result[ERROR_SYMBOL] = parent[ERROR_SYMBOL].map((error) => {\n        if (error.path != null) {\n            const path = error.path.slice();\n            const pathSegment = path.shift();\n            const expandedPathSegment = pathSegment.split(delimeter);\n            return relocatedError(error, expandedPathSegment.concat(path));\n        }\n        return error;\n    });\n    result[OBJECT_SUBSCHEMA_SYMBOL] = parent[OBJECT_SUBSCHEMA_SYMBOL];\n    return result;\n}\nexport function createMergedResolver({ fromPath, dehoist, delimeter = '__gqltf__', }) {\n    const parentErrorResolver = (parent, args, context, info) => parent instanceof Error ? parent : defaultMergedResolver(parent, args, context, info);\n    const unwrappingResolver = fromPath != null\n        ? (parent, args, context, info) => parentErrorResolver(unwrapResult(parent, fromPath), args, context, info)\n        : parentErrorResolver;\n    const dehoistingResolver = dehoist\n        ? (parent, args, context, info) => unwrappingResolver(dehoistResult(parent, delimeter), args, context, info)\n        : unwrappingResolver;\n    const noParentResolver = (parent, args, context, info) => parent ? dehoistingResolver(parent, args, context, info) : {};\n    return noParentResolver;\n}\n//# sourceMappingURL=createMergedResolver.js.map","import { Kind, TypeInfo, visit, visitWithTypeInfo, } from 'graphql';\nexport default class AddSelectionSetsByField {\n    constructor(schema, mapping) {\n        this.schema = schema;\n        this.mapping = mapping;\n    }\n    transformRequest(originalRequest) {\n        const document = addSelectionSetsByField(this.schema, originalRequest.document, this.mapping);\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n}\nfunction addSelectionSetsByField(schema, document, mapping) {\n    const typeInfo = new TypeInfo(schema);\n    return visit(document, visitWithTypeInfo(typeInfo, {\n        [Kind.SELECTION_SET](node) {\n            const parentType = typeInfo.getParentType();\n            if (parentType != null) {\n                const parentTypeName = parentType.name;\n                let selections = node.selections;\n                if (parentTypeName in mapping) {\n                    node.selections.forEach(selection => {\n                        if (selection.kind === Kind.FIELD) {\n                            const name = selection.name.value;\n                            const selectionSet = mapping[parentTypeName][name];\n                            if (selectionSet != null) {\n                                selections = selections.concat(selectionSet.selections);\n                            }\n                        }\n                    });\n                }\n                if (selections !== node.selections) {\n                    return {\n                        ...node,\n                        selections,\n                    };\n                }\n            }\n        },\n    }));\n}\n//# sourceMappingURL=AddSelectionSetsByField.js.map","import { Kind, TypeInfo, visit, visitWithTypeInfo, } from 'graphql';\nexport default class AddSelectionSetsByType {\n    constructor(targetSchema, mapping) {\n        this.targetSchema = targetSchema;\n        this.mapping = mapping;\n    }\n    transformRequest(originalRequest) {\n        const document = addSelectionSetsByType(this.targetSchema, originalRequest.document, this.mapping);\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n}\nfunction addSelectionSetsByType(targetSchema, document, mapping) {\n    const typeInfo = new TypeInfo(targetSchema);\n    return visit(document, visitWithTypeInfo(typeInfo, {\n        [Kind.SELECTION_SET](node) {\n            const parentType = typeInfo.getParentType();\n            if (parentType != null) {\n                const parentTypeName = parentType.name;\n                let selections = node.selections;\n                if (parentTypeName in mapping) {\n                    const selectionSet = mapping[parentTypeName];\n                    if (selectionSet != null) {\n                        selections = selections.concat(selectionSet.selections);\n                    }\n                }\n                if (selections !== node.selections) {\n                    return {\n                        ...node,\n                        selections,\n                    };\n                }\n            }\n        },\n    }));\n}\n//# sourceMappingURL=AddSelectionSetsByType.js.map","import { Kind, TypeInfo, parse, visit, visitWithTypeInfo, } from 'graphql';\nimport { concatInlineFragments } from '@graphql-tools/utils';\nexport default class ReplaceFieldWithFragment {\n    constructor(targetSchema, fragments) {\n        this.targetSchema = targetSchema;\n        this.mapping = {};\n        for (const { field, fragment } of fragments) {\n            const parsedFragment = parseFragmentToInlineFragment(fragment);\n            const actualTypeName = parsedFragment.typeCondition.name.value;\n            if (!(actualTypeName in this.mapping)) {\n                this.mapping[actualTypeName] = Object.create(null);\n            }\n            const typeMapping = this.mapping[actualTypeName];\n            if (!(field in typeMapping)) {\n                typeMapping[field] = [parsedFragment];\n            }\n            else {\n                typeMapping[field].push(parsedFragment);\n            }\n        }\n    }\n    transformRequest(originalRequest) {\n        const document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n}\nfunction replaceFieldsWithFragments(targetSchema, document, mapping) {\n    const typeInfo = new TypeInfo(targetSchema);\n    return visit(document, visitWithTypeInfo(typeInfo, {\n        [Kind.SELECTION_SET](node) {\n            const parentType = typeInfo.getParentType();\n            if (parentType != null) {\n                const parentTypeName = parentType.name;\n                let selections = node.selections;\n                if (parentTypeName in mapping) {\n                    node.selections.forEach(selection => {\n                        if (selection.kind === Kind.FIELD) {\n                            const name = selection.name.value;\n                            const fragments = mapping[parentTypeName][name];\n                            if (fragments != null && fragments.length > 0) {\n                                const fragment = concatInlineFragments(parentTypeName, fragments);\n                                selections = selections.concat(fragment);\n                            }\n                        }\n                    });\n                }\n                if (selections !== node.selections) {\n                    return {\n                        ...node,\n                        selections,\n                    };\n                }\n            }\n        },\n    }));\n}\nfunction parseFragmentToInlineFragment(definitions) {\n    if (definitions.trim().startsWith('fragment')) {\n        const document = parse(definitions);\n        for (const definition of document.definitions) {\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n                return {\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: definition.typeCondition,\n                    selectionSet: definition.selectionSet,\n                };\n            }\n        }\n    }\n    const query = parse(`{${definitions}}`).definitions[0];\n    for (const selection of query.selectionSet.selections) {\n        if (selection.kind === Kind.INLINE_FRAGMENT) {\n            return selection;\n        }\n    }\n    throw new Error('Could not parse fragment');\n}\n//# sourceMappingURL=ReplaceFieldWithFragment.js.map"]},"metadata":{},"sourceType":"module"}