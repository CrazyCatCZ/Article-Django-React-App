{"ast":null,"code":"import { parseGraphQLSDL, parseGraphQLJSON } from '@graphql-tools/utils';\nimport { fetch } from 'cross-fetch';\nimport { gqlPluckFromCodeString } from '@graphql-tools/graphql-tag-pluck'; // github:owner/name#ref:path/to/file\n\nfunction extractData(pointer) {\n  const [repo, file] = pointer.split('#');\n  const [owner, name] = repo.split(':')[1].split('/');\n  const [ref, path] = file.split(':');\n  return {\n    owner,\n    name,\n    ref,\n    path\n  };\n}\n/**\n * This loader loads a file from GitHub.\n *\n * ```js\n * const typeDefs = await loadTypedefs('github:githubUser/githubRepo#branchName:path/to/file.ts', {\n *   loaders: [new GithubLoader()],\n *   token: YOUR_GITHUB_TOKEN,\n * })\n * ```\n */\n\n\nclass GithubLoader {\n  loaderId() {\n    return 'github-loader';\n  }\n\n  async canLoad(pointer) {\n    return typeof pointer === 'string' && pointer.toLowerCase().startsWith('github:');\n  }\n\n  canLoadSync() {\n    return false;\n  }\n\n  async load(pointer, options) {\n    const {\n      owner,\n      name,\n      ref,\n      path\n    } = extractData(pointer);\n    const request = await fetch('https://api.github.com/graphql', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json; charset=utf-8',\n        Authorization: `bearer ${options.token}`\n      },\n      body: JSON.stringify({\n        query: `\n          query GetGraphQLSchemaForGraphQLtools($owner: String!, $name: String!, $expression: String!) {\n            repository(owner: $owner, name: $name) {\n              object(expression: $expression) {\n                ... on Blob {\n                  text\n                }\n              }\n            }\n          }\n        `,\n        variables: {\n          owner,\n          name,\n          expression: ref + ':' + path\n        },\n        operationName: 'GetGraphQLSchemaForGraphQLtools'\n      })\n    });\n    const response = await request.json();\n    let errorMessage = null;\n\n    if (response.errors && response.errors.length > 0) {\n      errorMessage = response.errors.map(item => item.message).join(', ');\n    } else if (!response.data) {\n      errorMessage = response;\n    }\n\n    if (errorMessage) {\n      throw new Error('Unable to download schema from github: ' + errorMessage);\n    }\n\n    const content = response.data.repository.object.text;\n\n    if (/\\.(gql|graphql)s?$/i.test(path)) {\n      return parseGraphQLSDL(pointer, content, options);\n    }\n\n    if (/\\.json$/i.test(path)) {\n      return parseGraphQLJSON(pointer, content, options);\n    }\n\n    const rawSDL = await gqlPluckFromCodeString(pointer, content, options.pluckConfig);\n\n    if (rawSDL) {\n      return {\n        location: pointer,\n        rawSDL\n      };\n    }\n\n    throw new Error(`Invalid file extension: ${path}`);\n  }\n\n  loadSync() {\n    throw new Error('Loader GitHub has no sync mode');\n  }\n\n}\n\nexport { GithubLoader };","map":{"version":3,"sources":["../../../dist/loaders/github/src/index.js"],"names":[],"mappings":";;2EAGA;;AACA,SAAS,WAAT,CAAqB,OAArB,EAA8B;AAC1B,QAAM,CAAC,IAAD,EAAO,IAAP,IAAe,OAAO,CAAC,KAAR,CAAc,GAAd,CAArB;AACA,QAAM,CAAC,KAAD,EAAQ,IAAR,IAAgB,IAAI,CAAC,KAAL,CAAW,GAAX,EAAgB,CAAhB,EAAmB,KAAnB,CAAyB,GAAzB,CAAtB;AACA,QAAM,CAAC,GAAD,EAAM,IAAN,IAAc,IAAI,CAAC,KAAL,CAAW,GAAX,CAApB;AACA,SAAO;AACH,IAAA,KADG;AAEH,IAAA,IAFG;AAGH,IAAA,GAHG;AAIH,IAAA;AAJG,GAAP;AAMH;AACD;;;;;;;;;;;;AAUO,MAAM,YAAN,CAAmB;AACtB,EAAA,QAAQ,GAAG;AACP,WAAO,eAAP;AACH;;AACD,QAAM,OAAN,CAAc,OAAd,EAAuB;AACnB,WAAO,OAAO,OAAP,KAAmB,QAAnB,IAA+B,OAAO,CAAC,WAAR,GAAsB,UAAtB,CAAiC,SAAjC,CAAtC;AACH;;AACD,EAAA,WAAW,GAAG;AACV,WAAO,KAAP;AACH;;AACD,QAAM,IAAN,CAAW,OAAX,EAAoB,OAApB,EAA6B;AACzB,UAAM;AAAE,MAAA,KAAF;AAAS,MAAA,IAAT;AAAe,MAAA,GAAf;AAAoB,MAAA;AAApB,QAA6B,WAAW,CAAC,OAAD,CAA9C;AACA,UAAM,OAAO,GAAG,MAAM,KAAK,CAAC,gCAAD,EAAmC;AAC1D,MAAA,MAAM,EAAE,MADkD;AAE1D,MAAA,OAAO,EAAE;AACL,wBAAgB,iCADX;AAEL,QAAA,aAAa,EAAG,UAAS,OAAO,CAAC,KAAM;AAFlC,OAFiD;AAM1D,MAAA,IAAI,EAAE,IAAI,CAAC,SAAL,CAAe;AACjB,QAAA,KAAK,EAAG;;;;;;;;;;SADS;AAYjB,QAAA,SAAS,EAAE;AACP,UAAA,KADO;AAEP,UAAA,IAFO;AAGP,UAAA,UAAU,EAAE,GAAG,GAAG,GAAN,GAAY;AAHjB,SAZM;AAiBjB,QAAA,aAAa,EAAE;AAjBE,OAAf;AANoD,KAAnC,CAA3B;AA0BA,UAAM,QAAQ,GAAG,MAAM,OAAO,CAAC,IAAR,EAAvB;AACA,QAAI,YAAY,GAAG,IAAnB;;AACA,QAAI,QAAQ,CAAC,MAAT,IAAmB,QAAQ,CAAC,MAAT,CAAgB,MAAhB,GAAyB,CAAhD,EAAmD;AAC/C,MAAA,YAAY,GAAG,QAAQ,CAAC,MAAT,CAAgB,GAAhB,CAAqB,IAAD,IAAU,IAAI,CAAC,OAAnC,EAA4C,IAA5C,CAAiD,IAAjD,CAAf;AACH,KAFD,MAGK,IAAI,CAAC,QAAQ,CAAC,IAAd,EAAoB;AACrB,MAAA,YAAY,GAAG,QAAf;AACH;;AACD,QAAI,YAAJ,EAAkB;AACd,YAAM,IAAI,KAAJ,CAAU,4CAA4C,YAAtD,CAAN;AACH;;AACD,UAAM,OAAO,GAAG,QAAQ,CAAC,IAAT,CAAc,UAAd,CAAyB,MAAzB,CAAgC,IAAhD;;AACA,QAAI,sBAAsB,IAAtB,CAA2B,IAA3B,CAAJ,EAAsC;AAClC,aAAO,eAAe,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,CAAtB;AACH;;AACD,QAAI,WAAW,IAAX,CAAgB,IAAhB,CAAJ,EAA2B;AACvB,aAAO,gBAAgB,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAnB,CAAvB;AACH;;AACD,UAAM,MAAM,GAAG,MAAM,sBAAsB,CAAC,OAAD,EAAU,OAAV,EAAmB,OAAO,CAAC,WAA3B,CAA3C;;AACA,QAAI,MAAJ,EAAY;AACR,aAAO;AACH,QAAA,QAAQ,EAAE,OADP;AAEH,QAAA;AAFG,OAAP;AAIH;;AACD,UAAM,IAAI,KAAJ,CAAW,2BAA0B,IAAK,EAA1C,CAAN;AACH;;AACD,EAAA,QAAQ,GAAG;AACP,UAAM,IAAI,KAAJ,CAAU,gCAAV,CAAN;AACH;;AAnEqB","sourcesContent":["import { parseGraphQLSDL, parseGraphQLJSON } from '@graphql-tools/utils';\nimport { fetch } from 'cross-fetch';\nimport { gqlPluckFromCodeString } from '@graphql-tools/graphql-tag-pluck';\n// github:owner/name#ref:path/to/file\nfunction extractData(pointer) {\n    const [repo, file] = pointer.split('#');\n    const [owner, name] = repo.split(':')[1].split('/');\n    const [ref, path] = file.split(':');\n    return {\n        owner,\n        name,\n        ref,\n        path,\n    };\n}\n/**\n * This loader loads a file from GitHub.\n *\n * ```js\n * const typeDefs = await loadTypedefs('github:githubUser/githubRepo#branchName:path/to/file.ts', {\n *   loaders: [new GithubLoader()],\n *   token: YOUR_GITHUB_TOKEN,\n * })\n * ```\n */\nexport class GithubLoader {\n    loaderId() {\n        return 'github-loader';\n    }\n    async canLoad(pointer) {\n        return typeof pointer === 'string' && pointer.toLowerCase().startsWith('github:');\n    }\n    canLoadSync() {\n        return false;\n    }\n    async load(pointer, options) {\n        const { owner, name, ref, path } = extractData(pointer);\n        const request = await fetch('https://api.github.com/graphql', {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json; charset=utf-8',\n                Authorization: `bearer ${options.token}`,\n            },\n            body: JSON.stringify({\n                query: `\n          query GetGraphQLSchemaForGraphQLtools($owner: String!, $name: String!, $expression: String!) {\n            repository(owner: $owner, name: $name) {\n              object(expression: $expression) {\n                ... on Blob {\n                  text\n                }\n              }\n            }\n          }\n        `,\n                variables: {\n                    owner,\n                    name,\n                    expression: ref + ':' + path,\n                },\n                operationName: 'GetGraphQLSchemaForGraphQLtools',\n            }),\n        });\n        const response = await request.json();\n        let errorMessage = null;\n        if (response.errors && response.errors.length > 0) {\n            errorMessage = response.errors.map((item) => item.message).join(', ');\n        }\n        else if (!response.data) {\n            errorMessage = response;\n        }\n        if (errorMessage) {\n            throw new Error('Unable to download schema from github: ' + errorMessage);\n        }\n        const content = response.data.repository.object.text;\n        if (/\\.(gql|graphql)s?$/i.test(path)) {\n            return parseGraphQLSDL(pointer, content, options);\n        }\n        if (/\\.json$/i.test(path)) {\n            return parseGraphQLJSON(pointer, content, options);\n        }\n        const rawSDL = await gqlPluckFromCodeString(pointer, content, options.pluckConfig);\n        if (rawSDL) {\n            return {\n                location: pointer,\n                rawSDL,\n            };\n        }\n        throw new Error(`Invalid file extension: ${path}`);\n    }\n    loadSync() {\n        throw new Error('Loader GitHub has no sync mode');\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}