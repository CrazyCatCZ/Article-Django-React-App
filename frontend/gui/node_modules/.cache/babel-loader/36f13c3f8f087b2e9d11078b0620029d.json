{"ast":null,"code":"import { isSchema, parse } from 'graphql';\nimport { fixSchemaAst, printSchemaWithDirectives } from '@graphql-tools/utils';\nconst InvalidError = new Error(`Imported object was not a string, DocumentNode or GraphQLSchema`);\n\nconst createLoadError = error => new Error('Unable to load schema from module: ' + `${error.message ||\n/* istanbul ignore next */\nerror}`); // module:node/module#export\n\n\nfunction extractData(pointer) {\n  const parts = pointer.replace(/^module\\:/i, '').split('#');\n\n  if (!parts || parts.length > 2) {\n    throw new Error('Schema pointer should match \"module:path/to/module#export\"');\n  }\n\n  return {\n    modulePath: parts[0],\n    exportName: parts[1]\n  };\n}\n/**\n * * This loader loads documents and type definitions from a Node module\n *\n * ```js\n * const schema = await loadSchema('module:someModuleName#someNamedExport', {\n *   loaders: [new ModuleLoader()],\n * })\n * ```\n */\n\n\nclass ModuleLoader {\n  loaderId() {\n    return 'module-loader';\n  }\n\n  async canLoad(pointer) {\n    return this.canLoadSync(pointer);\n  }\n\n  canLoadSync(pointer) {\n    return typeof pointer === 'string' && pointer.toLowerCase().startsWith('module:');\n  }\n\n  async load(pointer, options) {\n    try {\n      const result = this.parse(pointer, options, await this.importModule(pointer));\n\n      if (result) {\n        return result;\n      }\n\n      throw InvalidError;\n    } catch (error) {\n      throw createLoadError(error);\n    }\n  }\n\n  loadSync(pointer, options) {\n    try {\n      const result = this.parse(pointer, options, this.importModuleSync(pointer));\n\n      if (result) {\n        return result;\n      }\n\n      throw InvalidError;\n    } catch (error) {\n      throw createLoadError(error);\n    }\n  }\n\n  parse(pointer, options, importedModule) {\n    if (isSchema(importedModule)) {\n      const schema = fixSchemaAst(importedModule, options);\n      return {\n        schema,\n\n        get document() {\n          return parse(printSchemaWithDirectives(schema, options));\n        },\n\n        location: pointer\n      };\n    } else if (typeof importedModule === 'string') {\n      return {\n        location: pointer,\n        document: parse(importedModule)\n      };\n    } else if (typeof importedModule === 'object' && importedModule.kind === 'Document') {\n      return {\n        location: pointer,\n        document: importedModule\n      };\n    }\n  }\n\n  extractFromModule(mod, modulePath, identifier) {\n    const thing = identifier ? mod[identifier] : mod;\n\n    if (!thing) {\n      throw new Error('Unable to import an object from module: ' + modulePath);\n    }\n\n    return thing;\n  } // Sync and Async\n\n\n  async importModule(pointer) {\n    const {\n      modulePath,\n      exportName\n    } = extractData(pointer);\n    const imported = await import(modulePath);\n    return this.extractFromModule(imported, modulePath, exportName || 'default');\n  }\n\n  importModuleSync(pointer) {\n    const {\n      modulePath,\n      exportName\n    } = extractData(pointer);\n\n    const imported = require(modulePath);\n\n    return this.extractFromModule(imported, modulePath, exportName);\n  }\n\n}\n\nexport { ModuleLoader };","map":{"version":3,"sources":["../../../dist/loaders/module/src/index.js"],"names":[],"mappings":"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","sourcesContent":["import { parse, isSchema } from 'graphql';\nimport { fixSchemaAst, printSchemaWithDirectives, } from '@graphql-tools/utils';\nconst InvalidError = new Error(`Imported object was not a string, DocumentNode or GraphQLSchema`);\nconst createLoadError = (error) => new Error('Unable to load schema from module: ' + `${error.message || /* istanbul ignore next */ error}`);\n// module:node/module#export\nfunction extractData(pointer) {\n    const parts = pointer.replace(/^module\\:/i, '').split('#');\n    if (!parts || parts.length > 2) {\n        throw new Error('Schema pointer should match \"module:path/to/module#export\"');\n    }\n    return {\n        modulePath: parts[0],\n        exportName: parts[1],\n    };\n}\n/**\n * * This loader loads documents and type definitions from a Node module\n *\n * ```js\n * const schema = await loadSchema('module:someModuleName#someNamedExport', {\n *   loaders: [new ModuleLoader()],\n * })\n * ```\n */\nexport class ModuleLoader {\n    loaderId() {\n        return 'module-loader';\n    }\n    async canLoad(pointer) {\n        return this.canLoadSync(pointer);\n    }\n    canLoadSync(pointer) {\n        return typeof pointer === 'string' && pointer.toLowerCase().startsWith('module:');\n    }\n    async load(pointer, options) {\n        try {\n            const result = this.parse(pointer, options, await this.importModule(pointer));\n            if (result) {\n                return result;\n            }\n            throw InvalidError;\n        }\n        catch (error) {\n            throw createLoadError(error);\n        }\n    }\n    loadSync(pointer, options) {\n        try {\n            const result = this.parse(pointer, options, this.importModuleSync(pointer));\n            if (result) {\n                return result;\n            }\n            throw InvalidError;\n        }\n        catch (error) {\n            throw createLoadError(error);\n        }\n    }\n    parse(pointer, options, importedModule) {\n        if (isSchema(importedModule)) {\n            const schema = fixSchemaAst(importedModule, options);\n            return {\n                schema,\n                get document() {\n                    return parse(printSchemaWithDirectives(schema, options));\n                },\n                location: pointer,\n            };\n        }\n        else if (typeof importedModule === 'string') {\n            return {\n                location: pointer,\n                document: parse(importedModule),\n            };\n        }\n        else if (typeof importedModule === 'object' && importedModule.kind === 'Document') {\n            return {\n                location: pointer,\n                document: importedModule,\n            };\n        }\n    }\n    extractFromModule(mod, modulePath, identifier) {\n        const thing = identifier ? mod[identifier] : mod;\n        if (!thing) {\n            throw new Error('Unable to import an object from module: ' + modulePath);\n        }\n        return thing;\n    }\n    // Sync and Async\n    async importModule(pointer) {\n        const { modulePath, exportName } = extractData(pointer);\n        const imported = await import(modulePath);\n        return this.extractFromModule(imported, modulePath, exportName || 'default');\n    }\n    importModuleSync(pointer) {\n        const { modulePath, exportName } = extractData(pointer);\n        const imported = require(modulePath);\n        return this.extractFromModule(imported, modulePath, exportName);\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}