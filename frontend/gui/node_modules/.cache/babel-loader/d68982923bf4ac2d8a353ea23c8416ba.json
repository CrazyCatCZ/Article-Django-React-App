{"ast":null,"code":"import { get, set, flatten } from 'lodash';\nimport { isScalarType } from 'graphql';\nimport { asArray } from '@graphql-tools/utils';\n\nfunction chainFunctions(funcs) {\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n\nfunction resolveRelevantMappings(resolvers, path, allMappings) {\n  const splitted = path.split('.');\n\n  if (splitted.length === 2) {\n    const typeName = splitted[0];\n\n    if (isScalarType(resolvers[typeName])) {\n      return [];\n    }\n\n    const fieldName = splitted[1];\n\n    if (typeName === '*') {\n      return flatten(Object.keys(resolvers).map(typeName => resolveRelevantMappings(resolvers, `${typeName}.${fieldName}`, allMappings)));\n    }\n\n    if (fieldName === '*') {\n      return flatten(Object.keys(resolvers[typeName]).map(field => resolveRelevantMappings(resolvers, `${typeName}.${field}`, allMappings))).filter(mapItem => !allMappings[mapItem]);\n    } else {\n      const paths = [];\n\n      if (resolvers[typeName] && resolvers[typeName][fieldName]) {\n        if (resolvers[typeName][fieldName].subscribe) {\n          paths.push(path + '.subscribe');\n        }\n\n        if (resolvers[typeName][fieldName].resolve) {\n          paths.push(path + '.resolve');\n        }\n\n        if (typeof resolvers[typeName][fieldName] === 'function') {\n          paths.push(path);\n        }\n      }\n\n      return paths;\n    }\n  } else if (splitted.length === 1) {\n    const typeName = splitted[0];\n    return flatten(Object.keys(resolvers[typeName]).map(fieldName => resolveRelevantMappings(resolvers, `${typeName}.${fieldName}`, allMappings)));\n  }\n\n  return [];\n}\n/**\n * Wraps the resolvers object with the resolvers composition objects.\n * Implemented as a simple and basic middleware mechanism.\n *\n * @param resolvers - resolvers object\n * @param mapping - resolvers composition mapping\n * @hidden\n */\n\n\nfunction composeResolvers(resolvers, mapping = {}) {\n  const mappingResult = {};\n  Object.keys(mapping).map(resolverPath => {\n    if (mapping[resolverPath] instanceof Array || typeof mapping[resolverPath] === 'function') {\n      const composeFns = mapping[resolverPath];\n      const relevantFields = resolveRelevantMappings(resolvers, resolverPath, mapping);\n      relevantFields.forEach(path => {\n        mappingResult[path] = asArray(composeFns);\n      });\n    } else {\n      Object.keys(mapping[resolverPath]).forEach(fieldName => {\n        const composeFns = mapping[resolverPath][fieldName];\n        const relevantFields = resolveRelevantMappings(resolvers, resolverPath + '.' + fieldName, mapping);\n        relevantFields.forEach(path => {\n          mappingResult[path] = asArray(composeFns);\n        });\n      });\n    }\n  });\n  Object.keys(mappingResult).forEach(path => {\n    const fns = chainFunctions([...asArray(mappingResult[path]), () => get(resolvers, path)]);\n    set(resolvers, path, fns());\n  });\n  return resolvers;\n}\n\nexport { composeResolvers };","map":{"version":3,"sources":["../../../dist/resolvers-composition/src/chain-functions.js","../../../dist/resolvers-composition/src/resolvers-composition.js"],"names":[],"mappings":"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","sourcesContent":["export function chainFunctions(funcs) {\n    if (funcs.length === 1) {\n        return funcs[0];\n    }\n    return funcs.reduce((a, b) => (...args) => a(b(...args)));\n}\n//# sourceMappingURL=chain-functions.js.map","import { chainFunctions } from './chain-functions';\nimport { get, set, flatten } from 'lodash';\nimport { isScalarType } from 'graphql';\nimport { asArray } from '@graphql-tools/utils';\nfunction resolveRelevantMappings(resolvers, path, allMappings) {\n    const splitted = path.split('.');\n    if (splitted.length === 2) {\n        const typeName = splitted[0];\n        if (isScalarType(resolvers[typeName])) {\n            return [];\n        }\n        const fieldName = splitted[1];\n        if (typeName === '*') {\n            return flatten(Object.keys(resolvers).map(typeName => resolveRelevantMappings(resolvers, `${typeName}.${fieldName}`, allMappings)));\n        }\n        if (fieldName === '*') {\n            return flatten(Object.keys(resolvers[typeName]).map(field => resolveRelevantMappings(resolvers, `${typeName}.${field}`, allMappings))).filter(mapItem => !allMappings[mapItem]);\n        }\n        else {\n            const paths = [];\n            if (resolvers[typeName] && resolvers[typeName][fieldName]) {\n                if (resolvers[typeName][fieldName].subscribe) {\n                    paths.push(path + '.subscribe');\n                }\n                if (resolvers[typeName][fieldName].resolve) {\n                    paths.push(path + '.resolve');\n                }\n                if (typeof resolvers[typeName][fieldName] === 'function') {\n                    paths.push(path);\n                }\n            }\n            return paths;\n        }\n    }\n    else if (splitted.length === 1) {\n        const typeName = splitted[0];\n        return flatten(Object.keys(resolvers[typeName]).map(fieldName => resolveRelevantMappings(resolvers, `${typeName}.${fieldName}`, allMappings)));\n    }\n    return [];\n}\n/**\n * Wraps the resolvers object with the resolvers composition objects.\n * Implemented as a simple and basic middleware mechanism.\n *\n * @param resolvers - resolvers object\n * @param mapping - resolvers composition mapping\n * @hidden\n */\nexport function composeResolvers(resolvers, mapping = {}) {\n    const mappingResult = {};\n    Object.keys(mapping).map((resolverPath) => {\n        if (mapping[resolverPath] instanceof Array || typeof mapping[resolverPath] === 'function') {\n            const composeFns = mapping[resolverPath];\n            const relevantFields = resolveRelevantMappings(resolvers, resolverPath, mapping);\n            relevantFields.forEach((path) => {\n                mappingResult[path] = asArray(composeFns);\n            });\n        }\n        else {\n            Object.keys(mapping[resolverPath]).forEach(fieldName => {\n                const composeFns = mapping[resolverPath][fieldName];\n                const relevantFields = resolveRelevantMappings(resolvers, resolverPath + '.' + fieldName, mapping);\n                relevantFields.forEach((path) => {\n                    mappingResult[path] = asArray(composeFns);\n                });\n            });\n        }\n    });\n    Object.keys(mappingResult).forEach(path => {\n        const fns = chainFunctions([...asArray(mappingResult[path]), () => get(resolvers, path)]);\n        set(resolvers, path, fns());\n    });\n    return resolvers;\n}\n//# sourceMappingURL=resolvers-composition.js.map"]},"metadata":{},"sourceType":"module"}