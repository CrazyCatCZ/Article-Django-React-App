{"ast":null,"code":"import { GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, isSpecifiedScalarType, isScalarType, visit, Kind, TypeInfo, visitWithTypeInfo, isObjectType, isInterfaceType, isLeafType, valueFromAST, extendSchema, parse, getNullableType, BREAK, buildSchema, getIntrospectionQuery, buildClientSchema } from 'graphql';\nimport { applySchemaTransforms, getResponseKeyFromInfo, getErrors, mapSchema, MapperKind, renameType, visitData, visitResult, updateArgument, transformInputValue, relocatedError, getArgumentValues, valueMatchesCriteria, getDirectives, pruneSchema, selectObjectFields, appendObjectFields, modifyObjectFields, renameFieldNode, removeObjectFields } from '@graphql-tools/utils';\nimport { isSubschemaConfig, delegateToSchema, getSubschema, handleResult, defaultMergedResolver } from '@graphql-tools/delegate';\nimport { addResolversToSchema } from '@graphql-tools/schema';\nimport { __extends } from 'tslib';\n\nfunction generateProxyingResolvers(subschemaOrSubschemaConfig, transforms) {\n  var _a;\n\n  let targetSchema;\n  let schemaTransforms = [];\n  let createProxyingResolver;\n\n  if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\n    targetSchema = subschemaOrSubschemaConfig.schema;\n    createProxyingResolver = (_a = subschemaOrSubschemaConfig.createProxyingResolver) !== null && _a !== void 0 ? _a : defaultCreateProxyingResolver;\n\n    if (subschemaOrSubschemaConfig.transforms != null) {\n      schemaTransforms = schemaTransforms.concat(subschemaOrSubschemaConfig.transforms);\n    }\n  } else {\n    targetSchema = subschemaOrSubschemaConfig;\n    createProxyingResolver = defaultCreateProxyingResolver;\n  }\n\n  if (transforms != null) {\n    schemaTransforms = schemaTransforms.concat(transforms);\n  }\n\n  const transformedSchema = applySchemaTransforms(targetSchema, schemaTransforms);\n  const operationTypes = {\n    query: targetSchema.getQueryType(),\n    mutation: targetSchema.getMutationType(),\n    subscription: targetSchema.getSubscriptionType()\n  };\n  const resolvers = {};\n  Object.keys(operationTypes).forEach(operation => {\n    const rootType = operationTypes[operation];\n\n    if (rootType != null) {\n      const typeName = rootType.name;\n      const fields = rootType.getFields();\n      resolvers[typeName] = {};\n      Object.keys(fields).forEach(fieldName => {\n        const proxyingResolver = createProxyingResolver({\n          schema: subschemaOrSubschemaConfig,\n          transforms,\n          transformedSchema,\n          operation,\n          fieldName\n        });\n        const finalResolver = createPossiblyNestedProxyingResolver(subschemaOrSubschemaConfig, proxyingResolver);\n\n        if (operation === 'subscription') {\n          resolvers[typeName][fieldName] = {\n            subscribe: finalResolver,\n            resolve: (payload, _, __, {\n              fieldName: targetFieldName\n            }) => payload[targetFieldName]\n          };\n        } else {\n          resolvers[typeName][fieldName] = {\n            resolve: finalResolver\n          };\n        }\n      });\n    }\n  });\n  return resolvers;\n}\n\nfunction createPossiblyNestedProxyingResolver(subschemaOrSubschemaConfig, proxyingResolver) {\n  return (parent, args, context, info) => {\n    if (parent != null) {\n      const responseKey = getResponseKeyFromInfo(info);\n      const errors = getErrors(parent, responseKey); // Check to see if the parent contains a proxied result\n\n      if (errors != null) {\n        const subschema = getSubschema(parent, responseKey); // If there is a proxied result from this subschema, return it\n        // This can happen even for a root field when the root type ia\n        // also nested as a field within a different type.\n\n        if (subschemaOrSubschemaConfig === subschema && parent[responseKey] !== undefined) {\n          return handleResult(parent[responseKey], errors, subschema, context, info);\n        }\n      }\n    }\n\n    return proxyingResolver(parent, args, context, info);\n  };\n}\n\nfunction defaultCreateProxyingResolver({\n  schema,\n  operation,\n  transforms,\n  transformedSchema\n}) {\n  return (_parent, _args, context, info) => delegateToSchema({\n    schema,\n    operation,\n    context,\n    info,\n    transforms,\n    transformedSchema\n  });\n}\n\nfunction wrapSchema(subschemaOrSubschemaConfig, transforms) {\n  let targetSchema;\n  let schemaTransforms = [];\n\n  if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\n    targetSchema = subschemaOrSubschemaConfig.schema;\n\n    if (subschemaOrSubschemaConfig.transforms != null) {\n      schemaTransforms = schemaTransforms.concat(subschemaOrSubschemaConfig.transforms);\n    }\n  } else {\n    targetSchema = subschemaOrSubschemaConfig;\n  }\n\n  if (transforms != null) {\n    schemaTransforms = schemaTransforms.concat(transforms);\n  }\n\n  const proxyingResolvers = generateProxyingResolvers(subschemaOrSubschemaConfig, transforms);\n  const schema = createWrappingSchema(targetSchema, proxyingResolvers);\n  return applySchemaTransforms(schema, schemaTransforms);\n}\n\nfunction createWrappingSchema(schema, proxyingResolvers) {\n  return mapSchema(schema, {\n    [MapperKind.ROOT_OBJECT]: type => {\n      const config = type.toConfig();\n      const fieldConfigMap = config.fields;\n      Object.keys(fieldConfigMap).forEach(fieldName => {\n        fieldConfigMap[fieldName] = { ...fieldConfigMap[fieldName],\n          ...proxyingResolvers[type.name][fieldName]\n        };\n      });\n      return new GraphQLObjectType(config);\n    },\n    [MapperKind.OBJECT_TYPE]: type => {\n      const config = type.toConfig();\n      config.isTypeOf = undefined;\n      Object.keys(config.fields).forEach(fieldName => {\n        config.fields[fieldName].resolve = defaultMergedResolver;\n        config.fields[fieldName].subscribe = null;\n      });\n      return new GraphQLObjectType(config);\n    },\n    [MapperKind.INTERFACE_TYPE]: type => {\n      const config = type.toConfig();\n      delete config.resolveType;\n      return new GraphQLInterfaceType(config);\n    },\n    [MapperKind.UNION_TYPE]: type => {\n      const config = type.toConfig();\n      delete config.resolveType;\n      return new GraphQLUnionType(config);\n    }\n  });\n}\n\nclass RenameTypes {\n  constructor(renamer, options) {\n    this.renamer = renamer;\n    this.map = Object.create(null);\n    this.reverseMap = Object.create(null);\n    const {\n      renameBuiltins = false,\n      renameScalars = true\n    } = options != null ? options : {};\n    this.renameBuiltins = renameBuiltins;\n    this.renameScalars = renameScalars;\n  }\n\n  transformSchema(originalSchema) {\n    return mapSchema(originalSchema, {\n      [MapperKind.TYPE]: type => {\n        if (isSpecifiedScalarType(type) && !this.renameBuiltins) {\n          return undefined;\n        }\n\n        if (isScalarType(type) && !this.renameScalars) {\n          return undefined;\n        }\n\n        const oldName = type.name;\n        const newName = this.renamer(oldName);\n\n        if (newName !== undefined && newName !== oldName) {\n          this.map[oldName] = newName;\n          this.reverseMap[newName] = oldName;\n          return renameType(type, newName);\n        }\n      },\n\n      [MapperKind.ROOT_OBJECT]() {\n        return undefined;\n      }\n\n    });\n  }\n\n  transformRequest(originalRequest) {\n    const document = visit(originalRequest.document, {\n      [Kind.NAMED_TYPE]: node => {\n        const name = node.name.value;\n\n        if (name in this.reverseMap) {\n          return { ...node,\n            name: {\n              kind: Kind.NAME,\n              value: this.reverseMap[name]\n            }\n          };\n        }\n      }\n    });\n    return { ...originalRequest,\n      document\n    };\n  }\n\n  transformResult(result) {\n    return { ...result,\n      data: visitData(result.data, object => {\n        const typeName = object === null || object === void 0 ? void 0 : object.__typename;\n\n        if (typeName != null && typeName in this.map) {\n          object.__typename = this.map[typeName];\n        }\n\n        return object;\n      })\n    };\n  }\n\n}\n\nclass FilterTypes {\n  constructor(filter) {\n    this.filter = filter;\n  }\n\n  transformSchema(schema) {\n    return mapSchema(schema, {\n      [MapperKind.TYPE]: type => {\n        if (this.filter(type)) {\n          return undefined;\n        }\n\n        return null;\n      }\n    });\n  }\n\n}\n\nclass RenameRootTypes {\n  constructor(renamer) {\n    this.renamer = renamer;\n    this.map = Object.create(null);\n    this.reverseMap = Object.create(null);\n  }\n\n  transformSchema(originalSchema) {\n    return mapSchema(originalSchema, {\n      [MapperKind.ROOT_OBJECT]: type => {\n        const oldName = type.name;\n        const newName = this.renamer(oldName);\n\n        if (newName !== undefined && newName !== oldName) {\n          this.map[oldName] = newName;\n          this.reverseMap[newName] = oldName;\n          return renameType(type, newName);\n        }\n      }\n    });\n  }\n\n  transformRequest(originalRequest) {\n    const document = visit(originalRequest.document, {\n      [Kind.NAMED_TYPE]: node => {\n        const name = node.name.value;\n\n        if (name in this.reverseMap) {\n          return { ...node,\n            name: {\n              kind: Kind.NAME,\n              value: this.reverseMap[name]\n            }\n          };\n        }\n      }\n    });\n    return { ...originalRequest,\n      document\n    };\n  }\n\n  transformResult(result) {\n    return { ...result,\n      data: visitData(result.data, object => {\n        const typeName = object === null || object === void 0 ? void 0 : object.__typename;\n\n        if (typeName != null && typeName in this.map) {\n          object.__typename = this.map[typeName];\n        }\n\n        return object;\n      })\n    };\n  }\n\n}\n\nclass TransformCompositeFields {\n  constructor(fieldTransformer, fieldNodeTransformer, dataTransformer, errorsTransformer) {\n    this.fieldTransformer = fieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n    this.dataTransformer = dataTransformer;\n    this.errorsTransformer = errorsTransformer;\n    this.mapping = {};\n  }\n\n  transformSchema(originalSchema) {\n    this.transformedSchema = mapSchema(originalSchema, {\n      [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n        const transformedField = this.fieldTransformer(typeName, fieldName, fieldConfig);\n\n        if (Array.isArray(transformedField)) {\n          const newFieldName = transformedField[0];\n\n          if (newFieldName !== fieldName) {\n            if (!(typeName in this.mapping)) {\n              this.mapping[typeName] = {};\n            }\n\n            this.mapping[typeName][newFieldName] = fieldName;\n          }\n        }\n\n        return transformedField;\n      }\n    });\n    this.typeInfo = new TypeInfo(this.transformedSchema);\n    return this.transformedSchema;\n  }\n\n  transformRequest(originalRequest, _delegationContext, transformationContext) {\n    const document = originalRequest.document;\n    const fragments = Object.create(null);\n    document.definitions.forEach(def => {\n      if (def.kind === Kind.FRAGMENT_DEFINITION) {\n        fragments[def.name.value] = def;\n      }\n    });\n    return { ...originalRequest,\n      document: this.transformDocument(document, fragments, transformationContext)\n    };\n  }\n\n  transformResult(result, _delegationContext, transformationContext) {\n    if (this.dataTransformer != null) {\n      result.data = visitData(result.data, value => this.dataTransformer(value, transformationContext));\n    }\n\n    if (this.errorsTransformer != null) {\n      result.errors = this.errorsTransformer(result.errors, transformationContext);\n    }\n\n    return result;\n  }\n\n  transformDocument(document, fragments, transformationContext) {\n    return visit(document, visitWithTypeInfo(this.typeInfo, {\n      leave: {\n        [Kind.SELECTION_SET]: node => this.transformSelectionSet(node, this.typeInfo, fragments, transformationContext)\n      }\n    }));\n  }\n\n  transformSelectionSet(node, typeInfo, fragments, transformationContext) {\n    const parentType = typeInfo.getParentType();\n\n    if (parentType == null) {\n      return undefined;\n    }\n\n    const parentTypeName = parentType.name;\n    let newSelections = [];\n    node.selections.forEach(selection => {\n      var _a, _b;\n\n      if (selection.kind !== Kind.FIELD) {\n        newSelections.push(selection);\n        return;\n      }\n\n      const newName = selection.name.value;\n\n      if (this.dataTransformer != null || this.errorsTransformer != null) {\n        newSelections.push({\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: '__typename'\n          }\n        });\n      }\n\n      let transformedSelection;\n\n      if (this.fieldNodeTransformer == null) {\n        transformedSelection = selection;\n      } else {\n        transformedSelection = this.fieldNodeTransformer(parentTypeName, newName, selection, fragments, transformationContext);\n        transformedSelection = transformedSelection === undefined ? selection : transformedSelection;\n      }\n\n      if (Array.isArray(transformedSelection)) {\n        newSelections = newSelections.concat(transformedSelection);\n        return;\n      }\n\n      if (transformedSelection.kind !== Kind.FIELD) {\n        newSelections.push(transformedSelection);\n        return;\n      }\n\n      const typeMapping = this.mapping[parentTypeName];\n\n      if (typeMapping == null) {\n        newSelections.push(transformedSelection);\n        return;\n      }\n\n      const oldName = this.mapping[parentTypeName][newName];\n\n      if (oldName == null) {\n        newSelections.push(transformedSelection);\n        return;\n      }\n\n      newSelections.push({ ...transformedSelection,\n        name: {\n          kind: Kind.NAME,\n          value: oldName\n        },\n        alias: {\n          kind: Kind.NAME,\n          value: (_b = (_a = transformedSelection.alias) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : newName\n        }\n      });\n    });\n    return { ...node,\n      selections: newSelections\n    };\n  }\n\n}\n\nclass TransformObjectFields {\n  constructor(objectFieldTransformer, fieldNodeTransformer) {\n    this.objectFieldTransformer = objectFieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n  }\n\n  transformSchema(originalSchema) {\n    const compositeToObjectFieldTransformer = (typeName, fieldName, fieldConfig) => {\n      if (isObjectType(originalSchema.getType(typeName))) {\n        return this.objectFieldTransformer(typeName, fieldName, fieldConfig);\n      }\n\n      return undefined;\n    };\n\n    this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  transformRequest(originalRequest, delegationContext, transformationContext) {\n    return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n  }\n\n  transformResult(originalResult, delegationContext, transformationContext) {\n    return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n  }\n\n}\n\nclass TransformRootFields {\n  constructor(rootFieldTransformer, fieldNodeTransformer) {\n    this.rootFieldTransformer = rootFieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n  }\n\n  transformSchema(originalSchema) {\n    var _a, _b, _c;\n\n    const queryTypeName = (_a = originalSchema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name;\n    const mutationTypeName = (_b = originalSchema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name;\n    const subscriptionTypeName = (_c = originalSchema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name;\n\n    const rootToObjectFieldTransformer = (typeName, fieldName, fieldConfig) => {\n      if (typeName === queryTypeName) {\n        return this.rootFieldTransformer('Query', fieldName, fieldConfig);\n      }\n\n      if (typeName === mutationTypeName) {\n        return this.rootFieldTransformer('Mutation', fieldName, fieldConfig);\n      }\n\n      if (typeName === subscriptionTypeName) {\n        return this.rootFieldTransformer('Subscription', fieldName, fieldConfig);\n      }\n\n      return undefined;\n    };\n\n    this.transformer = new TransformObjectFields(rootToObjectFieldTransformer, this.fieldNodeTransformer);\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  transformRequest(originalRequest, delegationContext, transformationContext) {\n    return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n  }\n\n  transformResult(originalResult, delegationContext, transformationContext) {\n    return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n  }\n\n}\n\nclass RenameRootFields {\n  constructor(renamer) {\n    this.transformer = new TransformRootFields((operation, fieldName, fieldConfig) => [renamer(operation, fieldName, fieldConfig), fieldConfig]);\n  }\n\n  transformSchema(originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  transformRequest(originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  }\n\n}\n\nclass FilterRootFields {\n  constructor(filter) {\n    this.transformer = new TransformRootFields((operation, fieldName, fieldConfig) => {\n      if (filter(operation, fieldName, fieldConfig)) {\n        return undefined;\n      }\n\n      return null;\n    });\n  }\n\n  transformSchema(originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n}\n\nclass RenameObjectFields {\n  constructor(renamer) {\n    this.transformer = new TransformObjectFields((typeName, fieldName, fieldConfig) => [renamer(typeName, fieldName, fieldConfig), fieldConfig]);\n  }\n\n  transformSchema(originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  transformRequest(originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  }\n\n}\n\nclass FilterObjectFields {\n  constructor(filter) {\n    this.transformer = new TransformObjectFields((typeName, fieldName, fieldConfig) => filter(typeName, fieldName, fieldConfig) ? undefined : null);\n  }\n\n  transformSchema(originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n}\n\nclass TransformInterfaceFields {\n  constructor(interfaceFieldTransformer, fieldNodeTransformer) {\n    this.interfaceFieldTransformer = interfaceFieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n  }\n\n  transformSchema(originalSchema) {\n    const compositeToObjectFieldTransformer = (typeName, fieldName, fieldConfig) => {\n      if (isInterfaceType(originalSchema.getType(typeName))) {\n        return this.interfaceFieldTransformer(typeName, fieldName, fieldConfig);\n      }\n\n      return undefined;\n    };\n\n    this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  transformRequest(originalRequest, delegationContext, transformationContext) {\n    return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n  }\n\n  transformResult(originalResult, delegationContext, transformationContext) {\n    return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n  }\n\n}\n\nclass RenameInterfaceFields {\n  constructor(renamer) {\n    this.transformer = new TransformInterfaceFields((typeName, fieldName, fieldConfig) => [renamer(typeName, fieldName, fieldConfig), fieldConfig]);\n  }\n\n  transformSchema(originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  transformRequest(originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  }\n\n}\n\nclass FilterInterfaceFields {\n  constructor(filter) {\n    this.transformer = new TransformInterfaceFields((typeName, fieldName, fieldConfig) => filter(typeName, fieldName, fieldConfig) ? undefined : null);\n  }\n\n  transformSchema(originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n}\n\nclass TransformInputObjectFields {\n  constructor(inputFieldTransformer, inputFieldNodeTransformer, inputObjectNodeTransformer) {\n    this.inputFieldTransformer = inputFieldTransformer;\n    this.inputFieldNodeTransformer = inputFieldNodeTransformer;\n    this.inputObjectNodeTransformer = inputObjectNodeTransformer;\n    this.mapping = {};\n  }\n\n  transformSchema(originalSchema) {\n    this.transformedSchema = mapSchema(originalSchema, {\n      [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig, fieldName, typeName) => {\n        const transformedInputField = this.inputFieldTransformer(typeName, fieldName, inputFieldConfig);\n\n        if (Array.isArray(transformedInputField)) {\n          const newFieldName = transformedInputField[0];\n\n          if (newFieldName !== fieldName) {\n            if (!(typeName in this.mapping)) {\n              this.mapping[typeName] = {};\n            }\n\n            this.mapping[typeName][newFieldName] = fieldName;\n          }\n        }\n\n        return transformedInputField;\n      }\n    });\n    return this.transformedSchema;\n  }\n\n  transformRequest(originalRequest, delegationContext) {\n    const fragments = Object.create(null);\n    originalRequest.document.definitions.filter(def => def.kind === Kind.FRAGMENT_DEFINITION).forEach(def => {\n      fragments[def.name.value] = def;\n    });\n    const document = this.transformDocument(originalRequest.document, this.mapping, this.inputFieldNodeTransformer, this.inputObjectNodeTransformer, originalRequest, // cast to DelegationContext as workaround to avoid breaking change in types until next major version\n    delegationContext);\n    return { ...originalRequest,\n      document\n    };\n  }\n\n  transformDocument(document, mapping, inputFieldNodeTransformer, inputObjectNodeTransformer, request, delegationContext) {\n    const typeInfo = new TypeInfo(this.transformedSchema);\n    const newDocument = visit(document, visitWithTypeInfo(typeInfo, {\n      leave: {\n        [Kind.OBJECT]: node => {\n          const parentType = typeInfo.getInputType();\n\n          if (parentType != null) {\n            const parentTypeName = parentType.name;\n            const newInputFields = [];\n            node.fields.forEach(inputField => {\n              const newName = inputField.name.value;\n              const transformedInputField = inputFieldNodeTransformer != null ? inputFieldNodeTransformer(parentTypeName, newName, inputField, request, delegationContext) : inputField;\n\n              if (Array.isArray(transformedInputField)) {\n                transformedInputField.forEach(individualTransformedInputField => {\n                  const typeMapping = mapping[parentTypeName];\n\n                  if (typeMapping == null) {\n                    newInputFields.push(individualTransformedInputField);\n                    return;\n                  }\n\n                  const oldName = typeMapping[newName];\n\n                  if (oldName == null) {\n                    newInputFields.push(individualTransformedInputField);\n                    return;\n                  }\n\n                  newInputFields.push({ ...individualTransformedInputField,\n                    name: { ...individualTransformedInputField.name,\n                      value: oldName\n                    }\n                  });\n                });\n                return;\n              }\n\n              const typeMapping = mapping[parentTypeName];\n\n              if (typeMapping == null) {\n                newInputFields.push(transformedInputField);\n                return;\n              }\n\n              const oldName = typeMapping[newName];\n\n              if (oldName == null) {\n                newInputFields.push(transformedInputField);\n                return;\n              }\n\n              newInputFields.push({ ...transformedInputField,\n                name: { ...transformedInputField.name,\n                  value: oldName\n                }\n              });\n            });\n            const newNode = { ...node,\n              fields: newInputFields\n            };\n            return inputObjectNodeTransformer != null ? inputObjectNodeTransformer(parentTypeName, newNode, request, delegationContext) : newNode;\n          }\n        }\n      }\n    }));\n    return newDocument;\n  }\n\n}\n\nclass RenameInputObjectFields {\n  constructor(renamer) {\n    this.renamer = renamer;\n    this.transformer = new TransformInputObjectFields((typeName, inputFieldName, inputFieldConfig) => {\n      const newName = renamer(typeName, inputFieldName, inputFieldConfig);\n\n      if (newName !== undefined && newName !== inputFieldName) {\n        return [renamer(typeName, inputFieldName, inputFieldConfig), inputFieldConfig];\n      }\n    }, (typeName, inputFieldName, inputFieldNode) => {\n      if (!(typeName in this.reverseMap)) {\n        return inputFieldNode;\n      }\n\n      const inputFieldNameMap = this.reverseMap[typeName];\n\n      if (!(inputFieldName in inputFieldNameMap)) {\n        return inputFieldNode;\n      }\n\n      return { ...inputFieldNode,\n        name: { ...inputFieldNode.name,\n          value: inputFieldNameMap[inputFieldName]\n        }\n      };\n    });\n    this.reverseMap = Object.create(null);\n  }\n\n  transformSchema(originalSchema) {\n    mapSchema(originalSchema, {\n      [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig, fieldName, typeName) => {\n        const newName = this.renamer(typeName, fieldName, inputFieldConfig);\n\n        if (newName !== undefined && newName !== fieldName) {\n          if (this.reverseMap[typeName] == null) {\n            this.reverseMap[typeName] = Object.create(null);\n          }\n\n          this.reverseMap[typeName][newName] = fieldName;\n        }\n\n        return undefined;\n      },\n\n      [MapperKind.ROOT_OBJECT]() {\n        return undefined;\n      }\n\n    });\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  transformRequest(originalRequest, delegationContext) {\n    return this.transformer.transformRequest(originalRequest, delegationContext);\n  }\n\n}\n\nclass FilterInputObjectFields {\n  constructor(filter, inputObjectNodeTransformer) {\n    this.transformer = new TransformInputObjectFields((typeName, fieldName, inputFieldConfig) => filter(typeName, fieldName, inputFieldConfig) ? undefined : null, undefined, inputObjectNodeTransformer);\n  }\n\n  transformSchema(originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n  transformRequest(originalRequest, delegationContext) {\n    return this.transformer.transformRequest(originalRequest, delegationContext);\n  }\n\n}\n\nclass MapLeafValues {\n  constructor(inputValueTransformer, outputValueTransformer) {\n    this.inputValueTransformer = inputValueTransformer;\n    this.outputValueTransformer = outputValueTransformer;\n    this.resultVisitorMap = Object.create(null);\n  }\n\n  transformSchema(originalSchema) {\n    this.originalSchema = originalSchema;\n    const typeMap = originalSchema.getTypeMap();\n    Object.keys(typeMap).forEach(typeName => {\n      const type = typeMap[typeName];\n\n      if (!typeName.startsWith('__')) {\n        if (isLeafType(type)) {\n          this.resultVisitorMap[typeName] = value => this.outputValueTransformer(typeName, value);\n        }\n      }\n    });\n    this.typeInfo = new TypeInfo(originalSchema);\n    return originalSchema;\n  }\n\n  transformRequest(originalRequest, _delegationContext, transformationContext) {\n    const document = originalRequest.document;\n    const variableValues = originalRequest.variables;\n    const operations = document.definitions.filter(def => def.kind === Kind.OPERATION_DEFINITION);\n    const fragments = document.definitions.filter(def => def.kind === Kind.FRAGMENT_DEFINITION);\n    const newOperations = this.transformOperations(operations, variableValues);\n    const transformedRequest = { ...originalRequest,\n      document: { ...document,\n        definitions: [...newOperations, ...fragments]\n      },\n      variables: variableValues\n    };\n    transformationContext.transformedRequest = transformedRequest;\n    return transformedRequest;\n  }\n\n  transformResult(originalResult, _delegationContext, transformationContext) {\n    return visitResult(originalResult, transformationContext.transformedRequest, this.originalSchema, this.resultVisitorMap);\n  }\n\n  transformOperations(operations, variableValues) {\n    return operations.map(operation => {\n      const variableDefinitionMap = operation.variableDefinitions.reduce((prev, def) => ({ ...prev,\n        [def.variable.name.value]: def\n      }), {});\n      const newOperation = visit(operation, visitWithTypeInfo(this.typeInfo, {\n        [Kind.FIELD]: node => this.transformFieldNode(node, variableDefinitionMap, variableValues)\n      }));\n      return { ...newOperation,\n        variableDefinitions: Object.keys(variableDefinitionMap).map(varName => variableDefinitionMap[varName])\n      };\n    });\n  }\n\n  transformFieldNode(field, variableDefinitionMap, variableValues) {\n    const targetField = this.typeInfo.getFieldDef();\n\n    if (!targetField.name.startsWith('__')) {\n      const argumentNodes = field.arguments;\n\n      if (argumentNodes != null) {\n        const argumentNodeMap = argumentNodes.reduce((prev, argument) => ({ ...prev,\n          [argument.name.value]: argument\n        }), Object.create(null));\n        targetField.args.forEach(argument => {\n          const argName = argument.name;\n          const argType = argument.type;\n          const argumentNode = argumentNodeMap[argName];\n          const argValue = argumentNode === null || argumentNode === void 0 ? void 0 : argumentNode.value;\n          let value;\n\n          if (argValue != null) {\n            value = valueFromAST(argValue, argType, variableValues);\n          }\n\n          updateArgument(argName, argType, argumentNodeMap, variableDefinitionMap, variableValues, transformInputValue(argType, value, (t, v) => {\n            const newValue = this.inputValueTransformer(t.name, v);\n            return newValue === undefined ? v : newValue;\n          }));\n        });\n        return { ...field,\n          arguments: Object.keys(argumentNodeMap).map(argName => argumentNodeMap[argName])\n        };\n      }\n    }\n  }\n\n}\n\nclass TransformEnumValues {\n  constructor(enumValueTransformer, inputValueTransformer, outputValueTransformer) {\n    this.enumValueTransformer = enumValueTransformer;\n    this.mapping = Object.create(null);\n    this.reverseMapping = Object.create(null);\n    this.transformer = new MapLeafValues(generateValueTransformer(inputValueTransformer, this.reverseMapping), generateValueTransformer(outputValueTransformer, this.mapping));\n  }\n\n  transformSchema(originalSchema) {\n    const transformedSchema = this.transformer.transformSchema(originalSchema);\n    this.transformedSchema = mapSchema(transformedSchema, {\n      [MapperKind.ENUM_VALUE]: (valueConfig, typeName, _schema, externalValue) => this.transformEnumValue(typeName, externalValue, valueConfig)\n    });\n    return this.transformedSchema;\n  }\n\n  transformRequest(originalRequest, delegationContext, transformationContext) {\n    return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n  }\n\n  transformResult(originalResult, delegationContext, transformationContext) {\n    return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n  }\n\n  transformEnumValue(typeName, externalValue, enumValueConfig) {\n    const transformedEnumValue = this.enumValueTransformer(typeName, externalValue, enumValueConfig);\n\n    if (Array.isArray(transformedEnumValue)) {\n      const newExternalValue = transformedEnumValue[0];\n\n      if (newExternalValue !== externalValue) {\n        if (!(typeName in this.mapping)) {\n          this.mapping[typeName] = Object.create(null);\n          this.reverseMapping[typeName] = Object.create(null);\n        }\n\n        this.mapping[typeName][externalValue] = newExternalValue;\n        this.reverseMapping[typeName][newExternalValue] = externalValue;\n      }\n    }\n\n    return transformedEnumValue;\n  }\n\n}\n\nfunction mapEnumValues(typeName, value, mapping) {\n  var _a;\n\n  const newExternalValue = (_a = mapping[typeName]) === null || _a === void 0 ? void 0 : _a[value];\n  return newExternalValue != null ? newExternalValue : value;\n}\n\nfunction generateValueTransformer(valueTransformer, mapping) {\n  if (valueTransformer == null) {\n    return (typeName, value) => mapEnumValues(typeName, value, mapping);\n  } else {\n    return (typeName, value) => mapEnumValues(typeName, valueTransformer(typeName, value), mapping);\n  }\n}\n\nclass TransformQuery {\n  constructor({\n    path,\n    queryTransformer,\n    resultTransformer = result => result,\n    errorPathTransformer = errorPath => [].concat(errorPath),\n    fragments = {}\n  }) {\n    this.path = path;\n    this.queryTransformer = queryTransformer;\n    this.resultTransformer = resultTransformer;\n    this.errorPathTransformer = errorPathTransformer;\n    this.fragments = fragments;\n  }\n\n  transformRequest(originalRequest) {\n    const pathLength = this.path.length;\n    let index = 0;\n    const document = visit(originalRequest.document, {\n      [Kind.FIELD]: {\n        enter: node => {\n          if (index === pathLength || node.name.value !== this.path[index]) {\n            return false;\n          }\n\n          index++;\n\n          if (index === pathLength) {\n            const selectionSet = this.queryTransformer(node.selectionSet, this.fragments);\n            return { ...node,\n              selectionSet\n            };\n          }\n        },\n        leave: () => {\n          index--;\n        }\n      }\n    });\n    return { ...originalRequest,\n      document\n    };\n  }\n\n  transformResult(originalResult) {\n    const data = this.transformData(originalResult.data);\n    const errors = originalResult.errors;\n    return {\n      data,\n      errors: errors != null ? this.transformErrors(errors) : undefined\n    };\n  }\n\n  transformData(data) {\n    const leafIndex = this.path.length - 1;\n    let index = 0;\n    let newData = data;\n\n    if (newData) {\n      let next = this.path[index];\n\n      while (index < leafIndex) {\n        if (data[next]) {\n          newData = newData[next];\n        } else {\n          break;\n        }\n\n        index++;\n        next = this.path[index];\n      }\n\n      newData[next] = this.resultTransformer(newData[next]);\n    }\n\n    return newData;\n  }\n\n  transformErrors(errors) {\n    return errors.map(error => {\n      const path = error.path;\n      let match = true;\n      let index = 0;\n\n      while (index < this.path.length) {\n        if (path[index] !== this.path[index]) {\n          match = false;\n          break;\n        }\n\n        index++;\n      }\n\n      const newPath = match ? path.slice(0, index).concat(this.errorPathTransformer(path.slice(index))) : path;\n      return relocatedError(error, newPath);\n    });\n  }\n\n}\n\nclass FilterObjectFieldDirectives {\n  constructor(filter) {\n    this.filter = filter;\n  }\n\n  transformSchema(originalSchema) {\n    const transformer = new TransformObjectFields((_typeName, _fieldName, fieldConfig) => {\n      const keepDirectives = fieldConfig.astNode.directives.filter(dir => {\n        const directiveDef = originalSchema.getDirective(dir.name.value);\n        const directiveValue = directiveDef ? getArgumentValues(directiveDef, dir) : undefined;\n        return this.filter(dir.name.value, directiveValue);\n      });\n\n      if (keepDirectives.length !== fieldConfig.astNode.directives.length) {\n        fieldConfig = { ...fieldConfig,\n          astNode: { ...fieldConfig.astNode,\n            directives: keepDirectives\n          }\n        };\n        return fieldConfig;\n      }\n    });\n    return transformer.transformSchema(originalSchema);\n  }\n\n}\n\nclass RemoveObjectFieldDirectives {\n  constructor(directiveName, args = {}) {\n    this.transformer = new FilterObjectFieldDirectives((dirName, dirValue) => {\n      return !(valueMatchesCriteria(dirName, directiveName) && valueMatchesCriteria(dirValue, args));\n    });\n  }\n\n  transformSchema(originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n}\n\nclass RemoveObjectFieldsWithDirective {\n  constructor(directiveName, args = {}) {\n    this.directiveName = directiveName;\n    this.args = args;\n  }\n\n  transformSchema(originalSchema) {\n    const transformer = new FilterObjectFields((_typeName, _fieldName, fieldConfig) => {\n      const valueMap = getDirectives(originalSchema, fieldConfig);\n      return !Object.keys(valueMap).some(directiveName => valueMatchesCriteria(directiveName, this.directiveName) && (Array.isArray(valueMap[directiveName]) && valueMap[directiveName].some(value => valueMatchesCriteria(value, this.args)) || valueMatchesCriteria(valueMap[directiveName], this.args)));\n    });\n    return transformer.transformSchema(originalSchema);\n  }\n\n}\n\nclass RemoveObjectFieldDeprecations {\n  constructor(reason) {\n    const args = {\n      reason\n    };\n    this.removeDirectives = new FilterObjectFieldDirectives((dirName, dirValue) => {\n      return !(dirName === 'deprecated' && valueMatchesCriteria(dirValue, args));\n    });\n    this.removeDeprecations = new TransformObjectFields((_typeName, _fieldName, fieldConfig) => {\n      if (fieldConfig.deprecationReason && valueMatchesCriteria(fieldConfig.deprecationReason, reason)) {\n        fieldConfig = { ...fieldConfig\n        };\n        delete fieldConfig.deprecationReason;\n      }\n\n      return fieldConfig;\n    });\n  }\n\n  transformSchema(originalSchema) {\n    return this.removeDeprecations.transformSchema(this.removeDirectives.transformSchema(originalSchema));\n  }\n\n}\n\nclass RemoveObjectFieldsWithDeprecation {\n  constructor(reason) {\n    this.transformer = new FilterObjectFields((_typeName, _fieldName, fieldConfig) => {\n      if (fieldConfig.deprecationReason) {\n        return !valueMatchesCriteria(fieldConfig.deprecationReason, reason);\n      }\n\n      return true;\n    });\n  }\n\n  transformSchema(originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  }\n\n}\n\nclass MapFields {\n  constructor(fieldNodeTransformerMap, objectValueTransformerMap, errorsTransformer) {\n    this.transformer = new TransformCompositeFields(() => undefined, (typeName, fieldName, fieldNode, fragments, transformationContext) => {\n      const typeTransformers = fieldNodeTransformerMap[typeName];\n\n      if (typeTransformers == null) {\n        return undefined;\n      }\n\n      const fieldNodeTransformer = typeTransformers[fieldName];\n\n      if (fieldNodeTransformer == null) {\n        return undefined;\n      }\n\n      return fieldNodeTransformer(fieldNode, fragments, transformationContext);\n    }, objectValueTransformerMap != null ? (data, transformationContext) => {\n      if (data == null) {\n        return data;\n      }\n\n      const typeName = data.__typename;\n\n      if (typeName == null) {\n        return data;\n      }\n\n      const transformer = objectValueTransformerMap[typeName];\n\n      if (transformer == null) {\n        return data;\n      }\n\n      return transformer(data, transformationContext);\n    } : undefined, errorsTransformer != null ? errorsTransformer : undefined);\n  }\n\n  transformSchema(schema) {\n    return this.transformer.transformSchema(schema);\n  }\n\n  transformRequest(originalRequest, delegationContext, transformationContext) {\n    return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n  }\n\n  transformResult(originalResult, delegationContext, transformationContext) {\n    return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n  }\n\n}\n\nclass ExtendSchema {\n  constructor({\n    typeDefs,\n    resolvers = {},\n    defaultFieldResolver,\n    fieldNodeTransformerMap,\n    objectValueTransformerMap,\n    errorsTransformer\n  }) {\n    this.typeDefs = typeDefs;\n    this.resolvers = resolvers;\n    this.defaultFieldResolver = defaultFieldResolver != null ? defaultFieldResolver : defaultMergedResolver;\n    this.transformer = new MapFields(fieldNodeTransformerMap != null ? fieldNodeTransformerMap : {}, objectValueTransformerMap, errorsTransformer);\n  }\n\n  transformSchema(schema) {\n    // MapFields's transformSchema function does not actually modify the schema --\n    // it saves the current schema state, to be used later to transform requests.\n    this.transformer.transformSchema(schema);\n    return addResolversToSchema({\n      schema: this.typeDefs ? extendSchema(schema, parse(this.typeDefs)) : schema,\n      resolvers: this.resolvers != null ? this.resolvers : {},\n      defaultFieldResolver: this.defaultFieldResolver\n    });\n  }\n\n  transformRequest(originalRequest, delegationContext, transformationContext) {\n    return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n  }\n\n  transformResult(originalResult, delegationContext, transformationContext) {\n    return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n  }\n\n}\n\nclass PruneTypes {\n  constructor(options) {\n    this.options = options;\n  }\n\n  transformSchema(schema) {\n    return pruneSchema(schema, this.options);\n  }\n\n}\n\nfunction defaultWrappingResolver(parent, args, context, info) {\n  if (!parent) {\n    return {};\n  }\n\n  return defaultMergedResolver(parent, args, context, info);\n}\n\nclass WrapFields {\n  constructor(outerTypeName, wrappingFieldNames, wrappingTypeNames, fieldNames, wrappingResolver = defaultWrappingResolver, prefix = 'gqtld') {\n    this.outerTypeName = outerTypeName;\n    this.wrappingFieldNames = wrappingFieldNames;\n    this.wrappingTypeNames = wrappingTypeNames;\n    this.numWraps = wrappingFieldNames.length;\n    this.fieldNames = fieldNames;\n    this.wrappingResolver = wrappingResolver;\n    const remainingWrappingFieldNames = this.wrappingFieldNames.slice();\n    const outerMostWrappingFieldName = remainingWrappingFieldNames.shift();\n    this.transformer = new MapFields({\n      [outerTypeName]: {\n        [outerMostWrappingFieldName]: (fieldNode, fragments, transformationContext) => hoistFieldNodes({\n          fieldNode,\n          path: remainingWrappingFieldNames,\n          fieldNames,\n          fragments,\n          transformationContext,\n          prefix\n        })\n      }\n    }, {\n      [outerTypeName]: (value, context) => dehoistValue(value, context)\n    }, (errors, context) => dehoistErrors(errors, context));\n  }\n\n  transformSchema(schema) {\n    const targetFieldConfigMap = selectObjectFields(schema, this.outerTypeName, !this.fieldNames ? () => true : fieldName => this.fieldNames.includes(fieldName));\n    let wrapIndex = this.numWraps - 1;\n    let wrappingTypeName = this.wrappingTypeNames[wrapIndex];\n    let wrappingFieldName = this.wrappingFieldNames[wrapIndex];\n    let newSchema = appendObjectFields(schema, wrappingTypeName, targetFieldConfigMap);\n\n    for (wrapIndex--; wrapIndex > -1; wrapIndex--) {\n      const nextWrappingTypeName = this.wrappingTypeNames[wrapIndex];\n      newSchema = appendObjectFields(newSchema, nextWrappingTypeName, {\n        [wrappingFieldName]: {\n          type: newSchema.getType(wrappingTypeName),\n          resolve: this.wrappingResolver\n        }\n      });\n      wrappingTypeName = nextWrappingTypeName;\n      wrappingFieldName = this.wrappingFieldNames[wrapIndex];\n    }\n\n    const selectedFieldNames = Object.keys(targetFieldConfigMap);\n    [newSchema] = modifyObjectFields(newSchema, this.outerTypeName, fieldName => selectedFieldNames.includes(fieldName), {\n      [wrappingFieldName]: {\n        type: newSchema.getType(wrappingTypeName),\n        resolve: this.wrappingResolver\n      }\n    });\n    return this.transformer.transformSchema(newSchema);\n  }\n\n  transformRequest(originalRequest, delegationContext, transformationContext) {\n    transformationContext.nextIndex = 0;\n    transformationContext.paths = Object.create(null);\n    return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n  }\n\n  transformResult(originalResult, delegationContext, transformationContext) {\n    return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n  }\n\n}\n\nfunction collectFields(selectionSet, fragments, fields = [], visitedFragmentNames = {}) {\n  if (selectionSet != null) {\n    selectionSet.selections.forEach(selection => {\n      switch (selection.kind) {\n        case Kind.FIELD:\n          fields.push(selection);\n          break;\n\n        case Kind.INLINE_FRAGMENT:\n          collectFields(selection.selectionSet, fragments, fields, visitedFragmentNames);\n          break;\n\n        case Kind.FRAGMENT_SPREAD:\n          {\n            const fragmentName = selection.name.value;\n\n            if (!visitedFragmentNames[fragmentName]) {\n              visitedFragmentNames[fragmentName] = true;\n              collectFields(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n  return fields;\n}\n\nfunction aliasFieldNode(fieldNode, str) {\n  return { ...fieldNode,\n    alias: {\n      kind: Kind.NAME,\n      value: str\n    }\n  };\n}\n\nfunction hoistFieldNodes({\n  fieldNode,\n  fieldNames,\n  path,\n  fragments,\n  transformationContext,\n  prefix,\n  index = 0,\n  wrappingPath = []\n}) {\n  const alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;\n  let newFieldNodes = [];\n\n  if (index < path.length) {\n    const pathSegment = path[index];\n    collectFields(fieldNode.selectionSet, fragments).forEach(possibleFieldNode => {\n      if (possibleFieldNode.name.value === pathSegment) {\n        const newWrappingPath = wrappingPath.concat([alias]);\n        newFieldNodes = newFieldNodes.concat(hoistFieldNodes({\n          fieldNode: possibleFieldNode,\n          fieldNames,\n          path,\n          fragments,\n          transformationContext,\n          prefix,\n          index: index + 1,\n          wrappingPath: newWrappingPath\n        }));\n      }\n    });\n  } else {\n    collectFields(fieldNode.selectionSet, fragments).forEach(possibleFieldNode => {\n      if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {\n        const nextIndex = transformationContext.nextIndex;\n        transformationContext.nextIndex++;\n        const indexingAlias = `__${prefix}${nextIndex}__`;\n        transformationContext.paths[indexingAlias] = {\n          pathToField: wrappingPath.concat([alias]),\n          alias: possibleFieldNode.alias != null ? possibleFieldNode.alias.value : possibleFieldNode.name.value\n        };\n        newFieldNodes.push(aliasFieldNode(possibleFieldNode, indexingAlias));\n      }\n    });\n  }\n\n  return newFieldNodes;\n}\n\nfunction dehoistValue(originalValue, context) {\n  if (originalValue == null) {\n    return originalValue;\n  }\n\n  const newValue = Object.create(null);\n  Object.keys(originalValue).forEach(alias => {\n    let obj = newValue;\n    const path = context.paths[alias];\n\n    if (path == null) {\n      newValue[alias] = originalValue[alias];\n      return;\n    }\n\n    const pathToField = path.pathToField;\n    const fieldAlias = path.alias;\n    pathToField.forEach(key => {\n      obj = obj[key] = obj[key] || Object.create(null);\n    });\n    obj[fieldAlias] = originalValue[alias];\n  });\n  return newValue;\n}\n\nfunction dehoistErrors(errors, context) {\n  if (errors === undefined) {\n    return undefined;\n  }\n\n  return errors.map(error => {\n    const originalPath = error.path;\n\n    if (originalPath == null) {\n      return error;\n    }\n\n    let newPath = [];\n    originalPath.forEach(pathSegment => {\n      if (typeof pathSegment !== 'string') {\n        newPath.push(pathSegment);\n        return;\n      }\n\n      const path = context.paths[pathSegment];\n\n      if (path == null) {\n        newPath.push(pathSegment);\n        return;\n      }\n\n      newPath = newPath.concat(path.pathToField, [path.alias]);\n    });\n    return relocatedError(error, newPath);\n  });\n}\n\nclass WrapType {\n  constructor(outerTypeName, innerTypeName, fieldName) {\n    this.transformer = new WrapFields(outerTypeName, [fieldName], [innerTypeName]);\n  }\n\n  transformSchema(schema) {\n    return this.transformer.transformSchema(schema);\n  }\n\n  transformRequest(originalRequest, delegationContext, transformationContext) {\n    return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n  }\n\n  transformResult(originalResult, delegationContext, transformationContext) {\n    return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n  }\n\n}\n\nclass HoistField {\n  constructor(typeName, path, newFieldName, alias = '__gqtlw__') {\n    this.typeName = typeName;\n    this.newFieldName = newFieldName;\n    const pathToField = path.slice();\n    const oldFieldName = pathToField.pop();\n    this.oldFieldName = oldFieldName;\n    this.pathToField = pathToField;\n    this.transformer = new MapFields({\n      [typeName]: {\n        [newFieldName]: fieldNode => wrapFieldNode(renameFieldNode(fieldNode, oldFieldName), pathToField, alias)\n      }\n    }, {\n      [typeName]: value => unwrapValue(value, alias)\n    }, errors => unwrapErrors(errors, alias));\n  }\n\n  transformSchema(schema) {\n    const innerType = this.pathToField.reduce((acc, pathSegment) => getNullableType(acc.getFields()[pathSegment].type), schema.getType(this.typeName));\n    let [newSchema, targetFieldConfigMap] = removeObjectFields(schema, innerType.name, fieldName => fieldName === this.oldFieldName);\n    const targetField = targetFieldConfigMap[this.oldFieldName];\n    const targetType = targetField.type;\n    newSchema = appendObjectFields(newSchema, this.typeName, {\n      [this.newFieldName]: {\n        type: targetType,\n        resolve: defaultMergedResolver\n      }\n    });\n    return this.transformer.transformSchema(newSchema);\n  }\n\n  transformRequest(originalRequest, delegationContext, transformationContext) {\n    return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n  }\n\n  transformResult(originalResult, delegationContext, transformationContext) {\n    return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n  }\n\n}\n\nfunction wrapFieldNode(fieldNode, path, alias) {\n  let newFieldNode = fieldNode;\n  path.forEach(fieldName => {\n    newFieldNode = {\n      kind: Kind.FIELD,\n      alias: {\n        kind: Kind.NAME,\n        value: alias\n      },\n      name: {\n        kind: Kind.NAME,\n        value: fieldName\n      },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [fieldNode]\n      }\n    };\n  });\n  return newFieldNode;\n}\n\nfunction unwrapValue(originalValue, alias) {\n  let newValue = originalValue;\n  let object = newValue[alias];\n\n  while (object != null) {\n    newValue = object;\n    object = newValue[alias];\n  }\n\n  delete originalValue[alias];\n  Object.assign(originalValue, newValue);\n  return originalValue;\n}\n\nfunction unwrapErrors(errors, alias) {\n  if (errors === undefined) {\n    return undefined;\n  }\n\n  return errors.map(error => {\n    const originalPath = error.path;\n\n    if (originalPath == null) {\n      return error;\n    }\n\n    const newPath = originalPath.filter(pathSegment => pathSegment !== alias);\n    return relocatedError(error, newPath);\n  });\n}\n\nclass WrapQuery {\n  constructor(path, wrapper, extractor) {\n    this.path = path;\n    this.wrapper = wrapper;\n    this.extractor = extractor;\n  }\n\n  transformRequest(originalRequest) {\n    const fieldPath = [];\n    const ourPath = JSON.stringify(this.path);\n    const document = visit(originalRequest.document, {\n      [Kind.FIELD]: {\n        enter: node => {\n          fieldPath.push(node.name.value);\n\n          if (ourPath === JSON.stringify(fieldPath)) {\n            const wrapResult = this.wrapper(node.selectionSet); // Selection can be either a single selection or a selection set. If it's just one selection,\n            // let's wrap it in a selection set. Otherwise, keep it as is.\n\n            const selectionSet = wrapResult != null && wrapResult.kind === Kind.SELECTION_SET ? wrapResult : {\n              kind: Kind.SELECTION_SET,\n              selections: [wrapResult]\n            };\n            return { ...node,\n              selectionSet\n            };\n          }\n        },\n        leave: () => {\n          fieldPath.pop();\n        }\n      }\n    });\n    return { ...originalRequest,\n      document\n    };\n  }\n\n  transformResult(originalResult) {\n    const rootData = originalResult.data;\n\n    if (rootData != null) {\n      let data = rootData;\n      const path = [...this.path];\n\n      while (path.length > 1) {\n        const next = path.shift();\n\n        if (data[next]) {\n          data = data[next];\n        }\n      }\n\n      data[path[0]] = this.extractor(data[path[0]]);\n    }\n\n    return {\n      data: rootData,\n      errors: originalResult.errors\n    };\n  }\n\n}\n\nclass ExtractField {\n  constructor({\n    from,\n    to\n  }) {\n    this.from = from;\n    this.to = to;\n  }\n\n  transformRequest(originalRequest) {\n    let fromSelection;\n    const ourPathFrom = JSON.stringify(this.from);\n    const ourPathTo = JSON.stringify(this.to);\n    let fieldPath = [];\n    visit(originalRequest.document, {\n      [Kind.FIELD]: {\n        enter: node => {\n          fieldPath.push(node.name.value);\n\n          if (ourPathFrom === JSON.stringify(fieldPath)) {\n            fromSelection = node.selectionSet;\n            return BREAK;\n          }\n        },\n        leave: () => {\n          fieldPath.pop();\n        }\n      }\n    });\n    fieldPath = [];\n    const document = visit(originalRequest.document, {\n      [Kind.FIELD]: {\n        enter: node => {\n          fieldPath.push(node.name.value);\n\n          if (ourPathTo === JSON.stringify(fieldPath) && fromSelection != null) {\n            return { ...node,\n              selectionSet: fromSelection\n            };\n          }\n        },\n        leave: () => {\n          fieldPath.pop();\n        }\n      }\n    });\n    return { ...originalRequest,\n      document\n    };\n  }\n\n}\n\nfunction makeRemoteExecutableSchema({\n  schema: schemaOrTypeDefs,\n  executor,\n  subscriber,\n  createResolver = defaultCreateRemoteResolver,\n  buildSchemaOptions\n}) {\n  const targetSchema = typeof schemaOrTypeDefs === 'string' ? buildSchema(schemaOrTypeDefs, buildSchemaOptions) : schemaOrTypeDefs;\n  return wrapSchema({\n    schema: targetSchema,\n    createProxyingResolver: () => createResolver(executor, subscriber)\n  });\n}\n\nfunction defaultCreateRemoteResolver(executor, subscriber) {\n  return (_parent, _args, context, info) => delegateToSchema({\n    schema: {\n      schema: info.schema,\n      executor,\n      subscriber\n    },\n    context,\n    info\n  });\n}\n\nvar cleanInternalStack = function (stack) {\n  return stack.replace(/\\s+at .*aggregate-error\\/index.js:\\d+:\\d+\\)?/g, '');\n};\n/**\r\nEscape RegExp special characters.\r\nYou can also use this to escape a string that is inserted into the middle of a regex, for example, into a character class.\r\n@example\r\n```\r\nimport escapeStringRegexp = require('escape-string-regexp');\r\nconst escapedString = escapeStringRegexp('How much $ for a 🦄?');\r\n//=> 'How much \\\\$ for a 🦄\\\\?'\r\nnew RegExp(escapedString);\r\n```\r\n*/\n\n\nvar escapeStringRegexp = function (string) {\n  if (typeof string !== 'string') {\n    throw new TypeError('Expected a string');\n  } // Escape characters with special meaning either inside or outside character sets.\n  // Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\n\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&').replace(/-/g, '\\\\x2d');\n};\n\nvar extractPathRegex = /\\s+at.*[(\\s](.*)\\)?/;\nvar pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:babel-polyfill|pirates)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/;\n/**\r\nClean up error stack traces. Removes the mostly unhelpful internal Node.js entries.\r\n@param stack - The `stack` property of an `Error`.\r\n@example\r\n```\r\nimport cleanStack = require('clean-stack');\r\nconst error = new Error('Missing unicorn');\r\nconsole.log(error.stack);\r\n// Error: Missing unicorn\r\n//     at Object.<anonymous> (/Users/sindresorhus/dev/clean-stack/unicorn.js:2:15)\r\n//     at Module._compile (module.js:409:26)\r\n//     at Object.Module._extensions..js (module.js:416:10)\r\n//     at Module.load (module.js:343:32)\r\n//     at Function.Module._load (module.js:300:12)\r\n//     at Function.Module.runMain (module.js:441:10)\r\n//     at startup (node.js:139:18)\r\nconsole.log(cleanStack(error.stack));\r\n// Error: Missing unicorn\r\n//     at Object.<anonymous> (/Users/sindresorhus/dev/clean-stack/unicorn.js:2:15)\r\n```\r\n*/\n\nvar cleanStack = function (stack, basePath) {\n  var basePathRegex = basePath && new RegExp(\"(at | \\\\()\" + escapeStringRegexp(basePath), 'g');\n  return stack.replace(/\\\\/g, '/').split('\\n').filter(function (line) {\n    var pathMatches = line.match(extractPathRegex);\n\n    if (pathMatches === null || !pathMatches[1]) {\n      return true;\n    }\n\n    var match = pathMatches[1]; // Electron\n\n    if (match.includes('.app/Contents/Resources/electron.asar') || match.includes('.app/Contents/Resources/default_app.asar')) {\n      return false;\n    }\n\n    return !pathRegex.test(match);\n  }).filter(function (line) {\n    return line.trim() !== '';\n  }).map(function (line) {\n    if (basePathRegex) {\n      line = line.replace(basePathRegex, '$1');\n    }\n\n    return line;\n  }).join('\\n');\n};\n/**\r\nIndent each line in a string.\r\n@param string - The string to indent.\r\n@param count - How many times you want `options.indent` repeated. Default: `1`.\r\n@example\r\n```\r\nimport indentString = require('indent-string');\r\nindentString('Unicorns\\nRainbows', 4);\r\n//=> '    Unicorns\\n    Rainbows'\r\nindentString('Unicorns\\nRainbows', 4, {indent: '♥'});\r\n//=> '♥♥♥♥Unicorns\\n♥♥♥♥Rainbows'\r\n```\r\n*/\n\n\nvar indentString = function (string, count, options) {\n  if (count === void 0) {\n    count = 1;\n  }\n\n  options = Object.assign({\n    indent: ' ',\n    includeEmptyLines: false\n  }, options);\n\n  if (typeof string !== 'string') {\n    throw new TypeError(\"Expected `input` to be a `string`, got `\" + typeof string + \"`\");\n  }\n\n  if (typeof count !== 'number') {\n    throw new TypeError(\"Expected `count` to be a `number`, got `\" + typeof count + \"`\");\n  }\n\n  if (count < 0) {\n    throw new RangeError(\"Expected `count` to be at least 0, got `\" + count + \"`\");\n  }\n\n  if (typeof options.indent !== 'string') {\n    throw new TypeError(\"Expected `options.indent` to be a `string`, got `\" + typeof options.indent + \"`\");\n  }\n\n  if (count === 0) {\n    return string;\n  }\n\n  var regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\n  return string.replace(regex, options.indent.repeat(count));\n};\n\nvar AggregateError =\n/** @class */\nfunction (_super) {\n  __extends(AggregateError, _super);\n\n  function AggregateError(errors) {\n    var _this = this;\n\n    if (!Array.isArray(errors)) {\n      throw new TypeError(\"Expected input to be an Array, got \" + typeof errors);\n    }\n\n    var normalizedErrors = errors.map(function (error) {\n      if (error instanceof Error) {\n        return error;\n      }\n\n      if (error !== null && typeof error === 'object') {\n        // Handle plain error objects with message property and/or possibly other metadata\n        return Object.assign(new Error(error.message), error);\n      }\n\n      return new Error(error);\n    });\n    var message = normalizedErrors.map(function (error) {\n      // The `stack` property is not standardized, so we can't assume it exists\n      return typeof error.stack === 'string' ? cleanInternalStack(cleanStack(error.stack)) : String(error);\n    }).join('\\n');\n    message = '\\n' + indentString(message, 4);\n    _this = _super.call(this, message) || this;\n    _this.name = 'AggregateError';\n    Object.defineProperty(_this, Symbol.iterator, {\n      get: function () {\n        return function () {\n          return normalizedErrors[Symbol.iterator]();\n        };\n      }\n    });\n    return _this;\n  }\n\n  return AggregateError;\n}(Error);\n\nfunction getSchemaFromIntrospection(introspectionResult) {\n  var _a, _b;\n\n  if ((_a = introspectionResult === null || introspectionResult === void 0 ? void 0 : introspectionResult.data) === null || _a === void 0 ? void 0 : _a.__schema) {\n    return buildClientSchema(introspectionResult.data);\n  } else if ((_b = introspectionResult === null || introspectionResult === void 0 ? void 0 : introspectionResult.errors) === null || _b === void 0 ? void 0 : _b.length) {\n    if (introspectionResult.errors.length > 1) {\n      const combinedError = new AggregateError(introspectionResult.errors);\n      throw combinedError;\n    }\n\n    const error = introspectionResult.errors[0];\n    throw error.originalError || error;\n  } else {\n    throw new Error('Could not obtain introspection result, received: ' + JSON.stringify(introspectionResult));\n  }\n}\n\nasync function introspectSchema(executor, context, options) {\n  const parsedIntrospectionQuery = parse(getIntrospectionQuery(options));\n  const introspectionResult = await executor({\n    document: parsedIntrospectionQuery,\n    context\n  });\n  return getSchemaFromIntrospection(introspectionResult);\n}\n\nfunction introspectSchemaSync(executor, context, options) {\n  const parsedIntrospectionQuery = parse(getIntrospectionQuery(options));\n  const introspectionResult = executor({\n    document: parsedIntrospectionQuery,\n    context\n  });\n\n  if ('then' in introspectionResult) {\n    throw new Error(`Executor cannot return promise value in introspectSchemaSync!`);\n  }\n\n  return getSchemaFromIntrospection(introspectionResult);\n}\n\nexport { ExtendSchema, ExtractField, FilterInputObjectFields, FilterInterfaceFields, FilterObjectFieldDirectives, FilterObjectFields, FilterRootFields, FilterTypes, HoistField, MapFields, MapLeafValues, PruneTypes as PruneSchema, RemoveObjectFieldDeprecations, RemoveObjectFieldDirectives, RemoveObjectFieldsWithDeprecation, RemoveObjectFieldsWithDirective, RenameInputObjectFields, RenameInterfaceFields, RenameObjectFields, RenameRootFields, RenameRootTypes, RenameTypes, TransformCompositeFields, TransformEnumValues, TransformInputObjectFields, TransformInterfaceFields, TransformObjectFields, TransformQuery, TransformRootFields, WrapFields, WrapQuery, WrapType, defaultCreateProxyingResolver, defaultCreateRemoteResolver, generateProxyingResolvers, introspectSchema, introspectSchemaSync, makeRemoteExecutableSchema, wrapSchema };","map":{"version":3,"sources":["../../../dist/wrap/src/generateProxyingResolvers.js","../../../dist/wrap/src/wrapSchema.js","../../../dist/wrap/src/transforms/RenameTypes.js","../../../dist/wrap/src/transforms/FilterTypes.js","../../../dist/wrap/src/transforms/RenameRootTypes.js","../../../dist/wrap/src/transforms/TransformCompositeFields.js","../../../dist/wrap/src/transforms/TransformObjectFields.js","../../../dist/wrap/src/transforms/TransformRootFields.js","../../../dist/wrap/src/transforms/RenameRootFields.js","../../../dist/wrap/src/transforms/FilterRootFields.js","../../../dist/wrap/src/transforms/RenameObjectFields.js","../../../dist/wrap/src/transforms/FilterObjectFields.js","../../../dist/wrap/src/transforms/TransformInterfaceFields.js","../../../dist/wrap/src/transforms/RenameInterfaceFields.js","../../../dist/wrap/src/transforms/FilterInterfaceFields.js","../../../dist/wrap/src/transforms/TransformInputObjectFields.js","../../../dist/wrap/src/transforms/RenameInputObjectFields.js","../../../dist/wrap/src/transforms/FilterInputObjectFields.js","../../../dist/wrap/src/transforms/MapLeafValues.js","../../../dist/wrap/src/transforms/TransformEnumValues.js","../../../dist/wrap/src/transforms/TransformQuery.js","../../../dist/wrap/src/transforms/FilterObjectFieldDirectives.js","../../../dist/wrap/src/transforms/RemoveObjectFieldDirectives.js","../../../dist/wrap/src/transforms/RemoveObjectFieldsWithDirective.js","../../../dist/wrap/src/transforms/RemoveObjectFieldDeprecations.js","../../../dist/wrap/src/transforms/RemoveObjectFieldsWithDeprecation.js","../../../dist/wrap/src/transforms/MapFields.js","../../../dist/wrap/src/transforms/ExtendSchema.js","../../../dist/wrap/src/transforms/PruneSchema.js","../../../dist/wrap/src/transforms/WrapFields.js","../../../dist/wrap/src/transforms/WrapType.js","../../../dist/wrap/src/transforms/HoistField.js","../../../dist/wrap/src/transforms/WrapQuery.js","../../../dist/wrap/src/transforms/ExtractField.js","../../../dist/wrap/src/makeRemoteExecutableSchema.js","../../../node_modules/@ardatan/aggregate-error/index.esm.js","../../../dist/wrap/src/introspect.js"],"names":[],"mappings":"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","sourcesContent":["import { getResponseKeyFromInfo, getErrors, applySchemaTransforms } from '@graphql-tools/utils';\nimport { delegateToSchema, getSubschema, handleResult, isSubschemaConfig, } from '@graphql-tools/delegate';\nexport function generateProxyingResolvers(subschemaOrSubschemaConfig, transforms) {\n    var _a;\n    let targetSchema;\n    let schemaTransforms = [];\n    let createProxyingResolver;\n    if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\n        targetSchema = subschemaOrSubschemaConfig.schema;\n        createProxyingResolver = (_a = subschemaOrSubschemaConfig.createProxyingResolver) !== null && _a !== void 0 ? _a : defaultCreateProxyingResolver;\n        if (subschemaOrSubschemaConfig.transforms != null) {\n            schemaTransforms = schemaTransforms.concat(subschemaOrSubschemaConfig.transforms);\n        }\n    }\n    else {\n        targetSchema = subschemaOrSubschemaConfig;\n        createProxyingResolver = defaultCreateProxyingResolver;\n    }\n    if (transforms != null) {\n        schemaTransforms = schemaTransforms.concat(transforms);\n    }\n    const transformedSchema = applySchemaTransforms(targetSchema, schemaTransforms);\n    const operationTypes = {\n        query: targetSchema.getQueryType(),\n        mutation: targetSchema.getMutationType(),\n        subscription: targetSchema.getSubscriptionType(),\n    };\n    const resolvers = {};\n    Object.keys(operationTypes).forEach((operation) => {\n        const rootType = operationTypes[operation];\n        if (rootType != null) {\n            const typeName = rootType.name;\n            const fields = rootType.getFields();\n            resolvers[typeName] = {};\n            Object.keys(fields).forEach(fieldName => {\n                const proxyingResolver = createProxyingResolver({\n                    schema: subschemaOrSubschemaConfig,\n                    transforms,\n                    transformedSchema,\n                    operation,\n                    fieldName,\n                });\n                const finalResolver = createPossiblyNestedProxyingResolver(subschemaOrSubschemaConfig, proxyingResolver);\n                if (operation === 'subscription') {\n                    resolvers[typeName][fieldName] = {\n                        subscribe: finalResolver,\n                        resolve: (payload, _, __, { fieldName: targetFieldName }) => payload[targetFieldName],\n                    };\n                }\n                else {\n                    resolvers[typeName][fieldName] = {\n                        resolve: finalResolver,\n                    };\n                }\n            });\n        }\n    });\n    return resolvers;\n}\nfunction createPossiblyNestedProxyingResolver(subschemaOrSubschemaConfig, proxyingResolver) {\n    return (parent, args, context, info) => {\n        if (parent != null) {\n            const responseKey = getResponseKeyFromInfo(info);\n            const errors = getErrors(parent, responseKey);\n            // Check to see if the parent contains a proxied result\n            if (errors != null) {\n                const subschema = getSubschema(parent, responseKey);\n                // If there is a proxied result from this subschema, return it\n                // This can happen even for a root field when the root type ia\n                // also nested as a field within a different type.\n                if (subschemaOrSubschemaConfig === subschema && parent[responseKey] !== undefined) {\n                    return handleResult(parent[responseKey], errors, subschema, context, info);\n                }\n            }\n        }\n        return proxyingResolver(parent, args, context, info);\n    };\n}\nexport function defaultCreateProxyingResolver({ schema, operation, transforms, transformedSchema, }) {\n    return (_parent, _args, context, info) => delegateToSchema({\n        schema,\n        operation,\n        context,\n        info,\n        transforms,\n        transformedSchema,\n    });\n}\n//# sourceMappingURL=generateProxyingResolvers.js.map","import { GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, } from 'graphql';\nimport { MapperKind, mapSchema, applySchemaTransforms } from '@graphql-tools/utils';\nimport { isSubschemaConfig, defaultMergedResolver } from '@graphql-tools/delegate';\nimport { generateProxyingResolvers } from './generateProxyingResolvers';\nexport function wrapSchema(subschemaOrSubschemaConfig, transforms) {\n    let targetSchema;\n    let schemaTransforms = [];\n    if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\n        targetSchema = subschemaOrSubschemaConfig.schema;\n        if (subschemaOrSubschemaConfig.transforms != null) {\n            schemaTransforms = schemaTransforms.concat(subschemaOrSubschemaConfig.transforms);\n        }\n    }\n    else {\n        targetSchema = subschemaOrSubschemaConfig;\n    }\n    if (transforms != null) {\n        schemaTransforms = schemaTransforms.concat(transforms);\n    }\n    const proxyingResolvers = generateProxyingResolvers(subschemaOrSubschemaConfig, transforms);\n    const schema = createWrappingSchema(targetSchema, proxyingResolvers);\n    return applySchemaTransforms(schema, schemaTransforms);\n}\nfunction createWrappingSchema(schema, proxyingResolvers) {\n    return mapSchema(schema, {\n        [MapperKind.ROOT_OBJECT]: type => {\n            const config = type.toConfig();\n            const fieldConfigMap = config.fields;\n            Object.keys(fieldConfigMap).forEach(fieldName => {\n                fieldConfigMap[fieldName] = {\n                    ...fieldConfigMap[fieldName],\n                    ...proxyingResolvers[type.name][fieldName],\n                };\n            });\n            return new GraphQLObjectType(config);\n        },\n        [MapperKind.OBJECT_TYPE]: type => {\n            const config = type.toConfig();\n            config.isTypeOf = undefined;\n            Object.keys(config.fields).forEach(fieldName => {\n                config.fields[fieldName].resolve = defaultMergedResolver;\n                config.fields[fieldName].subscribe = null;\n            });\n            return new GraphQLObjectType(config);\n        },\n        [MapperKind.INTERFACE_TYPE]: type => {\n            const config = type.toConfig();\n            delete config.resolveType;\n            return new GraphQLInterfaceType(config);\n        },\n        [MapperKind.UNION_TYPE]: type => {\n            const config = type.toConfig();\n            delete config.resolveType;\n            return new GraphQLUnionType(config);\n        },\n    });\n}\n//# sourceMappingURL=wrapSchema.js.map","import { Kind, isScalarType, isSpecifiedScalarType, visit, } from 'graphql';\nimport { MapperKind, mapSchema, visitData, renameType, } from '@graphql-tools/utils';\nexport default class RenameTypes {\n    constructor(renamer, options) {\n        this.renamer = renamer;\n        this.map = Object.create(null);\n        this.reverseMap = Object.create(null);\n        const { renameBuiltins = false, renameScalars = true } = options != null ? options : {};\n        this.renameBuiltins = renameBuiltins;\n        this.renameScalars = renameScalars;\n    }\n    transformSchema(originalSchema) {\n        return mapSchema(originalSchema, {\n            [MapperKind.TYPE]: (type) => {\n                if (isSpecifiedScalarType(type) && !this.renameBuiltins) {\n                    return undefined;\n                }\n                if (isScalarType(type) && !this.renameScalars) {\n                    return undefined;\n                }\n                const oldName = type.name;\n                const newName = this.renamer(oldName);\n                if (newName !== undefined && newName !== oldName) {\n                    this.map[oldName] = newName;\n                    this.reverseMap[newName] = oldName;\n                    return renameType(type, newName);\n                }\n            },\n            [MapperKind.ROOT_OBJECT]() {\n                return undefined;\n            },\n        });\n    }\n    transformRequest(originalRequest) {\n        const document = visit(originalRequest.document, {\n            [Kind.NAMED_TYPE]: (node) => {\n                const name = node.name.value;\n                if (name in this.reverseMap) {\n                    return {\n                        ...node,\n                        name: {\n                            kind: Kind.NAME,\n                            value: this.reverseMap[name],\n                        },\n                    };\n                }\n            },\n        });\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n    transformResult(result) {\n        return {\n            ...result,\n            data: visitData(result.data, object => {\n                const typeName = object === null || object === void 0 ? void 0 : object.__typename;\n                if (typeName != null && typeName in this.map) {\n                    object.__typename = this.map[typeName];\n                }\n                return object;\n            }),\n        };\n    }\n}\n//# sourceMappingURL=RenameTypes.js.map","import { mapSchema, MapperKind } from '@graphql-tools/utils';\nexport default class FilterTypes {\n    constructor(filter) {\n        this.filter = filter;\n    }\n    transformSchema(schema) {\n        return mapSchema(schema, {\n            [MapperKind.TYPE]: (type) => {\n                if (this.filter(type)) {\n                    return undefined;\n                }\n                return null;\n            },\n        });\n    }\n}\n//# sourceMappingURL=FilterTypes.js.map","import { visit, Kind } from 'graphql';\nimport { MapperKind, mapSchema, renameType, visitData, } from '@graphql-tools/utils';\nexport default class RenameRootTypes {\n    constructor(renamer) {\n        this.renamer = renamer;\n        this.map = Object.create(null);\n        this.reverseMap = Object.create(null);\n    }\n    transformSchema(originalSchema) {\n        return mapSchema(originalSchema, {\n            [MapperKind.ROOT_OBJECT]: type => {\n                const oldName = type.name;\n                const newName = this.renamer(oldName);\n                if (newName !== undefined && newName !== oldName) {\n                    this.map[oldName] = newName;\n                    this.reverseMap[newName] = oldName;\n                    return renameType(type, newName);\n                }\n            },\n        });\n    }\n    transformRequest(originalRequest) {\n        const document = visit(originalRequest.document, {\n            [Kind.NAMED_TYPE]: (node) => {\n                const name = node.name.value;\n                if (name in this.reverseMap) {\n                    return {\n                        ...node,\n                        name: {\n                            kind: Kind.NAME,\n                            value: this.reverseMap[name],\n                        },\n                    };\n                }\n            },\n        });\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n    transformResult(result) {\n        return {\n            ...result,\n            data: visitData(result.data, object => {\n                const typeName = object === null || object === void 0 ? void 0 : object.__typename;\n                if (typeName != null && typeName in this.map) {\n                    object.__typename = this.map[typeName];\n                }\n                return object;\n            }),\n        };\n    }\n}\n//# sourceMappingURL=RenameRootTypes.js.map","import { TypeInfo, visit, visitWithTypeInfo, Kind, } from 'graphql';\nimport { MapperKind, mapSchema, visitData } from '@graphql-tools/utils';\nexport default class TransformCompositeFields {\n    constructor(fieldTransformer, fieldNodeTransformer, dataTransformer, errorsTransformer) {\n        this.fieldTransformer = fieldTransformer;\n        this.fieldNodeTransformer = fieldNodeTransformer;\n        this.dataTransformer = dataTransformer;\n        this.errorsTransformer = errorsTransformer;\n        this.mapping = {};\n    }\n    transformSchema(originalSchema) {\n        this.transformedSchema = mapSchema(originalSchema, {\n            [MapperKind.COMPOSITE_FIELD]: (fieldConfig, fieldName, typeName) => {\n                const transformedField = this.fieldTransformer(typeName, fieldName, fieldConfig);\n                if (Array.isArray(transformedField)) {\n                    const newFieldName = transformedField[0];\n                    if (newFieldName !== fieldName) {\n                        if (!(typeName in this.mapping)) {\n                            this.mapping[typeName] = {};\n                        }\n                        this.mapping[typeName][newFieldName] = fieldName;\n                    }\n                }\n                return transformedField;\n            },\n        });\n        this.typeInfo = new TypeInfo(this.transformedSchema);\n        return this.transformedSchema;\n    }\n    transformRequest(originalRequest, _delegationContext, transformationContext) {\n        const document = originalRequest.document;\n        const fragments = Object.create(null);\n        document.definitions.forEach(def => {\n            if (def.kind === Kind.FRAGMENT_DEFINITION) {\n                fragments[def.name.value] = def;\n            }\n        });\n        return {\n            ...originalRequest,\n            document: this.transformDocument(document, fragments, transformationContext),\n        };\n    }\n    transformResult(result, _delegationContext, transformationContext) {\n        if (this.dataTransformer != null) {\n            result.data = visitData(result.data, value => this.dataTransformer(value, transformationContext));\n        }\n        if (this.errorsTransformer != null) {\n            result.errors = this.errorsTransformer(result.errors, transformationContext);\n        }\n        return result;\n    }\n    transformDocument(document, fragments, transformationContext) {\n        return visit(document, visitWithTypeInfo(this.typeInfo, {\n            leave: {\n                [Kind.SELECTION_SET]: node => this.transformSelectionSet(node, this.typeInfo, fragments, transformationContext),\n            },\n        }));\n    }\n    transformSelectionSet(node, typeInfo, fragments, transformationContext) {\n        const parentType = typeInfo.getParentType();\n        if (parentType == null) {\n            return undefined;\n        }\n        const parentTypeName = parentType.name;\n        let newSelections = [];\n        node.selections.forEach(selection => {\n            var _a, _b;\n            if (selection.kind !== Kind.FIELD) {\n                newSelections.push(selection);\n                return;\n            }\n            const newName = selection.name.value;\n            if (this.dataTransformer != null || this.errorsTransformer != null) {\n                newSelections.push({\n                    kind: Kind.FIELD,\n                    name: {\n                        kind: Kind.NAME,\n                        value: '__typename',\n                    },\n                });\n            }\n            let transformedSelection;\n            if (this.fieldNodeTransformer == null) {\n                transformedSelection = selection;\n            }\n            else {\n                transformedSelection = this.fieldNodeTransformer(parentTypeName, newName, selection, fragments, transformationContext);\n                transformedSelection = transformedSelection === undefined ? selection : transformedSelection;\n            }\n            if (Array.isArray(transformedSelection)) {\n                newSelections = newSelections.concat(transformedSelection);\n                return;\n            }\n            if (transformedSelection.kind !== Kind.FIELD) {\n                newSelections.push(transformedSelection);\n                return;\n            }\n            const typeMapping = this.mapping[parentTypeName];\n            if (typeMapping == null) {\n                newSelections.push(transformedSelection);\n                return;\n            }\n            const oldName = this.mapping[parentTypeName][newName];\n            if (oldName == null) {\n                newSelections.push(transformedSelection);\n                return;\n            }\n            newSelections.push({\n                ...transformedSelection,\n                name: {\n                    kind: Kind.NAME,\n                    value: oldName,\n                },\n                alias: {\n                    kind: Kind.NAME,\n                    value: (_b = (_a = transformedSelection.alias) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : newName,\n                },\n            });\n        });\n        return {\n            ...node,\n            selections: newSelections,\n        };\n    }\n}\n//# sourceMappingURL=TransformCompositeFields.js.map","import { isObjectType } from 'graphql';\nimport TransformCompositeFields from './TransformCompositeFields';\nexport default class TransformObjectFields {\n    constructor(objectFieldTransformer, fieldNodeTransformer) {\n        this.objectFieldTransformer = objectFieldTransformer;\n        this.fieldNodeTransformer = fieldNodeTransformer;\n    }\n    transformSchema(originalSchema) {\n        const compositeToObjectFieldTransformer = (typeName, fieldName, fieldConfig) => {\n            if (isObjectType(originalSchema.getType(typeName))) {\n                return this.objectFieldTransformer(typeName, fieldName, fieldConfig);\n            }\n            return undefined;\n        };\n        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);\n        return this.transformer.transformSchema(originalSchema);\n    }\n    transformRequest(originalRequest, delegationContext, transformationContext) {\n        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n    }\n    transformResult(originalResult, delegationContext, transformationContext) {\n        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n    }\n}\n//# sourceMappingURL=TransformObjectFields.js.map","import TransformObjectFields from './TransformObjectFields';\nexport default class TransformRootFields {\n    constructor(rootFieldTransformer, fieldNodeTransformer) {\n        this.rootFieldTransformer = rootFieldTransformer;\n        this.fieldNodeTransformer = fieldNodeTransformer;\n    }\n    transformSchema(originalSchema) {\n        var _a, _b, _c;\n        const queryTypeName = (_a = originalSchema.getQueryType()) === null || _a === void 0 ? void 0 : _a.name;\n        const mutationTypeName = (_b = originalSchema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name;\n        const subscriptionTypeName = (_c = originalSchema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name;\n        const rootToObjectFieldTransformer = (typeName, fieldName, fieldConfig) => {\n            if (typeName === queryTypeName) {\n                return this.rootFieldTransformer('Query', fieldName, fieldConfig);\n            }\n            if (typeName === mutationTypeName) {\n                return this.rootFieldTransformer('Mutation', fieldName, fieldConfig);\n            }\n            if (typeName === subscriptionTypeName) {\n                return this.rootFieldTransformer('Subscription', fieldName, fieldConfig);\n            }\n            return undefined;\n        };\n        this.transformer = new TransformObjectFields(rootToObjectFieldTransformer, this.fieldNodeTransformer);\n        return this.transformer.transformSchema(originalSchema);\n    }\n    transformRequest(originalRequest, delegationContext, transformationContext) {\n        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n    }\n    transformResult(originalResult, delegationContext, transformationContext) {\n        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n    }\n}\n//# sourceMappingURL=TransformRootFields.js.map","import TransformRootFields from './TransformRootFields';\nexport default class RenameRootFields {\n    constructor(renamer) {\n        this.transformer = new TransformRootFields((operation, fieldName, fieldConfig) => [renamer(operation, fieldName, fieldConfig), fieldConfig]);\n    }\n    transformSchema(originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    }\n    transformRequest(originalRequest) {\n        return this.transformer.transformRequest(originalRequest);\n    }\n}\n//# sourceMappingURL=RenameRootFields.js.map","import TransformRootFields from './TransformRootFields';\nexport default class FilterRootFields {\n    constructor(filter) {\n        this.transformer = new TransformRootFields((operation, fieldName, fieldConfig) => {\n            if (filter(operation, fieldName, fieldConfig)) {\n                return undefined;\n            }\n            return null;\n        });\n    }\n    transformSchema(originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    }\n}\n//# sourceMappingURL=FilterRootFields.js.map","import TransformObjectFields from './TransformObjectFields';\nexport default class RenameObjectFields {\n    constructor(renamer) {\n        this.transformer = new TransformObjectFields((typeName, fieldName, fieldConfig) => [\n            renamer(typeName, fieldName, fieldConfig),\n            fieldConfig,\n        ]);\n    }\n    transformSchema(originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    }\n    transformRequest(originalRequest) {\n        return this.transformer.transformRequest(originalRequest);\n    }\n}\n//# sourceMappingURL=RenameObjectFields.js.map","import TransformObjectFields from './TransformObjectFields';\nexport default class FilterObjectFields {\n    constructor(filter) {\n        this.transformer = new TransformObjectFields((typeName, fieldName, fieldConfig) => filter(typeName, fieldName, fieldConfig) ? undefined : null);\n    }\n    transformSchema(originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    }\n}\n//# sourceMappingURL=FilterObjectFields.js.map","import { isInterfaceType } from 'graphql';\nimport TransformCompositeFields from './TransformCompositeFields';\nexport default class TransformInterfaceFields {\n    constructor(interfaceFieldTransformer, fieldNodeTransformer) {\n        this.interfaceFieldTransformer = interfaceFieldTransformer;\n        this.fieldNodeTransformer = fieldNodeTransformer;\n    }\n    transformSchema(originalSchema) {\n        const compositeToObjectFieldTransformer = (typeName, fieldName, fieldConfig) => {\n            if (isInterfaceType(originalSchema.getType(typeName))) {\n                return this.interfaceFieldTransformer(typeName, fieldName, fieldConfig);\n            }\n            return undefined;\n        };\n        this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);\n        return this.transformer.transformSchema(originalSchema);\n    }\n    transformRequest(originalRequest, delegationContext, transformationContext) {\n        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n    }\n    transformResult(originalResult, delegationContext, transformationContext) {\n        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n    }\n}\n//# sourceMappingURL=TransformInterfaceFields.js.map","import TransformInterfaceFields from './TransformInterfaceFields';\nexport default class RenameInterfaceFields {\n    constructor(renamer) {\n        this.transformer = new TransformInterfaceFields((typeName, fieldName, fieldConfig) => [\n            renamer(typeName, fieldName, fieldConfig),\n            fieldConfig,\n        ]);\n    }\n    transformSchema(originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    }\n    transformRequest(originalRequest) {\n        return this.transformer.transformRequest(originalRequest);\n    }\n}\n//# sourceMappingURL=RenameInterfaceFields.js.map","import TransformInterfaceFields from './TransformInterfaceFields';\nexport default class FilterInterfaceFields {\n    constructor(filter) {\n        this.transformer = new TransformInterfaceFields((typeName, fieldName, fieldConfig) => filter(typeName, fieldName, fieldConfig) ? undefined : null);\n    }\n    transformSchema(originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    }\n}\n//# sourceMappingURL=FilterInterfaceFields.js.map","import { TypeInfo, visit, visitWithTypeInfo, Kind, } from 'graphql';\nimport { MapperKind, mapSchema } from '@graphql-tools/utils';\nexport default class TransformInputObjectFields {\n    constructor(inputFieldTransformer, inputFieldNodeTransformer, inputObjectNodeTransformer) {\n        this.inputFieldTransformer = inputFieldTransformer;\n        this.inputFieldNodeTransformer = inputFieldNodeTransformer;\n        this.inputObjectNodeTransformer = inputObjectNodeTransformer;\n        this.mapping = {};\n    }\n    transformSchema(originalSchema) {\n        this.transformedSchema = mapSchema(originalSchema, {\n            [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig, fieldName, typeName) => {\n                const transformedInputField = this.inputFieldTransformer(typeName, fieldName, inputFieldConfig);\n                if (Array.isArray(transformedInputField)) {\n                    const newFieldName = transformedInputField[0];\n                    if (newFieldName !== fieldName) {\n                        if (!(typeName in this.mapping)) {\n                            this.mapping[typeName] = {};\n                        }\n                        this.mapping[typeName][newFieldName] = fieldName;\n                    }\n                }\n                return transformedInputField;\n            },\n        });\n        return this.transformedSchema;\n    }\n    transformRequest(originalRequest, delegationContext) {\n        const fragments = Object.create(null);\n        originalRequest.document.definitions\n            .filter(def => def.kind === Kind.FRAGMENT_DEFINITION)\n            .forEach(def => {\n            fragments[def.name.value] = def;\n        });\n        const document = this.transformDocument(originalRequest.document, this.mapping, this.inputFieldNodeTransformer, this.inputObjectNodeTransformer, originalRequest, \n        // cast to DelegationContext as workaround to avoid breaking change in types until next major version\n        delegationContext);\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n    transformDocument(document, mapping, inputFieldNodeTransformer, inputObjectNodeTransformer, request, delegationContext) {\n        const typeInfo = new TypeInfo(this.transformedSchema);\n        const newDocument = visit(document, visitWithTypeInfo(typeInfo, {\n            leave: {\n                [Kind.OBJECT]: (node) => {\n                    const parentType = typeInfo.getInputType();\n                    if (parentType != null) {\n                        const parentTypeName = parentType.name;\n                        const newInputFields = [];\n                        node.fields.forEach(inputField => {\n                            const newName = inputField.name.value;\n                            const transformedInputField = inputFieldNodeTransformer != null\n                                ? inputFieldNodeTransformer(parentTypeName, newName, inputField, request, delegationContext)\n                                : inputField;\n                            if (Array.isArray(transformedInputField)) {\n                                transformedInputField.forEach(individualTransformedInputField => {\n                                    const typeMapping = mapping[parentTypeName];\n                                    if (typeMapping == null) {\n                                        newInputFields.push(individualTransformedInputField);\n                                        return;\n                                    }\n                                    const oldName = typeMapping[newName];\n                                    if (oldName == null) {\n                                        newInputFields.push(individualTransformedInputField);\n                                        return;\n                                    }\n                                    newInputFields.push({\n                                        ...individualTransformedInputField,\n                                        name: {\n                                            ...individualTransformedInputField.name,\n                                            value: oldName,\n                                        },\n                                    });\n                                });\n                                return;\n                            }\n                            const typeMapping = mapping[parentTypeName];\n                            if (typeMapping == null) {\n                                newInputFields.push(transformedInputField);\n                                return;\n                            }\n                            const oldName = typeMapping[newName];\n                            if (oldName == null) {\n                                newInputFields.push(transformedInputField);\n                                return;\n                            }\n                            newInputFields.push({\n                                ...transformedInputField,\n                                name: {\n                                    ...transformedInputField.name,\n                                    value: oldName,\n                                },\n                            });\n                        });\n                        const newNode = {\n                            ...node,\n                            fields: newInputFields,\n                        };\n                        return inputObjectNodeTransformer != null\n                            ? inputObjectNodeTransformer(parentTypeName, newNode, request, delegationContext)\n                            : newNode;\n                    }\n                },\n            },\n        }));\n        return newDocument;\n    }\n}\n//# sourceMappingURL=TransformInputObjectFields.js.map","import { mapSchema, MapperKind } from '@graphql-tools/utils';\nimport TransformInputObjectFields from './TransformInputObjectFields';\nexport default class RenameInputObjectFields {\n    constructor(renamer) {\n        this.renamer = renamer;\n        this.transformer = new TransformInputObjectFields((typeName, inputFieldName, inputFieldConfig) => {\n            const newName = renamer(typeName, inputFieldName, inputFieldConfig);\n            if (newName !== undefined && newName !== inputFieldName) {\n                return [renamer(typeName, inputFieldName, inputFieldConfig), inputFieldConfig];\n            }\n        }, (typeName, inputFieldName, inputFieldNode) => {\n            if (!(typeName in this.reverseMap)) {\n                return inputFieldNode;\n            }\n            const inputFieldNameMap = this.reverseMap[typeName];\n            if (!(inputFieldName in inputFieldNameMap)) {\n                return inputFieldNode;\n            }\n            return {\n                ...inputFieldNode,\n                name: {\n                    ...inputFieldNode.name,\n                    value: inputFieldNameMap[inputFieldName],\n                },\n            };\n        });\n        this.reverseMap = Object.create(null);\n    }\n    transformSchema(originalSchema) {\n        mapSchema(originalSchema, {\n            [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig, fieldName, typeName) => {\n                const newName = this.renamer(typeName, fieldName, inputFieldConfig);\n                if (newName !== undefined && newName !== fieldName) {\n                    if (this.reverseMap[typeName] == null) {\n                        this.reverseMap[typeName] = Object.create(null);\n                    }\n                    this.reverseMap[typeName][newName] = fieldName;\n                }\n                return undefined;\n            },\n            [MapperKind.ROOT_OBJECT]() {\n                return undefined;\n            },\n        });\n        return this.transformer.transformSchema(originalSchema);\n    }\n    transformRequest(originalRequest, delegationContext) {\n        return this.transformer.transformRequest(originalRequest, delegationContext);\n    }\n}\n//# sourceMappingURL=RenameInputObjectFields.js.map","import TransformInputObjectFields from './TransformInputObjectFields';\nexport default class FilterInputObjectFields {\n    constructor(filter, inputObjectNodeTransformer) {\n        this.transformer = new TransformInputObjectFields((typeName, fieldName, inputFieldConfig) => filter(typeName, fieldName, inputFieldConfig) ? undefined : null, undefined, inputObjectNodeTransformer);\n    }\n    transformSchema(originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    }\n    transformRequest(originalRequest, delegationContext) {\n        return this.transformer.transformRequest(originalRequest, delegationContext);\n    }\n}\n//# sourceMappingURL=FilterInputObjectFields.js.map","import { visit, Kind, TypeInfo, visitWithTypeInfo, valueFromAST, isLeafType, } from 'graphql';\nimport { visitResult, updateArgument, transformInputValue, } from '@graphql-tools/utils';\nexport default class MapLeafValues {\n    constructor(inputValueTransformer, outputValueTransformer) {\n        this.inputValueTransformer = inputValueTransformer;\n        this.outputValueTransformer = outputValueTransformer;\n        this.resultVisitorMap = Object.create(null);\n    }\n    transformSchema(originalSchema) {\n        this.originalSchema = originalSchema;\n        const typeMap = originalSchema.getTypeMap();\n        Object.keys(typeMap).forEach(typeName => {\n            const type = typeMap[typeName];\n            if (!typeName.startsWith('__')) {\n                if (isLeafType(type)) {\n                    this.resultVisitorMap[typeName] = (value) => this.outputValueTransformer(typeName, value);\n                }\n            }\n        });\n        this.typeInfo = new TypeInfo(originalSchema);\n        return originalSchema;\n    }\n    transformRequest(originalRequest, _delegationContext, transformationContext) {\n        const document = originalRequest.document;\n        const variableValues = originalRequest.variables;\n        const operations = document.definitions.filter(def => def.kind === Kind.OPERATION_DEFINITION);\n        const fragments = document.definitions.filter(def => def.kind === Kind.FRAGMENT_DEFINITION);\n        const newOperations = this.transformOperations(operations, variableValues);\n        const transformedRequest = {\n            ...originalRequest,\n            document: {\n                ...document,\n                definitions: [...newOperations, ...fragments],\n            },\n            variables: variableValues,\n        };\n        transformationContext.transformedRequest = transformedRequest;\n        return transformedRequest;\n    }\n    transformResult(originalResult, _delegationContext, transformationContext) {\n        return visitResult(originalResult, transformationContext.transformedRequest, this.originalSchema, this.resultVisitorMap);\n    }\n    transformOperations(operations, variableValues) {\n        return operations.map((operation) => {\n            const variableDefinitionMap = operation.variableDefinitions.reduce((prev, def) => ({\n                ...prev,\n                [def.variable.name.value]: def,\n            }), {});\n            const newOperation = visit(operation, visitWithTypeInfo(this.typeInfo, {\n                [Kind.FIELD]: node => this.transformFieldNode(node, variableDefinitionMap, variableValues),\n            }));\n            return {\n                ...newOperation,\n                variableDefinitions: Object.keys(variableDefinitionMap).map(varName => variableDefinitionMap[varName]),\n            };\n        });\n    }\n    transformFieldNode(field, variableDefinitionMap, variableValues) {\n        const targetField = this.typeInfo.getFieldDef();\n        if (!targetField.name.startsWith('__')) {\n            const argumentNodes = field.arguments;\n            if (argumentNodes != null) {\n                const argumentNodeMap = argumentNodes.reduce((prev, argument) => ({\n                    ...prev,\n                    [argument.name.value]: argument,\n                }), Object.create(null));\n                targetField.args.forEach((argument) => {\n                    const argName = argument.name;\n                    const argType = argument.type;\n                    const argumentNode = argumentNodeMap[argName];\n                    const argValue = argumentNode === null || argumentNode === void 0 ? void 0 : argumentNode.value;\n                    let value;\n                    if (argValue != null) {\n                        value = valueFromAST(argValue, argType, variableValues);\n                    }\n                    updateArgument(argName, argType, argumentNodeMap, variableDefinitionMap, variableValues, transformInputValue(argType, value, (t, v) => {\n                        const newValue = this.inputValueTransformer(t.name, v);\n                        return newValue === undefined ? v : newValue;\n                    }));\n                });\n                return {\n                    ...field,\n                    arguments: Object.keys(argumentNodeMap).map(argName => argumentNodeMap[argName]),\n                };\n            }\n        }\n    }\n}\n//# sourceMappingURL=MapLeafValues.js.map","import { MapperKind, mapSchema } from '@graphql-tools/utils';\nimport MapLeafValues from './MapLeafValues';\nexport default class TransformEnumValues {\n    constructor(enumValueTransformer, inputValueTransformer, outputValueTransformer) {\n        this.enumValueTransformer = enumValueTransformer;\n        this.mapping = Object.create(null);\n        this.reverseMapping = Object.create(null);\n        this.transformer = new MapLeafValues(generateValueTransformer(inputValueTransformer, this.reverseMapping), generateValueTransformer(outputValueTransformer, this.mapping));\n    }\n    transformSchema(originalSchema) {\n        const transformedSchema = this.transformer.transformSchema(originalSchema);\n        this.transformedSchema = mapSchema(transformedSchema, {\n            [MapperKind.ENUM_VALUE]: (valueConfig, typeName, _schema, externalValue) => this.transformEnumValue(typeName, externalValue, valueConfig),\n        });\n        return this.transformedSchema;\n    }\n    transformRequest(originalRequest, delegationContext, transformationContext) {\n        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n    }\n    transformResult(originalResult, delegationContext, transformationContext) {\n        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n    }\n    transformEnumValue(typeName, externalValue, enumValueConfig) {\n        const transformedEnumValue = this.enumValueTransformer(typeName, externalValue, enumValueConfig);\n        if (Array.isArray(transformedEnumValue)) {\n            const newExternalValue = transformedEnumValue[0];\n            if (newExternalValue !== externalValue) {\n                if (!(typeName in this.mapping)) {\n                    this.mapping[typeName] = Object.create(null);\n                    this.reverseMapping[typeName] = Object.create(null);\n                }\n                this.mapping[typeName][externalValue] = newExternalValue;\n                this.reverseMapping[typeName][newExternalValue] = externalValue;\n            }\n        }\n        return transformedEnumValue;\n    }\n}\nfunction mapEnumValues(typeName, value, mapping) {\n    var _a;\n    const newExternalValue = (_a = mapping[typeName]) === null || _a === void 0 ? void 0 : _a[value];\n    return newExternalValue != null ? newExternalValue : value;\n}\nfunction generateValueTransformer(valueTransformer, mapping) {\n    if (valueTransformer == null) {\n        return (typeName, value) => mapEnumValues(typeName, value, mapping);\n    }\n    else {\n        return (typeName, value) => mapEnumValues(typeName, valueTransformer(typeName, value), mapping);\n    }\n}\n//# sourceMappingURL=TransformEnumValues.js.map","import { visit, Kind } from 'graphql';\nimport { relocatedError } from '@graphql-tools/utils';\nexport default class TransformQuery {\n    constructor({ path, queryTransformer, resultTransformer = result => result, errorPathTransformer = errorPath => [].concat(errorPath), fragments = {}, }) {\n        this.path = path;\n        this.queryTransformer = queryTransformer;\n        this.resultTransformer = resultTransformer;\n        this.errorPathTransformer = errorPathTransformer;\n        this.fragments = fragments;\n    }\n    transformRequest(originalRequest) {\n        const pathLength = this.path.length;\n        let index = 0;\n        const document = visit(originalRequest.document, {\n            [Kind.FIELD]: {\n                enter: node => {\n                    if (index === pathLength || node.name.value !== this.path[index]) {\n                        return false;\n                    }\n                    index++;\n                    if (index === pathLength) {\n                        const selectionSet = this.queryTransformer(node.selectionSet, this.fragments);\n                        return {\n                            ...node,\n                            selectionSet,\n                        };\n                    }\n                },\n                leave: () => {\n                    index--;\n                },\n            },\n        });\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n    transformResult(originalResult) {\n        const data = this.transformData(originalResult.data);\n        const errors = originalResult.errors;\n        return {\n            data,\n            errors: errors != null ? this.transformErrors(errors) : undefined,\n        };\n    }\n    transformData(data) {\n        const leafIndex = this.path.length - 1;\n        let index = 0;\n        let newData = data;\n        if (newData) {\n            let next = this.path[index];\n            while (index < leafIndex) {\n                if (data[next]) {\n                    newData = newData[next];\n                }\n                else {\n                    break;\n                }\n                index++;\n                next = this.path[index];\n            }\n            newData[next] = this.resultTransformer(newData[next]);\n        }\n        return newData;\n    }\n    transformErrors(errors) {\n        return errors.map(error => {\n            const path = error.path;\n            let match = true;\n            let index = 0;\n            while (index < this.path.length) {\n                if (path[index] !== this.path[index]) {\n                    match = false;\n                    break;\n                }\n                index++;\n            }\n            const newPath = match ? path.slice(0, index).concat(this.errorPathTransformer(path.slice(index))) : path;\n            return relocatedError(error, newPath);\n        });\n    }\n}\n//# sourceMappingURL=TransformQuery.js.map","import { getArgumentValues } from '@graphql-tools/utils';\nimport TransformObjectFields from './TransformObjectFields';\nexport default class FilterObjectFieldDirectives {\n    constructor(filter) {\n        this.filter = filter;\n    }\n    transformSchema(originalSchema) {\n        const transformer = new TransformObjectFields((_typeName, _fieldName, fieldConfig) => {\n            const keepDirectives = fieldConfig.astNode.directives.filter(dir => {\n                const directiveDef = originalSchema.getDirective(dir.name.value);\n                const directiveValue = directiveDef ? getArgumentValues(directiveDef, dir) : undefined;\n                return this.filter(dir.name.value, directiveValue);\n            });\n            if (keepDirectives.length !== fieldConfig.astNode.directives.length) {\n                fieldConfig = {\n                    ...fieldConfig,\n                    astNode: {\n                        ...fieldConfig.astNode,\n                        directives: keepDirectives,\n                    },\n                };\n                return fieldConfig;\n            }\n        });\n        return transformer.transformSchema(originalSchema);\n    }\n}\n//# sourceMappingURL=FilterObjectFieldDirectives.js.map","import { valueMatchesCriteria } from '@graphql-tools/utils';\nimport FilterObjectFieldDirectives from './FilterObjectFieldDirectives';\nexport default class RemoveObjectFieldDirectives {\n    constructor(directiveName, args = {}) {\n        this.transformer = new FilterObjectFieldDirectives((dirName, dirValue) => {\n            return !(valueMatchesCriteria(dirName, directiveName) && valueMatchesCriteria(dirValue, args));\n        });\n    }\n    transformSchema(originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    }\n}\n//# sourceMappingURL=RemoveObjectFieldDirectives.js.map","import { getDirectives, valueMatchesCriteria } from '@graphql-tools/utils';\nimport FilterObjectFields from './FilterObjectFields';\nexport default class RemoveObjectFieldsWithDirective {\n    constructor(directiveName, args = {}) {\n        this.directiveName = directiveName;\n        this.args = args;\n    }\n    transformSchema(originalSchema) {\n        const transformer = new FilterObjectFields((_typeName, _fieldName, fieldConfig) => {\n            const valueMap = getDirectives(originalSchema, fieldConfig);\n            return !Object.keys(valueMap).some(directiveName => valueMatchesCriteria(directiveName, this.directiveName) &&\n                ((Array.isArray(valueMap[directiveName]) &&\n                    valueMap[directiveName].some((value) => valueMatchesCriteria(value, this.args))) ||\n                    valueMatchesCriteria(valueMap[directiveName], this.args)));\n        });\n        return transformer.transformSchema(originalSchema);\n    }\n}\n//# sourceMappingURL=RemoveObjectFieldsWithDirective.js.map","import { valueMatchesCriteria } from '@graphql-tools/utils';\nimport FilterObjectFieldDirectives from './FilterObjectFieldDirectives';\nimport TransformObjectFields from './TransformObjectFields';\nexport default class RemoveObjectFieldDeprecations {\n    constructor(reason) {\n        const args = { reason };\n        this.removeDirectives = new FilterObjectFieldDirectives((dirName, dirValue) => {\n            return !(dirName === 'deprecated' && valueMatchesCriteria(dirValue, args));\n        });\n        this.removeDeprecations = new TransformObjectFields((_typeName, _fieldName, fieldConfig) => {\n            if (fieldConfig.deprecationReason && valueMatchesCriteria(fieldConfig.deprecationReason, reason)) {\n                fieldConfig = { ...fieldConfig };\n                delete fieldConfig.deprecationReason;\n            }\n            return fieldConfig;\n        });\n    }\n    transformSchema(originalSchema) {\n        return this.removeDeprecations.transformSchema(this.removeDirectives.transformSchema(originalSchema));\n    }\n}\n//# sourceMappingURL=RemoveObjectFieldDeprecations.js.map","import { valueMatchesCriteria } from '@graphql-tools/utils';\nimport FilterObjectFields from './FilterObjectFields';\nexport default class RemoveObjectFieldsWithDeprecation {\n    constructor(reason) {\n        this.transformer = new FilterObjectFields((_typeName, _fieldName, fieldConfig) => {\n            if (fieldConfig.deprecationReason) {\n                return !valueMatchesCriteria(fieldConfig.deprecationReason, reason);\n            }\n            return true;\n        });\n    }\n    transformSchema(originalSchema) {\n        return this.transformer.transformSchema(originalSchema);\n    }\n}\n//# sourceMappingURL=RemoveObjectFieldsWithDeprecation.js.map","import TransformCompositeFields from './TransformCompositeFields';\nexport default class MapFields {\n    constructor(fieldNodeTransformerMap, objectValueTransformerMap, errorsTransformer) {\n        this.transformer = new TransformCompositeFields(() => undefined, (typeName, fieldName, fieldNode, fragments, transformationContext) => {\n            const typeTransformers = fieldNodeTransformerMap[typeName];\n            if (typeTransformers == null) {\n                return undefined;\n            }\n            const fieldNodeTransformer = typeTransformers[fieldName];\n            if (fieldNodeTransformer == null) {\n                return undefined;\n            }\n            return fieldNodeTransformer(fieldNode, fragments, transformationContext);\n        }, objectValueTransformerMap != null\n            ? (data, transformationContext) => {\n                if (data == null) {\n                    return data;\n                }\n                const typeName = data.__typename;\n                if (typeName == null) {\n                    return data;\n                }\n                const transformer = objectValueTransformerMap[typeName];\n                if (transformer == null) {\n                    return data;\n                }\n                return transformer(data, transformationContext);\n            }\n            : undefined, errorsTransformer != null ? errorsTransformer : undefined);\n    }\n    transformSchema(schema) {\n        return this.transformer.transformSchema(schema);\n    }\n    transformRequest(originalRequest, delegationContext, transformationContext) {\n        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n    }\n    transformResult(originalResult, delegationContext, transformationContext) {\n        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n    }\n}\n//# sourceMappingURL=MapFields.js.map","import { extendSchema, parse } from 'graphql';\nimport { addResolversToSchema } from '@graphql-tools/schema';\nimport { defaultMergedResolver } from '@graphql-tools/delegate';\nimport MapFields from './MapFields';\nexport default class ExtendSchema {\n    constructor({ typeDefs, resolvers = {}, defaultFieldResolver, fieldNodeTransformerMap, objectValueTransformerMap, errorsTransformer, }) {\n        this.typeDefs = typeDefs;\n        this.resolvers = resolvers;\n        this.defaultFieldResolver = defaultFieldResolver != null ? defaultFieldResolver : defaultMergedResolver;\n        this.transformer = new MapFields(fieldNodeTransformerMap != null ? fieldNodeTransformerMap : {}, objectValueTransformerMap, errorsTransformer);\n    }\n    transformSchema(schema) {\n        // MapFields's transformSchema function does not actually modify the schema --\n        // it saves the current schema state, to be used later to transform requests.\n        this.transformer.transformSchema(schema);\n        return addResolversToSchema({\n            schema: this.typeDefs ? extendSchema(schema, parse(this.typeDefs)) : schema,\n            resolvers: this.resolvers != null ? this.resolvers : {},\n            defaultFieldResolver: this.defaultFieldResolver,\n        });\n    }\n    transformRequest(originalRequest, delegationContext, transformationContext) {\n        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n    }\n    transformResult(originalResult, delegationContext, transformationContext) {\n        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n    }\n}\n//# sourceMappingURL=ExtendSchema.js.map","import { pruneSchema } from '@graphql-tools/utils';\nexport default class PruneTypes {\n    constructor(options) {\n        this.options = options;\n    }\n    transformSchema(schema) {\n        return pruneSchema(schema, this.options);\n    }\n}\n//# sourceMappingURL=PruneSchema.js.map","import { Kind, } from 'graphql';\nimport { appendObjectFields, selectObjectFields, modifyObjectFields, relocatedError, } from '@graphql-tools/utils';\nimport { defaultMergedResolver } from '@graphql-tools/delegate';\nimport MapFields from './MapFields';\nfunction defaultWrappingResolver(parent, args, context, info) {\n    if (!parent) {\n        return {};\n    }\n    return defaultMergedResolver(parent, args, context, info);\n}\nexport default class WrapFields {\n    constructor(outerTypeName, wrappingFieldNames, wrappingTypeNames, fieldNames, wrappingResolver = defaultWrappingResolver, prefix = 'gqtld') {\n        this.outerTypeName = outerTypeName;\n        this.wrappingFieldNames = wrappingFieldNames;\n        this.wrappingTypeNames = wrappingTypeNames;\n        this.numWraps = wrappingFieldNames.length;\n        this.fieldNames = fieldNames;\n        this.wrappingResolver = wrappingResolver;\n        const remainingWrappingFieldNames = this.wrappingFieldNames.slice();\n        const outerMostWrappingFieldName = remainingWrappingFieldNames.shift();\n        this.transformer = new MapFields({\n            [outerTypeName]: {\n                [outerMostWrappingFieldName]: (fieldNode, fragments, transformationContext) => hoistFieldNodes({\n                    fieldNode,\n                    path: remainingWrappingFieldNames,\n                    fieldNames,\n                    fragments,\n                    transformationContext,\n                    prefix,\n                }),\n            },\n        }, {\n            [outerTypeName]: (value, context) => dehoistValue(value, context),\n        }, (errors, context) => dehoistErrors(errors, context));\n    }\n    transformSchema(schema) {\n        const targetFieldConfigMap = selectObjectFields(schema, this.outerTypeName, !this.fieldNames ? () => true : fieldName => this.fieldNames.includes(fieldName));\n        let wrapIndex = this.numWraps - 1;\n        let wrappingTypeName = this.wrappingTypeNames[wrapIndex];\n        let wrappingFieldName = this.wrappingFieldNames[wrapIndex];\n        let newSchema = appendObjectFields(schema, wrappingTypeName, targetFieldConfigMap);\n        for (wrapIndex--; wrapIndex > -1; wrapIndex--) {\n            const nextWrappingTypeName = this.wrappingTypeNames[wrapIndex];\n            newSchema = appendObjectFields(newSchema, nextWrappingTypeName, {\n                [wrappingFieldName]: {\n                    type: newSchema.getType(wrappingTypeName),\n                    resolve: this.wrappingResolver,\n                },\n            });\n            wrappingTypeName = nextWrappingTypeName;\n            wrappingFieldName = this.wrappingFieldNames[wrapIndex];\n        }\n        const selectedFieldNames = Object.keys(targetFieldConfigMap);\n        [newSchema] = modifyObjectFields(newSchema, this.outerTypeName, fieldName => selectedFieldNames.includes(fieldName), {\n            [wrappingFieldName]: {\n                type: newSchema.getType(wrappingTypeName),\n                resolve: this.wrappingResolver,\n            },\n        });\n        return this.transformer.transformSchema(newSchema);\n    }\n    transformRequest(originalRequest, delegationContext, transformationContext) {\n        transformationContext.nextIndex = 0;\n        transformationContext.paths = Object.create(null);\n        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n    }\n    transformResult(originalResult, delegationContext, transformationContext) {\n        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n    }\n}\nfunction collectFields(selectionSet, fragments, fields = [], visitedFragmentNames = {}) {\n    if (selectionSet != null) {\n        selectionSet.selections.forEach(selection => {\n            switch (selection.kind) {\n                case Kind.FIELD:\n                    fields.push(selection);\n                    break;\n                case Kind.INLINE_FRAGMENT:\n                    collectFields(selection.selectionSet, fragments, fields, visitedFragmentNames);\n                    break;\n                case Kind.FRAGMENT_SPREAD: {\n                    const fragmentName = selection.name.value;\n                    if (!visitedFragmentNames[fragmentName]) {\n                        visitedFragmentNames[fragmentName] = true;\n                        collectFields(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);\n                    }\n                    break;\n                }\n                default:\n                    // unreachable\n                    break;\n            }\n        });\n    }\n    return fields;\n}\nfunction aliasFieldNode(fieldNode, str) {\n    return {\n        ...fieldNode,\n        alias: {\n            kind: Kind.NAME,\n            value: str,\n        },\n    };\n}\nfunction hoistFieldNodes({ fieldNode, fieldNames, path, fragments, transformationContext, prefix, index = 0, wrappingPath = [], }) {\n    const alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;\n    let newFieldNodes = [];\n    if (index < path.length) {\n        const pathSegment = path[index];\n        collectFields(fieldNode.selectionSet, fragments).forEach((possibleFieldNode) => {\n            if (possibleFieldNode.name.value === pathSegment) {\n                const newWrappingPath = wrappingPath.concat([alias]);\n                newFieldNodes = newFieldNodes.concat(hoistFieldNodes({\n                    fieldNode: possibleFieldNode,\n                    fieldNames,\n                    path,\n                    fragments,\n                    transformationContext,\n                    prefix,\n                    index: index + 1,\n                    wrappingPath: newWrappingPath,\n                }));\n            }\n        });\n    }\n    else {\n        collectFields(fieldNode.selectionSet, fragments).forEach((possibleFieldNode) => {\n            if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {\n                const nextIndex = transformationContext.nextIndex;\n                transformationContext.nextIndex++;\n                const indexingAlias = `__${prefix}${nextIndex}__`;\n                transformationContext.paths[indexingAlias] = {\n                    pathToField: wrappingPath.concat([alias]),\n                    alias: possibleFieldNode.alias != null ? possibleFieldNode.alias.value : possibleFieldNode.name.value,\n                };\n                newFieldNodes.push(aliasFieldNode(possibleFieldNode, indexingAlias));\n            }\n        });\n    }\n    return newFieldNodes;\n}\nexport function dehoistValue(originalValue, context) {\n    if (originalValue == null) {\n        return originalValue;\n    }\n    const newValue = Object.create(null);\n    Object.keys(originalValue).forEach(alias => {\n        let obj = newValue;\n        const path = context.paths[alias];\n        if (path == null) {\n            newValue[alias] = originalValue[alias];\n            return;\n        }\n        const pathToField = path.pathToField;\n        const fieldAlias = path.alias;\n        pathToField.forEach(key => {\n            obj = obj[key] = obj[key] || Object.create(null);\n        });\n        obj[fieldAlias] = originalValue[alias];\n    });\n    return newValue;\n}\nfunction dehoistErrors(errors, context) {\n    if (errors === undefined) {\n        return undefined;\n    }\n    return errors.map(error => {\n        const originalPath = error.path;\n        if (originalPath == null) {\n            return error;\n        }\n        let newPath = [];\n        originalPath.forEach(pathSegment => {\n            if (typeof pathSegment !== 'string') {\n                newPath.push(pathSegment);\n                return;\n            }\n            const path = context.paths[pathSegment];\n            if (path == null) {\n                newPath.push(pathSegment);\n                return;\n            }\n            newPath = newPath.concat(path.pathToField, [path.alias]);\n        });\n        return relocatedError(error, newPath);\n    });\n}\n//# sourceMappingURL=WrapFields.js.map","import WrapFields from './WrapFields';\nexport default class WrapType {\n    constructor(outerTypeName, innerTypeName, fieldName) {\n        this.transformer = new WrapFields(outerTypeName, [fieldName], [innerTypeName]);\n    }\n    transformSchema(schema) {\n        return this.transformer.transformSchema(schema);\n    }\n    transformRequest(originalRequest, delegationContext, transformationContext) {\n        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n    }\n    transformResult(originalResult, delegationContext, transformationContext) {\n        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n    }\n}\n//# sourceMappingURL=WrapType.js.map","import { getNullableType, Kind } from 'graphql';\nimport { renameFieldNode, appendObjectFields, removeObjectFields, relocatedError, } from '@graphql-tools/utils';\nimport { defaultMergedResolver } from '@graphql-tools/delegate';\nimport MapFields from './MapFields';\nexport default class HoistField {\n    constructor(typeName, path, newFieldName, alias = '__gqtlw__') {\n        this.typeName = typeName;\n        this.newFieldName = newFieldName;\n        const pathToField = path.slice();\n        const oldFieldName = pathToField.pop();\n        this.oldFieldName = oldFieldName;\n        this.pathToField = pathToField;\n        this.transformer = new MapFields({\n            [typeName]: {\n                [newFieldName]: fieldNode => wrapFieldNode(renameFieldNode(fieldNode, oldFieldName), pathToField, alias),\n            },\n        }, {\n            [typeName]: value => unwrapValue(value, alias),\n        }, errors => unwrapErrors(errors, alias));\n    }\n    transformSchema(schema) {\n        const innerType = this.pathToField.reduce((acc, pathSegment) => getNullableType(acc.getFields()[pathSegment].type), schema.getType(this.typeName));\n        let [newSchema, targetFieldConfigMap] = removeObjectFields(schema, innerType.name, fieldName => fieldName === this.oldFieldName);\n        const targetField = targetFieldConfigMap[this.oldFieldName];\n        const targetType = targetField.type;\n        newSchema = appendObjectFields(newSchema, this.typeName, {\n            [this.newFieldName]: {\n                type: targetType,\n                resolve: defaultMergedResolver,\n            },\n        });\n        return this.transformer.transformSchema(newSchema);\n    }\n    transformRequest(originalRequest, delegationContext, transformationContext) {\n        return this.transformer.transformRequest(originalRequest, delegationContext, transformationContext);\n    }\n    transformResult(originalResult, delegationContext, transformationContext) {\n        return this.transformer.transformResult(originalResult, delegationContext, transformationContext);\n    }\n}\nexport function wrapFieldNode(fieldNode, path, alias) {\n    let newFieldNode = fieldNode;\n    path.forEach(fieldName => {\n        newFieldNode = {\n            kind: Kind.FIELD,\n            alias: {\n                kind: Kind.NAME,\n                value: alias,\n            },\n            name: {\n                kind: Kind.NAME,\n                value: fieldName,\n            },\n            selectionSet: {\n                kind: Kind.SELECTION_SET,\n                selections: [fieldNode],\n            },\n        };\n    });\n    return newFieldNode;\n}\nexport function unwrapValue(originalValue, alias) {\n    let newValue = originalValue;\n    let object = newValue[alias];\n    while (object != null) {\n        newValue = object;\n        object = newValue[alias];\n    }\n    delete originalValue[alias];\n    Object.assign(originalValue, newValue);\n    return originalValue;\n}\nfunction unwrapErrors(errors, alias) {\n    if (errors === undefined) {\n        return undefined;\n    }\n    return errors.map(error => {\n        const originalPath = error.path;\n        if (originalPath == null) {\n            return error;\n        }\n        const newPath = originalPath.filter(pathSegment => pathSegment !== alias);\n        return relocatedError(error, newPath);\n    });\n}\n//# sourceMappingURL=HoistField.js.map","import { visit, Kind } from 'graphql';\nexport default class WrapQuery {\n    constructor(path, wrapper, extractor) {\n        this.path = path;\n        this.wrapper = wrapper;\n        this.extractor = extractor;\n    }\n    transformRequest(originalRequest) {\n        const fieldPath = [];\n        const ourPath = JSON.stringify(this.path);\n        const document = visit(originalRequest.document, {\n            [Kind.FIELD]: {\n                enter: (node) => {\n                    fieldPath.push(node.name.value);\n                    if (ourPath === JSON.stringify(fieldPath)) {\n                        const wrapResult = this.wrapper(node.selectionSet);\n                        // Selection can be either a single selection or a selection set. If it's just one selection,\n                        // let's wrap it in a selection set. Otherwise, keep it as is.\n                        const selectionSet = wrapResult != null && wrapResult.kind === Kind.SELECTION_SET\n                            ? wrapResult\n                            : {\n                                kind: Kind.SELECTION_SET,\n                                selections: [wrapResult],\n                            };\n                        return {\n                            ...node,\n                            selectionSet,\n                        };\n                    }\n                },\n                leave: () => {\n                    fieldPath.pop();\n                },\n            },\n        });\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n    transformResult(originalResult) {\n        const rootData = originalResult.data;\n        if (rootData != null) {\n            let data = rootData;\n            const path = [...this.path];\n            while (path.length > 1) {\n                const next = path.shift();\n                if (data[next]) {\n                    data = data[next];\n                }\n            }\n            data[path[0]] = this.extractor(data[path[0]]);\n        }\n        return {\n            data: rootData,\n            errors: originalResult.errors,\n        };\n    }\n}\n//# sourceMappingURL=WrapQuery.js.map","import { visit, Kind, BREAK } from 'graphql';\nexport default class ExtractField {\n    constructor({ from, to }) {\n        this.from = from;\n        this.to = to;\n    }\n    transformRequest(originalRequest) {\n        let fromSelection;\n        const ourPathFrom = JSON.stringify(this.from);\n        const ourPathTo = JSON.stringify(this.to);\n        let fieldPath = [];\n        visit(originalRequest.document, {\n            [Kind.FIELD]: {\n                enter: (node) => {\n                    fieldPath.push(node.name.value);\n                    if (ourPathFrom === JSON.stringify(fieldPath)) {\n                        fromSelection = node.selectionSet;\n                        return BREAK;\n                    }\n                },\n                leave: () => {\n                    fieldPath.pop();\n                },\n            },\n        });\n        fieldPath = [];\n        const document = visit(originalRequest.document, {\n            [Kind.FIELD]: {\n                enter: (node) => {\n                    fieldPath.push(node.name.value);\n                    if (ourPathTo === JSON.stringify(fieldPath) && fromSelection != null) {\n                        return {\n                            ...node,\n                            selectionSet: fromSelection,\n                        };\n                    }\n                },\n                leave: () => {\n                    fieldPath.pop();\n                },\n            },\n        });\n        return {\n            ...originalRequest,\n            document,\n        };\n    }\n}\n//# sourceMappingURL=ExtractField.js.map","import { buildSchema } from 'graphql';\nimport { delegateToSchema } from '@graphql-tools/delegate';\nimport { wrapSchema } from './wrapSchema';\nexport function makeRemoteExecutableSchema({ schema: schemaOrTypeDefs, executor, subscriber, createResolver = defaultCreateRemoteResolver, buildSchemaOptions, }) {\n    const targetSchema = typeof schemaOrTypeDefs === 'string' ? buildSchema(schemaOrTypeDefs, buildSchemaOptions) : schemaOrTypeDefs;\n    return wrapSchema({\n        schema: targetSchema,\n        createProxyingResolver: () => createResolver(executor, subscriber),\n    });\n}\nexport function defaultCreateRemoteResolver(executor, subscriber) {\n    return (_parent, _args, context, info) => delegateToSchema({\n        schema: { schema: info.schema, executor, subscriber },\n        context,\n        info,\n    });\n}\n//# sourceMappingURL=makeRemoteExecutableSchema.js.map","import { __extends } from 'tslib';\n\nvar cleanInternalStack = function (stack) { return stack.replace(/\\s+at .*aggregate-error\\/index.js:\\d+:\\d+\\)?/g, ''); };\n\n/**\r\nEscape RegExp special characters.\r\nYou can also use this to escape a string that is inserted into the middle of a regex, for example, into a character class.\r\n@example\r\n```\r\nimport escapeStringRegexp = require('escape-string-regexp');\r\nconst escapedString = escapeStringRegexp('How much $ for a 🦄?');\r\n//=> 'How much \\\\$ for a 🦄\\\\?'\r\nnew RegExp(escapedString);\r\n```\r\n*/\r\nvar escapeStringRegexp = function (string) {\r\n    if (typeof string !== 'string') {\r\n        throw new TypeError('Expected a string');\r\n    }\r\n    // Escape characters with special meaning either inside or outside character sets.\r\n    // Use a simple backslash escape when it’s always valid, and a `\\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\r\n    return string\r\n        .replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\r\n        .replace(/-/g, '\\\\x2d');\r\n};\n\nvar extractPathRegex = /\\s+at.*[(\\s](.*)\\)?/;\r\nvar pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:babel-polyfill|pirates)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/;\r\n/**\r\nClean up error stack traces. Removes the mostly unhelpful internal Node.js entries.\r\n@param stack - The `stack` property of an `Error`.\r\n@example\r\n```\r\nimport cleanStack = require('clean-stack');\r\nconst error = new Error('Missing unicorn');\r\nconsole.log(error.stack);\r\n// Error: Missing unicorn\r\n//     at Object.<anonymous> (/Users/sindresorhus/dev/clean-stack/unicorn.js:2:15)\r\n//     at Module._compile (module.js:409:26)\r\n//     at Object.Module._extensions..js (module.js:416:10)\r\n//     at Module.load (module.js:343:32)\r\n//     at Function.Module._load (module.js:300:12)\r\n//     at Function.Module.runMain (module.js:441:10)\r\n//     at startup (node.js:139:18)\r\nconsole.log(cleanStack(error.stack));\r\n// Error: Missing unicorn\r\n//     at Object.<anonymous> (/Users/sindresorhus/dev/clean-stack/unicorn.js:2:15)\r\n```\r\n*/\r\nvar cleanStack = function (stack, basePath) {\r\n    var basePathRegex = basePath && new RegExp(\"(at | \\\\()\" + escapeStringRegexp(basePath), 'g');\r\n    return stack.replace(/\\\\/g, '/')\r\n        .split('\\n')\r\n        .filter(function (line) {\r\n        var pathMatches = line.match(extractPathRegex);\r\n        if (pathMatches === null || !pathMatches[1]) {\r\n            return true;\r\n        }\r\n        var match = pathMatches[1];\r\n        // Electron\r\n        if (match.includes('.app/Contents/Resources/electron.asar') ||\r\n            match.includes('.app/Contents/Resources/default_app.asar')) {\r\n            return false;\r\n        }\r\n        return !pathRegex.test(match);\r\n    })\r\n        .filter(function (line) { return line.trim() !== ''; })\r\n        .map(function (line) {\r\n        if (basePathRegex) {\r\n            line = line.replace(basePathRegex, '$1');\r\n        }\r\n        return line;\r\n    })\r\n        .join('\\n');\r\n};\n\n/**\r\nIndent each line in a string.\r\n@param string - The string to indent.\r\n@param count - How many times you want `options.indent` repeated. Default: `1`.\r\n@example\r\n```\r\nimport indentString = require('indent-string');\r\nindentString('Unicorns\\nRainbows', 4);\r\n//=> '    Unicorns\\n    Rainbows'\r\nindentString('Unicorns\\nRainbows', 4, {indent: '♥'});\r\n//=> '♥♥♥♥Unicorns\\n♥♥♥♥Rainbows'\r\n```\r\n*/\r\nvar indentString = function (string, count, options) {\r\n    if (count === void 0) { count = 1; }\r\n    options = Object.assign({\r\n        indent: ' ',\r\n        includeEmptyLines: false,\r\n    }, options);\r\n    if (typeof string !== 'string') {\r\n        throw new TypeError(\"Expected `input` to be a `string`, got `\" + typeof string + \"`\");\r\n    }\r\n    if (typeof count !== 'number') {\r\n        throw new TypeError(\"Expected `count` to be a `number`, got `\" + typeof count + \"`\");\r\n    }\r\n    if (count < 0) {\r\n        throw new RangeError(\"Expected `count` to be at least 0, got `\" + count + \"`\");\r\n    }\r\n    if (typeof options.indent !== 'string') {\r\n        throw new TypeError(\"Expected `options.indent` to be a `string`, got `\" + typeof options.indent + \"`\");\r\n    }\r\n    if (count === 0) {\r\n        return string;\r\n    }\r\n    var regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;\r\n    return string.replace(regex, options.indent.repeat(count));\r\n};\n\nvar AggregateError = /** @class */ (function (_super) {\r\n    __extends(AggregateError, _super);\r\n    function AggregateError(errors) {\r\n        var _this = this;\r\n        if (!Array.isArray(errors)) {\r\n            throw new TypeError(\"Expected input to be an Array, got \" + typeof errors);\r\n        }\r\n        var normalizedErrors = errors.map(function (error) {\r\n            if (error instanceof Error) {\r\n                return error;\r\n            }\r\n            if (error !== null && typeof error === 'object') {\r\n                // Handle plain error objects with message property and/or possibly other metadata\r\n                return Object.assign(new Error(error.message), error);\r\n            }\r\n            return new Error(error);\r\n        });\r\n        var message = normalizedErrors\r\n            .map(function (error) {\r\n            // The `stack` property is not standardized, so we can't assume it exists\r\n            return typeof error.stack === 'string' ? cleanInternalStack(cleanStack(error.stack)) : String(error);\r\n        })\r\n            .join('\\n');\r\n        message = '\\n' + indentString(message, 4);\r\n        _this = _super.call(this, message) || this;\r\n        _this.name = 'AggregateError';\r\n        Object.defineProperty(_this, Symbol.iterator, {\r\n            get: function () { return function () { return normalizedErrors[Symbol.iterator](); }; },\r\n        });\r\n        return _this;\r\n    }\r\n    return AggregateError;\r\n}(Error));\n\nexport default AggregateError;\n//# sourceMappingURL=index.esm.js.map\n","import { getIntrospectionQuery, buildClientSchema, parse, } from 'graphql';\nimport AggregateError from '@ardatan/aggregate-error';\nfunction getSchemaFromIntrospection(introspectionResult) {\n    var _a, _b;\n    if ((_a = introspectionResult === null || introspectionResult === void 0 ? void 0 : introspectionResult.data) === null || _a === void 0 ? void 0 : _a.__schema) {\n        return buildClientSchema(introspectionResult.data);\n    }\n    else if ((_b = introspectionResult === null || introspectionResult === void 0 ? void 0 : introspectionResult.errors) === null || _b === void 0 ? void 0 : _b.length) {\n        if (introspectionResult.errors.length > 1) {\n            const combinedError = new AggregateError(introspectionResult.errors);\n            throw combinedError;\n        }\n        const error = introspectionResult.errors[0];\n        throw error.originalError || error;\n    }\n    else {\n        throw new Error('Could not obtain introspection result, received: ' + JSON.stringify(introspectionResult));\n    }\n}\nexport async function introspectSchema(executor, context, options) {\n    const parsedIntrospectionQuery = parse(getIntrospectionQuery(options));\n    const introspectionResult = await executor({\n        document: parsedIntrospectionQuery,\n        context,\n    });\n    return getSchemaFromIntrospection(introspectionResult);\n}\nexport function introspectSchemaSync(executor, context, options) {\n    const parsedIntrospectionQuery = parse(getIntrospectionQuery(options));\n    const introspectionResult = executor({\n        document: parsedIntrospectionQuery,\n        context,\n    });\n    if ('then' in introspectionResult) {\n        throw new Error(`Executor cannot return promise value in introspectSchemaSync!`);\n    }\n    return getSchemaFromIntrospection(introspectionResult);\n}\n//# sourceMappingURL=introspect.js.map"]},"metadata":{},"sourceType":"module"}