{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar IRTransformer = require('../core/IRTransformer');\n\nvar areEqual = require('../util/areEqualOSS');\n\nvar getIdentifierForSelection = require('../core/getIdentifierForSelection');\n\nvar _require = require('../core/CompilerError'),\n    createCompilerError = _require.createCompilerError,\n    createUserError = _require.createUserError;\n/**\n * Transform that flattens inline fragments, fragment spreads, and conditionals.\n *\n * Inline fragments are inlined (replaced with their selections) when:\n * - The fragment type matches the type of its parent, and its `isForCodegen`,\n *   or if it's for printing, there is no directive on the inline fragment.\n */\n\n\nfunction flattenTransformImpl(context, options) {\n  var state = {\n    isForCodegen: !!(options && options.isForCodegen),\n    parentType: null\n  };\n  var visitorFn = memoizedFlattenSelection(new Map());\n  return IRTransformer.transform(context, {\n    Condition: visitorFn,\n    Defer: visitorFn,\n    Fragment: visitorFn,\n    InlineFragment: visitorFn,\n    InlineDataFragmentSpread: visitorFn,\n    LinkedField: visitorFn,\n    Root: visitorFn,\n    SplitOperation: visitorFn\n  }, function () {\n    return state;\n  });\n}\n\nfunction memoizedFlattenSelection(cache) {\n  return function flattenSelectionsFn(node, state) {\n    var context = this.getContext();\n    var nodeCache = cache.get(node);\n\n    if (nodeCache == null) {\n      nodeCache = new Map();\n      cache.set(node, nodeCache);\n    } // Determine the current type.\n\n\n    var parentType = state.parentType;\n    var result = nodeCache.get(parentType);\n\n    if (result != null) {\n      return result;\n    }\n\n    var type = node.kind === 'LinkedField' || node.kind === 'Fragment' || node.kind === 'Root' || node.kind === 'SplitOperation' ? node.type : node.kind === 'InlineFragment' ? node.typeCondition : parentType;\n\n    if (type == null) {\n      throw createCompilerError('FlattenTransform: Expected a parent type.', [node.loc]);\n    } // Flatten the selections in this node, creating a new node with flattened\n    // selections if possible, then deeply traverse the flattened node, while\n    // keeping track of the parent type.\n\n\n    var nextSelections = new Map();\n    var hasFlattened = flattenSelectionsInto(context.getSchema(), nextSelections, node, state, type);\n    var flattenedNode = hasFlattened ? _objectSpread({}, node, {\n      selections: Array.from(nextSelections.values())\n    }) : node;\n    state.parentType = type;\n    var deeplyFlattenedNode = this.traverse(flattenedNode, state);\n    state.parentType = parentType;\n    nodeCache.set(parentType, deeplyFlattenedNode);\n    return deeplyFlattenedNode;\n  };\n}\n/**\n * @private\n */\n\n\nfunction flattenSelectionsInto(schema, flattenedSelections, node, state, type) {\n  var hasFlattened = false;\n  node.selections.forEach(function (selection) {\n    if (selection.kind === 'InlineFragment' && shouldFlattenInlineFragment(schema, selection, state, type)) {\n      hasFlattened = true;\n      flattenSelectionsInto(schema, flattenedSelections, selection, state, type);\n      return;\n    }\n\n    var nodeIdentifier = getIdentifierForSelection(schema, selection);\n    var flattenedSelection = flattenedSelections.get(nodeIdentifier); // If this selection hasn't been seen before, keep track of it.\n\n    if (!flattenedSelection) {\n      flattenedSelections.set(nodeIdentifier, selection);\n      return;\n    } // Otherwise a similar selection exists which should be merged.\n\n\n    hasFlattened = true;\n\n    if (flattenedSelection.kind === 'InlineFragment') {\n      if (selection.kind !== 'InlineFragment') {\n        throw createCompilerError(\"FlattenTransform: Expected an InlineFragment, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({}, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, selection.typeCondition)\n      }));\n    } else if (flattenedSelection.kind === 'Condition') {\n      if (selection.kind !== 'Condition') {\n        throw createCompilerError(\"FlattenTransform: Expected a Condition, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({}, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, type)\n      }));\n    } else if (flattenedSelection.kind === 'ClientExtension') {\n      if (selection.kind !== 'ClientExtension') {\n        throw createCompilerError(\"FlattenTransform: Expected a ClientExtension, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({}, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, type)\n      }));\n    } else if (flattenedSelection.kind === 'FragmentSpread') {// Ignore duplicate fragment spreads.\n    } else if (flattenedSelection.kind === 'ModuleImport') {\n      if (selection.kind !== 'ModuleImport') {\n        throw createCompilerError(\"FlattenTransform: Expected a ModuleImport, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      if (selection.name !== flattenedSelection.name || selection.module !== flattenedSelection.module || selection.key !== flattenedSelection.key) {\n        throw createUserError('Found conflicting @module selections: use a unique alias on the ' + 'parent fields.', [selection.loc, flattenedSelection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({}, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, type)\n      }));\n    } else if (flattenedSelection.kind === 'Defer') {\n      if (selection.kind !== 'Defer') {\n        throw createCompilerError(\"FlattenTransform: Expected a Defer, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({\n        kind: 'Defer'\n      }, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, type)\n      }));\n    } else if (flattenedSelection.kind === 'Stream') {\n      if (selection.kind !== 'Stream') {\n        throw createCompilerError(\"FlattenTransform: Expected a Stream, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({\n        kind: 'Stream'\n      }, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, type)\n      }));\n    } else if (flattenedSelection.kind === 'LinkedField') {\n      if (selection.kind !== 'LinkedField') {\n        throw createCompilerError(\"FlattenTransform: Expected a LinkedField, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      assertUniqueArgsForAlias(selection, flattenedSelection); // NOTE: not using object spread here as this code is pretty hot\n\n      flattenedSelections.set(nodeIdentifier, {\n        kind: 'LinkedField',\n        alias: flattenedSelection.alias,\n        args: flattenedSelection.args,\n        connection: flattenedSelection.connection || selection.connection,\n        directives: flattenedSelection.directives,\n        handles: mergeHandles(flattenedSelection, selection),\n        loc: flattenedSelection.loc,\n        metadata: flattenedSelection.metadata,\n        name: flattenedSelection.name,\n        selections: mergeSelections(schema, flattenedSelection, selection, state, selection.type),\n        type: flattenedSelection.type\n      });\n    } else if (flattenedSelection.kind === 'ScalarField') {\n      if (selection.kind !== 'ScalarField') {\n        throw createCompilerError(\"FlattenTransform: Expected a ScalarField, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      assertUniqueArgsForAlias(selection, flattenedSelection);\n\n      if (selection.handles && selection.handles.length > 0) {\n        flattenedSelections.set(nodeIdentifier, _objectSpread({\n          kind: 'ScalarField'\n        }, flattenedSelection, {\n          handles: mergeHandles(selection, flattenedSelection)\n        }));\n      }\n    } else if (flattenedSelection.kind === 'InlineDataFragmentSpread') {\n      throw createCompilerError('FlattenTransform: did not expect an InlineDataFragmentSpread node. ' + 'Only expecting InlineDataFragmentSpread in reader ASTs and this ' + 'transform to run only on normalization ASTs.', [selection.loc]);\n    } else {\n      flattenedSelection.kind;\n      throw createCompilerError(\"FlattenTransform: Unknown kind '\".concat(flattenedSelection.kind, \"'\"));\n    }\n  });\n  return hasFlattened;\n}\n/**\n * @private\n */\n\n\nfunction mergeSelections(schema, nodeA, nodeB, state, type) {\n  var flattenedSelections = new Map();\n  flattenSelectionsInto(schema, flattenedSelections, nodeA, state, type);\n  flattenSelectionsInto(schema, flattenedSelections, nodeB, state, type);\n  return Array.from(flattenedSelections.values());\n}\n/**\n * @private\n * TODO(T19327202) This is redundant with OverlappingFieldsCanBeMergedRule once\n * it can be enabled.\n */\n\n\nfunction assertUniqueArgsForAlias(field, otherField) {\n  if (!areEqualFields(field, otherField)) {\n    throw createUserError('Expected all fields on the same parent with the name or alias ' + \"'\".concat(field.alias, \"' to have the same name and arguments.\"), [field.loc, otherField.loc]);\n  }\n}\n/**\n * @private\n */\n\n\nfunction shouldFlattenInlineFragment(schema, fragment, state, type) {\n  return schema.areEqualTypes(fragment.typeCondition, schema.getRawType(type)) && (state.isForCodegen || fragment.directives.length === 0);\n}\n/**\n * @private\n *\n * Verify that two fields are equal in all properties other than their\n * selections.\n */\n\n\nfunction areEqualFields(thisField, thatField) {\n  return thisField.kind === thatField.kind && thisField.name === thatField.name && thisField.alias === thatField.alias && areEqualArgs(thisField.args, thatField.args);\n}\n/**\n * Verify that two sets of arguments are equivalent - same argument names\n * and values. Notably this ignores the types of arguments and values, which\n * may not always be inferred identically.\n */\n\n\nfunction areEqualArgs(thisArgs, thatArgs) {\n  return thisArgs.length === thatArgs.length && thisArgs.every(function (thisArg, index) {\n    var thatArg = thatArgs[index];\n    return thisArg.name === thatArg.name && thisArg.value.kind === thatArg.value.kind && thisArg.value.variableName === thatArg.value.variableName && areEqual(thisArg.value.value, thatArg.value.value);\n  });\n}\n/**\n * @private\n */\n\n\nfunction mergeHandles(nodeA, nodeB) {\n  if (!nodeA.handles) {\n    return nodeB.handles;\n  }\n\n  if (!nodeB.handles) {\n    return nodeA.handles;\n  }\n\n  var uniqueItems = new Map();\n  nodeA.handles.concat(nodeB.handles).forEach(function (item) {\n    return uniqueItems.set(item.name + item.key, item);\n  });\n  return Array.from(uniqueItems.values());\n}\n\nfunction transformWithOptions(options) {\n  return function flattenTransform(context) {\n    return flattenTransformImpl(context, options);\n  };\n}\n\nmodule.exports = {\n  transformWithOptions: transformWithOptions\n};","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/relay-compiler/lib/transforms/FlattenTransform.js"],"names":["_interopRequireDefault","require","_defineProperty2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","IRTransformer","areEqual","getIdentifierForSelection","_require","createCompilerError","createUserError","flattenTransformImpl","context","options","state","isForCodegen","parentType","visitorFn","memoizedFlattenSelection","Map","transform","Condition","Defer","Fragment","InlineFragment","InlineDataFragmentSpread","LinkedField","Root","SplitOperation","cache","flattenSelectionsFn","node","getContext","nodeCache","get","set","result","type","kind","typeCondition","loc","nextSelections","hasFlattened","flattenSelectionsInto","getSchema","flattenedNode","selections","Array","from","values","deeplyFlattenedNode","traverse","schema","flattenedSelections","selection","shouldFlattenInlineFragment","nodeIdentifier","flattenedSelection","concat","mergeSelections","name","module","assertUniqueArgsForAlias","alias","args","connection","directives","handles","mergeHandles","metadata","nodeA","nodeB","field","otherField","areEqualFields","fragment","areEqualTypes","getRawType","thisField","thatField","areEqualArgs","thisArgs","thatArgs","every","thisArg","index","thatArg","value","variableName","uniqueItems","item","transformWithOptions","flattenTransform","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar IRTransformer = require('../core/IRTransformer');\n\nvar areEqual = require('../util/areEqualOSS');\n\nvar getIdentifierForSelection = require('../core/getIdentifierForSelection');\n\nvar _require = require('../core/CompilerError'),\n    createCompilerError = _require.createCompilerError,\n    createUserError = _require.createUserError;\n\n/**\n * Transform that flattens inline fragments, fragment spreads, and conditionals.\n *\n * Inline fragments are inlined (replaced with their selections) when:\n * - The fragment type matches the type of its parent, and its `isForCodegen`,\n *   or if it's for printing, there is no directive on the inline fragment.\n */\nfunction flattenTransformImpl(context, options) {\n  var state = {\n    isForCodegen: !!(options && options.isForCodegen),\n    parentType: null\n  };\n  var visitorFn = memoizedFlattenSelection(new Map());\n  return IRTransformer.transform(context, {\n    Condition: visitorFn,\n    Defer: visitorFn,\n    Fragment: visitorFn,\n    InlineFragment: visitorFn,\n    InlineDataFragmentSpread: visitorFn,\n    LinkedField: visitorFn,\n    Root: visitorFn,\n    SplitOperation: visitorFn\n  }, function () {\n    return state;\n  });\n}\n\nfunction memoizedFlattenSelection(cache) {\n  return function flattenSelectionsFn(node, state) {\n    var context = this.getContext();\n    var nodeCache = cache.get(node);\n\n    if (nodeCache == null) {\n      nodeCache = new Map();\n      cache.set(node, nodeCache);\n    } // Determine the current type.\n\n\n    var parentType = state.parentType;\n    var result = nodeCache.get(parentType);\n\n    if (result != null) {\n      return result;\n    }\n\n    var type = node.kind === 'LinkedField' || node.kind === 'Fragment' || node.kind === 'Root' || node.kind === 'SplitOperation' ? node.type : node.kind === 'InlineFragment' ? node.typeCondition : parentType;\n\n    if (type == null) {\n      throw createCompilerError('FlattenTransform: Expected a parent type.', [node.loc]);\n    } // Flatten the selections in this node, creating a new node with flattened\n    // selections if possible, then deeply traverse the flattened node, while\n    // keeping track of the parent type.\n\n\n    var nextSelections = new Map();\n    var hasFlattened = flattenSelectionsInto(context.getSchema(), nextSelections, node, state, type);\n    var flattenedNode = hasFlattened ? _objectSpread({}, node, {\n      selections: Array.from(nextSelections.values())\n    }) : node;\n    state.parentType = type;\n    var deeplyFlattenedNode = this.traverse(flattenedNode, state);\n    state.parentType = parentType;\n    nodeCache.set(parentType, deeplyFlattenedNode);\n    return deeplyFlattenedNode;\n  };\n}\n/**\n * @private\n */\n\n\nfunction flattenSelectionsInto(schema, flattenedSelections, node, state, type) {\n  var hasFlattened = false;\n  node.selections.forEach(function (selection) {\n    if (selection.kind === 'InlineFragment' && shouldFlattenInlineFragment(schema, selection, state, type)) {\n      hasFlattened = true;\n      flattenSelectionsInto(schema, flattenedSelections, selection, state, type);\n      return;\n    }\n\n    var nodeIdentifier = getIdentifierForSelection(schema, selection);\n    var flattenedSelection = flattenedSelections.get(nodeIdentifier); // If this selection hasn't been seen before, keep track of it.\n\n    if (!flattenedSelection) {\n      flattenedSelections.set(nodeIdentifier, selection);\n      return;\n    } // Otherwise a similar selection exists which should be merged.\n\n\n    hasFlattened = true;\n\n    if (flattenedSelection.kind === 'InlineFragment') {\n      if (selection.kind !== 'InlineFragment') {\n        throw createCompilerError(\"FlattenTransform: Expected an InlineFragment, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({}, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, selection.typeCondition)\n      }));\n    } else if (flattenedSelection.kind === 'Condition') {\n      if (selection.kind !== 'Condition') {\n        throw createCompilerError(\"FlattenTransform: Expected a Condition, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({}, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, type)\n      }));\n    } else if (flattenedSelection.kind === 'ClientExtension') {\n      if (selection.kind !== 'ClientExtension') {\n        throw createCompilerError(\"FlattenTransform: Expected a ClientExtension, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({}, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, type)\n      }));\n    } else if (flattenedSelection.kind === 'FragmentSpread') {// Ignore duplicate fragment spreads.\n    } else if (flattenedSelection.kind === 'ModuleImport') {\n      if (selection.kind !== 'ModuleImport') {\n        throw createCompilerError(\"FlattenTransform: Expected a ModuleImport, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      if (selection.name !== flattenedSelection.name || selection.module !== flattenedSelection.module || selection.key !== flattenedSelection.key) {\n        throw createUserError('Found conflicting @module selections: use a unique alias on the ' + 'parent fields.', [selection.loc, flattenedSelection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({}, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, type)\n      }));\n    } else if (flattenedSelection.kind === 'Defer') {\n      if (selection.kind !== 'Defer') {\n        throw createCompilerError(\"FlattenTransform: Expected a Defer, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({\n        kind: 'Defer'\n      }, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, type)\n      }));\n    } else if (flattenedSelection.kind === 'Stream') {\n      if (selection.kind !== 'Stream') {\n        throw createCompilerError(\"FlattenTransform: Expected a Stream, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      flattenedSelections.set(nodeIdentifier, _objectSpread({\n        kind: 'Stream'\n      }, flattenedSelection, {\n        selections: mergeSelections(schema, flattenedSelection, selection, state, type)\n      }));\n    } else if (flattenedSelection.kind === 'LinkedField') {\n      if (selection.kind !== 'LinkedField') {\n        throw createCompilerError(\"FlattenTransform: Expected a LinkedField, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      assertUniqueArgsForAlias(selection, flattenedSelection); // NOTE: not using object spread here as this code is pretty hot\n\n      flattenedSelections.set(nodeIdentifier, {\n        kind: 'LinkedField',\n        alias: flattenedSelection.alias,\n        args: flattenedSelection.args,\n        connection: flattenedSelection.connection || selection.connection,\n        directives: flattenedSelection.directives,\n        handles: mergeHandles(flattenedSelection, selection),\n        loc: flattenedSelection.loc,\n        metadata: flattenedSelection.metadata,\n        name: flattenedSelection.name,\n        selections: mergeSelections(schema, flattenedSelection, selection, state, selection.type),\n        type: flattenedSelection.type\n      });\n    } else if (flattenedSelection.kind === 'ScalarField') {\n      if (selection.kind !== 'ScalarField') {\n        throw createCompilerError(\"FlattenTransform: Expected a ScalarField, got a '\".concat(selection.kind, \"'\"), [selection.loc]);\n      }\n\n      assertUniqueArgsForAlias(selection, flattenedSelection);\n\n      if (selection.handles && selection.handles.length > 0) {\n        flattenedSelections.set(nodeIdentifier, _objectSpread({\n          kind: 'ScalarField'\n        }, flattenedSelection, {\n          handles: mergeHandles(selection, flattenedSelection)\n        }));\n      }\n    } else if (flattenedSelection.kind === 'InlineDataFragmentSpread') {\n      throw createCompilerError('FlattenTransform: did not expect an InlineDataFragmentSpread node. ' + 'Only expecting InlineDataFragmentSpread in reader ASTs and this ' + 'transform to run only on normalization ASTs.', [selection.loc]);\n    } else {\n      flattenedSelection.kind;\n      throw createCompilerError(\"FlattenTransform: Unknown kind '\".concat(flattenedSelection.kind, \"'\"));\n    }\n  });\n  return hasFlattened;\n}\n/**\n * @private\n */\n\n\nfunction mergeSelections(schema, nodeA, nodeB, state, type) {\n  var flattenedSelections = new Map();\n  flattenSelectionsInto(schema, flattenedSelections, nodeA, state, type);\n  flattenSelectionsInto(schema, flattenedSelections, nodeB, state, type);\n  return Array.from(flattenedSelections.values());\n}\n/**\n * @private\n * TODO(T19327202) This is redundant with OverlappingFieldsCanBeMergedRule once\n * it can be enabled.\n */\n\n\nfunction assertUniqueArgsForAlias(field, otherField) {\n  if (!areEqualFields(field, otherField)) {\n    throw createUserError('Expected all fields on the same parent with the name or alias ' + \"'\".concat(field.alias, \"' to have the same name and arguments.\"), [field.loc, otherField.loc]);\n  }\n}\n/**\n * @private\n */\n\n\nfunction shouldFlattenInlineFragment(schema, fragment, state, type) {\n  return schema.areEqualTypes(fragment.typeCondition, schema.getRawType(type)) && (state.isForCodegen || fragment.directives.length === 0);\n}\n/**\n * @private\n *\n * Verify that two fields are equal in all properties other than their\n * selections.\n */\n\n\nfunction areEqualFields(thisField, thatField) {\n  return thisField.kind === thatField.kind && thisField.name === thatField.name && thisField.alias === thatField.alias && areEqualArgs(thisField.args, thatField.args);\n}\n/**\n * Verify that two sets of arguments are equivalent - same argument names\n * and values. Notably this ignores the types of arguments and values, which\n * may not always be inferred identically.\n */\n\n\nfunction areEqualArgs(thisArgs, thatArgs) {\n  return thisArgs.length === thatArgs.length && thisArgs.every(function (thisArg, index) {\n    var thatArg = thatArgs[index];\n    return thisArg.name === thatArg.name && thisArg.value.kind === thatArg.value.kind && thisArg.value.variableName === thatArg.value.variableName && areEqual(thisArg.value.value, thatArg.value.value);\n  });\n}\n/**\n * @private\n */\n\n\nfunction mergeHandles(nodeA, nodeB) {\n  if (!nodeA.handles) {\n    return nodeB.handles;\n  }\n\n  if (!nodeB.handles) {\n    return nodeA.handles;\n  }\n\n  var uniqueItems = new Map();\n  nodeA.handles.concat(nodeB.handles).forEach(function (item) {\n    return uniqueItems.set(item.name + item.key, item);\n  });\n  return Array.from(uniqueItems.values());\n}\n\nfunction transformWithOptions(options) {\n  return function flattenTransform(context) {\n    return flattenTransformImpl(context, options);\n  };\n}\n\nmodule.exports = {\n  transformWithOptions: transformWithOptions\n};"]},"metadata":{},"sourceType":"script"}