{"ast":null,"code":"import { printSchemaWithDirectives, createSchemaDefinition, compareNodes, isNotEqual, isValidPath, parseGraphQLSDL } from '@graphql-tools/utils';\nimport { isAbsolute, resolve } from 'path';\nimport { pathExists, pathExistsSync, readFile, readFileSync } from 'fs-extra';\nimport { cwd } from 'process';\nimport { Kind, visit, isSchema, parse, Source, getDescription, print, isExecutableDefinitionNode } from 'graphql';\nimport { processImport } from '@graphql-tools/import';\n\nfunction mergeArguments(args1, args2, config) {\n  const result = deduplicateArguments([].concat(args2, args1).filter(a => a));\n\n  if (config && config.sort) {\n    result.sort(compareNodes);\n  }\n\n  return result;\n}\n\nfunction deduplicateArguments(args) {\n  return args.reduce((acc, current) => {\n    const dup = acc.find(arg => arg.name.value === current.name.value);\n\n    if (!dup) {\n      return acc.concat([current]);\n    }\n\n    return acc;\n  }, []);\n}\n\nlet commentsRegistry = {};\n\nfunction resetComments() {\n  commentsRegistry = {};\n}\n\nfunction collectComment(node) {\n  const entityName = node.name.value;\n  pushComment(node, entityName);\n\n  switch (node.kind) {\n    case 'EnumTypeDefinition':\n      node.values.forEach(value => {\n        pushComment(value, entityName, value.name.value);\n      });\n      break;\n\n    case 'ObjectTypeDefinition':\n    case 'InputObjectTypeDefinition':\n    case 'InterfaceTypeDefinition':\n      if (node.fields) {\n        node.fields.forEach(field => {\n          pushComment(field, entityName, field.name.value);\n\n          if (isFieldDefinitionNode(field) && field.arguments) {\n            field.arguments.forEach(arg => {\n              pushComment(arg, entityName, field.name.value, arg.name.value);\n            });\n          }\n        });\n      }\n\n      break;\n  }\n}\n\nfunction pushComment(node, entity, field, argument) {\n  const comment = getDescription(node, {\n    commentDescriptions: true\n  });\n\n  if (typeof comment !== 'string' || comment.length === 0) {\n    return;\n  }\n\n  const keys = [entity];\n\n  if (field) {\n    keys.push(field);\n\n    if (argument) {\n      keys.push(argument);\n    }\n  }\n\n  const path = keys.join('.');\n\n  if (!commentsRegistry[path]) {\n    commentsRegistry[path] = [];\n  }\n\n  commentsRegistry[path].push(comment);\n}\n\nfunction printComment(comment) {\n  return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n// import { visit, VisitFn } from 'graphql/language/visitor';\n\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\n\n\nfunction join(maybeArray, separator) {\n  return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\n\nfunction addDescription(cb) {\n  return (node, _key, _parent, path, ancestors) => {\n    const keys = [];\n    const parent = path.reduce((prev, key) => {\n      if (['fields', 'arguments', 'values'].includes(key)) {\n        keys.push(prev.name.value);\n      }\n\n      return prev[key];\n    }, ancestors[0]);\n    const key = [...keys, parent.name.value].join('.');\n    const items = [];\n\n    if (commentsRegistry[key]) {\n      items.push(...commentsRegistry[key]);\n    }\n\n    return join([...items.map(printComment), node.description, cb(node)], '\\n');\n  };\n}\n\nfunction indent(maybeString) {\n  return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\n\n\nfunction block(array) {\n  return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\n\n\nfunction wrap(start, maybeString, end) {\n  return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\n\n\nfunction printBlockString(value, isDescription) {\n  const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n  return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1 ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"` : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\n\n\nfunction printWithComments(ast) {\n  return visit(ast, {\n    leave: {\n      Name: node => node.value,\n      Variable: node => `$${node.name}`,\n      // Document\n      Document: node => `${node.definitions.map(defNode => `${defNode}\\n${defNode[0] === '#' ? '' : '\\n'}`).join('').trim()}\\n`,\n      OperationTypeDefinition: node => `${node.operation}: ${node.type}`,\n      VariableDefinition: ({\n        variable,\n        type,\n        defaultValue\n      }) => `${variable}: ${type}${wrap(' = ', defaultValue)}`,\n      SelectionSet: ({\n        selections\n      }) => block(selections),\n      Field: ({\n        alias,\n        name,\n        arguments: args,\n        directives,\n        selectionSet\n      }) => join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], '  '),\n      Argument: addDescription(({\n        name,\n        value\n      }) => `${name}: ${value}`),\n      // Value\n      IntValue: ({\n        value\n      }) => value,\n      FloatValue: ({\n        value\n      }) => value,\n      StringValue: ({\n        value,\n        block: isBlockString\n      }, key) => isBlockString ? printBlockString(value, key === 'description') : JSON.stringify(value),\n      BooleanValue: ({\n        value\n      }) => value ? 'true' : 'false',\n      NullValue: () => 'null',\n      EnumValue: ({\n        value\n      }) => value,\n      ListValue: ({\n        values\n      }) => `[${join(values, ', ')}]`,\n      ObjectValue: ({\n        fields\n      }) => `{${join(fields, ', ')}}`,\n      ObjectField: ({\n        name,\n        value\n      }) => `${name}: ${value}`,\n      // Directive\n      Directive: ({\n        name,\n        arguments: args\n      }) => `@${name}${wrap('(', join(args, ', '), ')')}`,\n      // Type\n      NamedType: ({\n        name\n      }) => name,\n      ListType: ({\n        type\n      }) => `[${type}]`,\n      NonNullType: ({\n        type\n      }) => `${type}!`,\n      // Type System Definitions\n      SchemaDefinition: ({\n        directives,\n        operationTypes\n      }) => join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n      ScalarTypeDefinition: addDescription(({\n        name,\n        directives\n      }) => join(['scalar', name, join(directives, ' ')], ' ')),\n      ObjectTypeDefinition: addDescription(({\n        name,\n        interfaces,\n        directives,\n        fields\n      }) => join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ')),\n      FieldDefinition: addDescription(({\n        name,\n        arguments: args,\n        type,\n        directives\n      }) => `${name + wrap('(', join(args, ', '), ')')}: ${type}${wrap(' ', join(directives, ' '))}`),\n      InputValueDefinition: addDescription(({\n        name,\n        type,\n        defaultValue,\n        directives\n      }) => join([`${name}: ${type}`, wrap('= ', defaultValue), join(directives, ' ')], ' ')),\n      InterfaceTypeDefinition: addDescription(({\n        name,\n        directives,\n        fields\n      }) => join(['interface', name, join(directives, ' '), block(fields)], ' ')),\n      UnionTypeDefinition: addDescription(({\n        name,\n        directives,\n        types\n      }) => join(['union', name, join(directives, ' '), types && types.length !== 0 ? `= ${join(types, ' | ')}` : ''], ' ')),\n      EnumTypeDefinition: addDescription(({\n        name,\n        directives,\n        values\n      }) => join(['enum', name, join(directives, ' '), block(values)], ' ')),\n      EnumValueDefinition: addDescription(({\n        name,\n        directives\n      }) => join([name, join(directives, ' ')], ' ')),\n      InputObjectTypeDefinition: addDescription(({\n        name,\n        directives,\n        fields\n      }) => join(['input', name, join(directives, ' '), block(fields)], ' ')),\n      ScalarTypeExtension: ({\n        name,\n        directives\n      }) => join(['extend scalar', name, join(directives, ' ')], ' '),\n      ObjectTypeExtension: ({\n        name,\n        interfaces,\n        directives,\n        fields\n      }) => join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n      InterfaceTypeExtension: ({\n        name,\n        directives,\n        fields\n      }) => join(['extend interface', name, join(directives, ' '), block(fields)], ' '),\n      UnionTypeExtension: ({\n        name,\n        directives,\n        types\n      }) => join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? `= ${join(types, ' | ')}` : ''], ' '),\n      EnumTypeExtension: ({\n        name,\n        directives,\n        values\n      }) => join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n      InputObjectTypeExtension: ({\n        name,\n        directives,\n        fields\n      }) => join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n      DirectiveDefinition: addDescription(({\n        name,\n        arguments: args,\n        locations\n      }) => `directive @${name}${wrap('(', join(args, ', '), ')')} on ${join(locations, ' | ')}`)\n    }\n  });\n}\n\nfunction isFieldDefinitionNode(node) {\n  return node.kind === 'FieldDefinition';\n}\n\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n  return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\n\nfunction nameAlreadyExists(name, namesArr) {\n  return namesArr.some(({\n    value\n  }) => value === name.value);\n}\n\nfunction mergeArguments$1(a1, a2) {\n  const result = [...a2];\n\n  for (const argument of a1) {\n    const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n\n    if (existingIndex > -1) {\n      const existingArg = result[existingIndex];\n\n      if (existingArg.value.kind === 'ListValue') {\n        const source = existingArg.value.values;\n        const target = argument.value.values; // merge values of two lists\n\n        existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n          const value = targetVal.value;\n          return !value || !source.some(sourceVal => sourceVal.value === value);\n        });\n      } else {\n        existingArg.value = argument.value;\n      }\n    } else {\n      result.push(argument);\n    }\n  }\n\n  return result;\n}\n\nfunction deduplicateDirectives(directives) {\n  return directives.map((directive, i, all) => {\n    const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n\n    if (firstAt !== i) {\n      const dup = all[firstAt];\n      directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);\n      return null;\n    }\n\n    return directive;\n  }).filter(d => d);\n}\n\nfunction mergeDirectives(d1 = [], d2 = [], config) {\n  const reverseOrder = config && config.reverseDirectives;\n  const asNext = reverseOrder ? d1 : d2;\n  const asFirst = reverseOrder ? d2 : d1;\n  const result = deduplicateDirectives([...asNext]);\n\n  for (const directive of asFirst) {\n    if (directiveAlreadyExists(result, directive)) {\n      const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n      const existingDirective = result[existingDirectiveIndex];\n      result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);\n    } else {\n      result.push(directive);\n    }\n  }\n\n  return result;\n}\n\nfunction validateInputs(node, existingNode) {\n  const printedNode = print(node);\n  const printedExistingNode = print(existingNode);\n  const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n  const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n\n  if (!sameArguments) {\n    throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n  }\n}\n\nfunction mergeDirective(node, existingNode) {\n  if (existingNode) {\n    validateInputs(node, existingNode);\n    return { ...node,\n      locations: [...existingNode.locations, ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations))]\n    };\n  }\n\n  return node;\n}\n\nfunction deduplicateLists(source, target, filterFn) {\n  return source.concat(target.filter(val => filterFn(val, source)));\n}\n\nfunction mergeEnumValues(first, second, config) {\n  const enumValueMap = new Map();\n\n  for (const firstValue of first) {\n    enumValueMap.set(firstValue.name.value, firstValue);\n  }\n\n  for (const secondValue of second) {\n    const enumValue = secondValue.name.value;\n\n    if (enumValueMap.has(enumValue)) {\n      const firstValue = enumValueMap.get(enumValue);\n      firstValue.description = secondValue.description || firstValue.description;\n      firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);\n    } else {\n      enumValueMap.set(enumValue, secondValue);\n    }\n  }\n\n  const result = [...enumValueMap.values()];\n\n  if (config && config.sort) {\n    result.sort(compareNodes);\n  }\n\n  return result;\n}\n\nfunction mergeEnum(e1, e2, config) {\n  if (e2) {\n    return {\n      name: e1.name,\n      description: e1['description'] || e2['description'],\n      kind: config && config.convertExtensions || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition' ? 'EnumTypeDefinition' : 'EnumTypeExtension',\n      loc: e1.loc,\n      directives: mergeDirectives(e1.directives, e2.directives, config),\n      values: mergeEnumValues(e1.values, e2.values, config)\n    };\n  }\n\n  return config && config.convertExtensions ? { ...e1,\n    kind: 'EnumTypeDefinition'\n  } : e1;\n}\n\nfunction isStringTypes(types) {\n  return typeof types === 'string';\n}\n\nfunction isSourceTypes(types) {\n  return types instanceof Source;\n}\n\nfunction isGraphQLType(definition) {\n  return definition.kind === 'ObjectTypeDefinition';\n}\n\nfunction isGraphQLTypeExtension(definition) {\n  return definition.kind === 'ObjectTypeExtension';\n}\n\nfunction isGraphQLEnum(definition) {\n  return definition.kind === 'EnumTypeDefinition';\n}\n\nfunction isGraphQLEnumExtension(definition) {\n  return definition.kind === 'EnumTypeExtension';\n}\n\nfunction isGraphQLUnion(definition) {\n  return definition.kind === 'UnionTypeDefinition';\n}\n\nfunction isGraphQLUnionExtension(definition) {\n  return definition.kind === 'UnionTypeExtension';\n}\n\nfunction isGraphQLScalar(definition) {\n  return definition.kind === 'ScalarTypeDefinition';\n}\n\nfunction isGraphQLScalarExtension(definition) {\n  return definition.kind === 'ScalarTypeExtension';\n}\n\nfunction isGraphQLInputType(definition) {\n  return definition.kind === 'InputObjectTypeDefinition';\n}\n\nfunction isGraphQLInputTypeExtension(definition) {\n  return definition.kind === 'InputObjectTypeExtension';\n}\n\nfunction isGraphQLInterface(definition) {\n  return definition.kind === 'InterfaceTypeDefinition';\n}\n\nfunction isGraphQLInterfaceExtension(definition) {\n  return definition.kind === 'InterfaceTypeExtension';\n}\n\nfunction isGraphQLDirective(definition) {\n  return definition.kind === 'DirectiveDefinition';\n}\n\nfunction extractType(type) {\n  let visitedType = type;\n\n  while (visitedType.kind === 'ListType' || visitedType.kind === 'NonNullType') {\n    visitedType = visitedType.type;\n  }\n\n  return visitedType;\n}\n\nfunction isSchemaDefinition(node) {\n  return node.kind === 'SchemaDefinition';\n}\n\nfunction isWrappingTypeNode(type) {\n  return type.kind !== Kind.NAMED_TYPE;\n}\n\nfunction isListTypeNode(type) {\n  return type.kind === Kind.LIST_TYPE;\n}\n\nfunction isNonNullTypeNode(type) {\n  return type.kind === Kind.NON_NULL_TYPE;\n}\n\nfunction printTypeNode(type) {\n  if (isListTypeNode(type)) {\n    return `[${printTypeNode(type.type)}]`;\n  }\n\n  if (isNonNullTypeNode(type)) {\n    return `${printTypeNode(type.type)}!`;\n  }\n\n  return type.name.value;\n}\n\nfunction fieldAlreadyExists(fieldsArr, otherField) {\n  const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n\n  if (result) {\n    const t1 = extractType(result.type);\n    const t2 = extractType(otherField.type);\n\n    if (t1.name.value !== t2.name.value) {\n      throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n    }\n  }\n\n  return !!result;\n}\n\nfunction mergeFields(type, f1, f2, config) {\n  const result = [...f2];\n\n  for (const field of f1) {\n    if (fieldAlreadyExists(result, field)) {\n      const existing = result.find(f => f.name.value === field.name.value);\n\n      if (config && config.throwOnConflict) {\n        preventConflicts(type, existing, field, false);\n      } else {\n        preventConflicts(type, existing, field, true);\n      }\n\n      if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {\n        existing.type = field.type;\n      }\n\n      existing.arguments = mergeArguments(field['arguments'] || [], existing.arguments || [], config);\n      existing.directives = mergeDirectives(field.directives, existing.directives, config);\n      existing.description = field.description || existing.description;\n    } else {\n      result.push(field);\n    }\n  }\n\n  if (config && config.sort) {\n    result.sort(compareNodes);\n  }\n\n  if (config && config.exclusions) {\n    return result.filter(field => !config.exclusions.includes(`${type.name.value}.${field.name.value}`));\n  }\n\n  return result;\n}\n\nfunction preventConflicts(type, a, b, ignoreNullability = false) {\n  const aType = printTypeNode(a.type);\n  const bType = printTypeNode(b.type);\n\n  if (isNotEqual(aType, bType)) {\n    if (safeChangeForFieldType(a.type, b.type, ignoreNullability) === false) {\n      throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n    }\n  }\n}\n\nfunction safeChangeForFieldType(oldType, newType, ignoreNullability = false) {\n  // both are named\n  if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {\n    return oldType.toString() === newType.toString();\n  } // new is non-null\n\n\n  if (isNonNullTypeNode(newType)) {\n    const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;\n    return safeChangeForFieldType(ofType, newType.type);\n  } // old is non-null\n\n\n  if (isNonNullTypeNode(oldType)) {\n    return safeChangeForFieldType(newType, oldType, ignoreNullability);\n  } // old is list\n\n\n  if (isListTypeNode(oldType)) {\n    return isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type) || isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType['type']);\n  }\n\n  return false;\n}\n\nfunction mergeInputType(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: config && config.convertExtensions || node.kind === 'InputObjectTypeDefinition' || existingNode.kind === 'InputObjectTypeDefinition' ? 'InputObjectTypeDefinition' : 'InputObjectTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return config && config.convertExtensions ? { ...node,\n    kind: 'InputObjectTypeDefinition'\n  } : node;\n}\n\nfunction mergeInterface(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: config && config.convertExtensions || node.kind === 'InterfaceTypeDefinition' || existingNode.kind === 'InterfaceTypeDefinition' ? 'InterfaceTypeDefinition' : 'InterfaceTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return config && config.convertExtensions ? { ...node,\n    kind: 'InterfaceTypeDefinition'\n  } : node;\n}\n\nfunction alreadyExists(arr, other) {\n  return !!arr.find(i => i.name.value === other.name.value);\n}\n\nfunction mergeNamedTypeArray(first, second, config) {\n  const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n\n  if (config && config.sort) {\n    result.sort(compareNodes);\n  }\n\n  return result;\n}\n\nfunction mergeType(node, existingNode, config) {\n  if (existingNode) {\n    try {\n      return {\n        name: node.name,\n        description: node['description'] || existingNode['description'],\n        kind: config && config.convertExtensions || node.kind === 'ObjectTypeDefinition' || existingNode.kind === 'ObjectTypeDefinition' ? 'ObjectTypeDefinition' : 'ObjectTypeExtension',\n        loc: node.loc,\n        fields: mergeFields(node, node.fields, existingNode.fields, config),\n        directives: mergeDirectives(node.directives, existingNode.directives, config),\n        interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config)\n      };\n    } catch (e) {\n      throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n    }\n  }\n\n  return config && config.convertExtensions ? { ...node,\n    kind: 'ObjectTypeDefinition'\n  } : node;\n}\n\nfunction mergeUnion(first, second, config) {\n  if (second) {\n    return {\n      name: first.name,\n      description: first['description'] || second['description'],\n      directives: mergeDirectives(first.directives, second.directives, config),\n      kind: config && config.convertExtensions || first.kind === 'UnionTypeDefinition' || second.kind === 'UnionTypeDefinition' ? 'UnionTypeDefinition' : 'UnionTypeExtension',\n      loc: first.loc,\n      types: mergeNamedTypeArray(first.types, second.types, config)\n    };\n  }\n\n  return config && config.convertExtensions ? { ...first,\n    kind: 'UnionTypeDefinition'\n  } : first;\n}\n\nfunction mergeGraphQLNodes(nodes, config) {\n  return nodes.reduce((prev, nodeDefinition) => {\n    const node = nodeDefinition;\n\n    if (node && node.name && node.name.value) {\n      const name = node.name.value;\n\n      if (config && config.commentDescriptions) {\n        collectComment(node);\n      }\n\n      if (config && config.exclusions && (config.exclusions.includes(name + '.*') || config.exclusions.includes(name))) {\n        delete prev[name];\n      } else if (isGraphQLType(nodeDefinition) || isGraphQLTypeExtension(nodeDefinition)) {\n        prev[name] = mergeType(nodeDefinition, prev[name], config);\n      } else if (isGraphQLEnum(nodeDefinition) || isGraphQLEnumExtension(nodeDefinition)) {\n        prev[name] = mergeEnum(nodeDefinition, prev[name], config);\n      } else if (isGraphQLUnion(nodeDefinition) || isGraphQLUnionExtension(nodeDefinition)) {\n        prev[name] = mergeUnion(nodeDefinition, prev[name], config);\n      } else if (isGraphQLScalar(nodeDefinition) || isGraphQLScalarExtension(nodeDefinition)) {\n        prev[name] = nodeDefinition;\n      } else if (isGraphQLInputType(nodeDefinition) || isGraphQLInputTypeExtension(nodeDefinition)) {\n        prev[name] = mergeInputType(nodeDefinition, prev[name], config);\n      } else if (isGraphQLInterface(nodeDefinition) || isGraphQLInterfaceExtension(nodeDefinition)) {\n        prev[name] = mergeInterface(nodeDefinition, prev[name], config);\n      } else if (isGraphQLDirective(nodeDefinition)) {\n        prev[name] = mergeDirective(nodeDefinition, prev[name]);\n      }\n    }\n\n    return prev;\n  }, {});\n}\n\nfunction mergeTypeDefs(types, config) {\n  resetComments();\n  const doc = {\n    kind: Kind.DOCUMENT,\n    definitions: mergeGraphQLTypes(types, {\n      useSchemaDefinition: true,\n      forceSchemaDefinition: false,\n      throwOnConflict: false,\n      commentDescriptions: false,\n      ...config\n    })\n  };\n  let result;\n\n  if (config && config.commentDescriptions) {\n    result = printWithComments(doc);\n  } else {\n    result = doc;\n  }\n\n  resetComments();\n  return result;\n}\n\nfunction mergeGraphQLTypes(types, config) {\n  resetComments();\n  const allNodes = types.map(type => {\n    if (Array.isArray(type)) {\n      type = mergeTypeDefs(type);\n    }\n\n    if (isSchema(type)) {\n      return parse(printSchemaWithDirectives(type));\n    } else if (isStringTypes(type) || isSourceTypes(type)) {\n      return parse(type);\n    }\n\n    return type;\n  }).map(ast => ast.definitions).reduce((defs, newDef = []) => [...defs, ...newDef], []); // XXX: right now we don't handle multiple schema definitions\n\n  let schemaDef = allNodes.filter(isSchemaDefinition).reduce((def, node) => {\n    node.operationTypes.filter(op => op.type.name.value).forEach(op => {\n      def[op.operation] = op.type.name.value;\n    });\n    return def;\n  }, {\n    query: null,\n    mutation: null,\n    subscription: null\n  });\n  const mergedNodes = mergeGraphQLNodes(allNodes, config);\n  const allTypes = Object.keys(mergedNodes);\n\n  if (config && config.sort) {\n    allTypes.sort(typeof config.sort === 'function' ? config.sort : undefined);\n  }\n\n  if (config && config.useSchemaDefinition) {\n    const queryType = schemaDef.query ? schemaDef.query : allTypes.find(t => t === 'Query');\n    const mutationType = schemaDef.mutation ? schemaDef.mutation : allTypes.find(t => t === 'Mutation');\n    const subscriptionType = schemaDef.subscription ? schemaDef.subscription : allTypes.find(t => t === 'Subscription');\n    schemaDef = {\n      query: queryType,\n      mutation: mutationType,\n      subscription: subscriptionType\n    };\n  }\n\n  const schemaDefinition = createSchemaDefinition(schemaDef, {\n    force: config.forceSchemaDefinition\n  });\n\n  if (!schemaDefinition) {\n    return Object.values(mergedNodes);\n  }\n\n  return [...Object.values(mergedNodes), parse(schemaDefinition).definitions[0]];\n}\n\nconst FILE_EXTENSIONS = ['.gql', '.gqls', '.graphql', '.graphqls'];\n\nfunction isGraphQLImportFile(rawSDL) {\n  const trimmedRawSDL = rawSDL.trim();\n  return trimmedRawSDL.startsWith('# import') || trimmedRawSDL.startsWith('#import');\n}\n/**\n * This loader loads documents and type definitions from `.graphql` files.\n *\n * You can load a single source:\n *\n * ```js\n * const schema = await loadSchema('schema.graphql', {\n *   loaders: [\n *     new GraphQLFileLoader()\n *   ]\n * });\n * ```\n *\n * Or provide a glob pattern to load multiple sources:\n *\n * ```js\n * const schema = await loadSchema('graphql/*.graphql', {\n *   loaders: [\n *     new GraphQLFileLoader()\n *   ]\n * });\n * ```\n */\n\n\nclass GraphQLFileLoader {\n  loaderId() {\n    return 'graphql-file';\n  }\n\n  async canLoad(pointer, options) {\n    if (isValidPath(pointer)) {\n      if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {\n        const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);\n        return pathExists(normalizedFilePath);\n      }\n    }\n\n    return false;\n  }\n\n  canLoadSync(pointer, options) {\n    if (isValidPath(pointer)) {\n      if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {\n        const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);\n        return pathExistsSync(normalizedFilePath);\n      }\n    }\n\n    return false;\n  }\n\n  async load(pointer, options) {\n    const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);\n    const rawSDL = await readFile(normalizedFilePath, {\n      encoding: 'utf8'\n    });\n    return this.handleFileContent(rawSDL, pointer, options);\n  }\n\n  loadSync(pointer, options) {\n    const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || cwd(), pointer);\n    const rawSDL = readFileSync(normalizedFilePath, {\n      encoding: 'utf8'\n    });\n    return this.handleFileContent(rawSDL, pointer, options);\n  }\n\n  handleFileContent(rawSDL, pointer, options) {\n    if (!options.skipGraphQLImport && isGraphQLImportFile(rawSDL)) {\n      const document = processImport(pointer, options.cwd);\n      const typeSystemDefinitions = document.definitions.filter(d => !isExecutableDefinitionNode(d)).map(definition => ({\n        kind: Kind.DOCUMENT,\n        definitions: [definition]\n      }));\n      const mergedTypeDefs = mergeTypeDefs(typeSystemDefinitions, {\n        useSchemaDefinition: false\n      });\n      const executableDefinitions = document.definitions.filter(isExecutableDefinitionNode);\n      return {\n        location: pointer,\n        document: { ...mergedTypeDefs,\n          definitions: [...mergedTypeDefs.definitions, ...executableDefinitions]\n        }\n      };\n    }\n\n    return parseGraphQLSDL(pointer, rawSDL, options);\n  }\n\n}\n\nexport { GraphQLFileLoader };","map":{"version":3,"sources":["../../../packages/merge/dist/index.esm.js","../../../dist/loaders/graphql-file/src/index.js"],"names":["processCwd"],"mappings":"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","sourcesContent":["import { mergeDeep, compareNodes, isNotEqual, printSchemaWithDirectives, createSchemaDefinition, asArray, getResolversFromSchema, SchemaDirectiveVisitor } from '@graphql-tools/utils';\nimport { getDescription, visit, print, Source, Kind, isSchema, parse, isScalarType, isSpecifiedScalarType, isIntrospectionType, isObjectType, isInterfaceType, isInputObjectType, isUnionType, isEnumType, buildSchema, buildASTSchema } from 'graphql';\nimport { addResolversToSchema, addErrorLoggingToSchema } from '@graphql-tools/schema';\n\n/**\n * Deep merges multiple resolver definition objects into a single definition.\n * @param resolversDefinitions Resolver definitions to be merged\n * @param options Additional options\n *\n * ```js\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const clientResolver = require('./clientResolver');\n * const productResolver = require('./productResolver');\n *\n * const resolvers = mergeResolvers([\n *  clientResolver,\n *  productResolver,\n * ]);\n * ```\n *\n * If you don't want to manually create the array of resolver objects, you can\n * also use this function along with loadFiles:\n *\n * ```js\n * const path = require('path');\n * const { mergeResolvers } = require('@graphql-tools/merge');\n * const { loadFilesSync } = require('@graphql-tools/load-files');\n *\n * const resolversArray = loadFilesSync(path.join(__dirname, './resolvers'));\n *\n * const resolvers = mergeResolvers(resolversArray)\n * ```\n */\nfunction mergeResolvers(resolversDefinitions, options) {\n    if (!resolversDefinitions || resolversDefinitions.length === 0) {\n        return {};\n    }\n    if (resolversDefinitions.length === 1) {\n        const singleDefinition = resolversDefinitions[0];\n        if (Array.isArray(singleDefinition)) {\n            return mergeResolvers(singleDefinition);\n        }\n        return singleDefinition;\n    }\n    const resolversFactories = new Array();\n    const resolvers = new Array();\n    for (let resolversDefinition of resolversDefinitions) {\n        if (Array.isArray(resolversDefinition)) {\n            resolversDefinition = mergeResolvers(resolversDefinition);\n        }\n        if (typeof resolversDefinition === 'function') {\n            resolversFactories.push(resolversDefinition);\n        }\n        else if (typeof resolversDefinition === 'object') {\n            resolvers.push(resolversDefinition);\n        }\n    }\n    let result = {};\n    if (resolversFactories.length) {\n        result = ((...args) => {\n            const resultsOfFactories = resolversFactories.map(factory => factory(...args));\n            return resolvers.concat(resultsOfFactories).reduce(mergeDeep, {});\n        });\n    }\n    else {\n        result = resolvers.reduce(mergeDeep, {});\n    }\n    if (options && options.exclusions) {\n        for (const exclusion of options.exclusions) {\n            const [typeName, fieldName] = exclusion.split('.');\n            if (!fieldName || fieldName === '*') {\n                delete result[typeName];\n            }\n            else if (result[typeName]) {\n                delete result[typeName][fieldName];\n            }\n        }\n    }\n    return result;\n}\n\nfunction mergeArguments(args1, args2, config) {\n    const result = deduplicateArguments([].concat(args2, args1).filter(a => a));\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\nfunction deduplicateArguments(args) {\n    return args.reduce((acc, current) => {\n        const dup = acc.find(arg => arg.name.value === current.name.value);\n        if (!dup) {\n            return acc.concat([current]);\n        }\n        return acc;\n    }, []);\n}\n\nlet commentsRegistry = {};\nfunction resetComments() {\n    commentsRegistry = {};\n}\nfunction collectComment(node) {\n    const entityName = node.name.value;\n    pushComment(node, entityName);\n    switch (node.kind) {\n        case 'EnumTypeDefinition':\n            node.values.forEach(value => {\n                pushComment(value, entityName, value.name.value);\n            });\n            break;\n        case 'ObjectTypeDefinition':\n        case 'InputObjectTypeDefinition':\n        case 'InterfaceTypeDefinition':\n            if (node.fields) {\n                node.fields.forEach((field) => {\n                    pushComment(field, entityName, field.name.value);\n                    if (isFieldDefinitionNode(field) && field.arguments) {\n                        field.arguments.forEach(arg => {\n                            pushComment(arg, entityName, field.name.value, arg.name.value);\n                        });\n                    }\n                });\n            }\n            break;\n    }\n}\nfunction pushComment(node, entity, field, argument) {\n    const comment = getDescription(node, { commentDescriptions: true });\n    if (typeof comment !== 'string' || comment.length === 0) {\n        return;\n    }\n    const keys = [entity];\n    if (field) {\n        keys.push(field);\n        if (argument) {\n            keys.push(argument);\n        }\n    }\n    const path = keys.join('.');\n    if (!commentsRegistry[path]) {\n        commentsRegistry[path] = [];\n    }\n    commentsRegistry[path].push(comment);\n}\nfunction printComment(comment) {\n    return '\\n# ' + comment.replace(/\\n/g, '\\n# ');\n}\n/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/**\n * NOTE: ==> This file has been modified just to add comments to the printed AST\n * This is a temp measure, we will move to using the original non modified printer.js ASAP.\n */\n// import { visit, VisitFn } from 'graphql/language/visitor';\n/**\n * Given maybeArray, print an empty string if it is null or empty, otherwise\n * print all items together separated by separator if provided\n */\nfunction join(maybeArray, separator) {\n    return maybeArray ? maybeArray.filter(x => x).join(separator || '') : '';\n}\nfunction addDescription(cb) {\n    return (node, _key, _parent, path, ancestors) => {\n        const keys = [];\n        const parent = path.reduce((prev, key) => {\n            if (['fields', 'arguments', 'values'].includes(key)) {\n                keys.push(prev.name.value);\n            }\n            return prev[key];\n        }, ancestors[0]);\n        const key = [...keys, parent.name.value].join('.');\n        const items = [];\n        if (commentsRegistry[key]) {\n            items.push(...commentsRegistry[key]);\n        }\n        return join([...items.map(printComment), node.description, cb(node)], '\\n');\n    };\n}\nfunction indent(maybeString) {\n    return maybeString && `  ${maybeString.replace(/\\n/g, '\\n  ')}`;\n}\n/**\n * Given array, print each item on its own line, wrapped in an\n * indented \"{ }\" block.\n */\nfunction block(array) {\n    return array && array.length !== 0 ? `{\\n${indent(join(array, '\\n'))}\\n}` : '';\n}\n/**\n * If maybeString is not null or empty, then wrap with start and end, otherwise\n * print an empty string.\n */\nfunction wrap(start, maybeString, end) {\n    return maybeString ? start + maybeString + (end || '') : '';\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n */\nfunction printBlockString(value, isDescription) {\n    const escaped = value.replace(/\"\"\"/g, '\\\\\"\"\"');\n    return (value[0] === ' ' || value[0] === '\\t') && value.indexOf('\\n') === -1\n        ? `\"\"\"${escaped.replace(/\"$/, '\"\\n')}\"\"\"`\n        : `\"\"\"\\n${isDescription ? escaped : indent(escaped)}\\n\"\"\"`;\n}\n/**\n * Converts an AST into a string, using one set of reasonable\n * formatting rules.\n */\nfunction printWithComments(ast) {\n    return visit(ast, {\n        leave: {\n            Name: node => node.value,\n            Variable: node => `$${node.name}`,\n            // Document\n            Document: node => `${node.definitions\n                .map(defNode => `${defNode}\\n${defNode[0] === '#' ? '' : '\\n'}`)\n                .join('')\n                .trim()}\\n`,\n            OperationTypeDefinition: node => `${node.operation}: ${node.type}`,\n            VariableDefinition: ({ variable, type, defaultValue }) => `${variable}: ${type}${wrap(' = ', defaultValue)}`,\n            SelectionSet: ({ selections }) => block(selections),\n            Field: ({ alias, name, arguments: args, directives, selectionSet }) => join([wrap('', alias, ': ') + name + wrap('(', join(args, ', '), ')'), join(directives, ' '), selectionSet], '  '),\n            Argument: addDescription(({ name, value }) => `${name}: ${value}`),\n            // Value\n            IntValue: ({ value }) => value,\n            FloatValue: ({ value }) => value,\n            StringValue: ({ value, block: isBlockString }, key) => isBlockString ? printBlockString(value, key === 'description') : JSON.stringify(value),\n            BooleanValue: ({ value }) => (value ? 'true' : 'false'),\n            NullValue: () => 'null',\n            EnumValue: ({ value }) => value,\n            ListValue: ({ values }) => `[${join(values, ', ')}]`,\n            ObjectValue: ({ fields }) => `{${join(fields, ', ')}}`,\n            ObjectField: ({ name, value }) => `${name}: ${value}`,\n            // Directive\n            Directive: ({ name, arguments: args }) => `@${name}${wrap('(', join(args, ', '), ')')}`,\n            // Type\n            NamedType: ({ name }) => name,\n            ListType: ({ type }) => `[${type}]`,\n            NonNullType: ({ type }) => `${type}!`,\n            // Type System Definitions\n            SchemaDefinition: ({ directives, operationTypes }) => join(['schema', join(directives, ' '), block(operationTypes)], ' '),\n            ScalarTypeDefinition: addDescription(({ name, directives }) => join(['scalar', name, join(directives, ' ')], ' ')),\n            ObjectTypeDefinition: addDescription(({ name, interfaces, directives, fields }) => join(['type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' ')),\n            FieldDefinition: addDescription(({ name, arguments: args, type, directives }) => `${name + wrap('(', join(args, ', '), ')')}: ${type}${wrap(' ', join(directives, ' '))}`),\n            InputValueDefinition: addDescription(({ name, type, defaultValue, directives }) => join([`${name}: ${type}`, wrap('= ', defaultValue), join(directives, ' ')], ' ')),\n            InterfaceTypeDefinition: addDescription(({ name, directives, fields }) => join(['interface', name, join(directives, ' '), block(fields)], ' ')),\n            UnionTypeDefinition: addDescription(({ name, directives, types }) => join(['union', name, join(directives, ' '), types && types.length !== 0 ? `= ${join(types, ' | ')}` : ''], ' ')),\n            EnumTypeDefinition: addDescription(({ name, directives, values }) => join(['enum', name, join(directives, ' '), block(values)], ' ')),\n            EnumValueDefinition: addDescription(({ name, directives }) => join([name, join(directives, ' ')], ' ')),\n            InputObjectTypeDefinition: addDescription(({ name, directives, fields }) => join(['input', name, join(directives, ' '), block(fields)], ' ')),\n            ScalarTypeExtension: ({ name, directives }) => join(['extend scalar', name, join(directives, ' ')], ' '),\n            ObjectTypeExtension: ({ name, interfaces, directives, fields }) => join(['extend type', name, wrap('implements ', join(interfaces, ' & ')), join(directives, ' '), block(fields)], ' '),\n            InterfaceTypeExtension: ({ name, directives, fields }) => join(['extend interface', name, join(directives, ' '), block(fields)], ' '),\n            UnionTypeExtension: ({ name, directives, types }) => join(['extend union', name, join(directives, ' '), types && types.length !== 0 ? `= ${join(types, ' | ')}` : ''], ' '),\n            EnumTypeExtension: ({ name, directives, values }) => join(['extend enum', name, join(directives, ' '), block(values)], ' '),\n            InputObjectTypeExtension: ({ name, directives, fields }) => join(['extend input', name, join(directives, ' '), block(fields)], ' '),\n            DirectiveDefinition: addDescription(({ name, arguments: args, locations }) => `directive @${name}${wrap('(', join(args, ', '), ')')} on ${join(locations, ' | ')}`),\n        },\n    });\n}\nfunction isFieldDefinitionNode(node) {\n    return node.kind === 'FieldDefinition';\n}\n\nfunction directiveAlreadyExists(directivesArr, otherDirective) {\n    return !!directivesArr.find(directive => directive.name.value === otherDirective.name.value);\n}\nfunction nameAlreadyExists(name, namesArr) {\n    return namesArr.some(({ value }) => value === name.value);\n}\nfunction mergeArguments$1(a1, a2) {\n    const result = [...a2];\n    for (const argument of a1) {\n        const existingIndex = result.findIndex(a => a.name.value === argument.name.value);\n        if (existingIndex > -1) {\n            const existingArg = result[existingIndex];\n            if (existingArg.value.kind === 'ListValue') {\n                const source = existingArg.value.values;\n                const target = argument.value.values;\n                // merge values of two lists\n                existingArg.value.values = deduplicateLists(source, target, (targetVal, source) => {\n                    const value = targetVal.value;\n                    return !value || !source.some((sourceVal) => sourceVal.value === value);\n                });\n            }\n            else {\n                existingArg.value = argument.value;\n            }\n        }\n        else {\n            result.push(argument);\n        }\n    }\n    return result;\n}\nfunction deduplicateDirectives(directives) {\n    return directives\n        .map((directive, i, all) => {\n        const firstAt = all.findIndex(d => d.name.value === directive.name.value);\n        if (firstAt !== i) {\n            const dup = all[firstAt];\n            directive.arguments = mergeArguments$1(directive.arguments, dup.arguments);\n            return null;\n        }\n        return directive;\n    })\n        .filter(d => d);\n}\nfunction mergeDirectives(d1 = [], d2 = [], config) {\n    const reverseOrder = config && config.reverseDirectives;\n    const asNext = reverseOrder ? d1 : d2;\n    const asFirst = reverseOrder ? d2 : d1;\n    const result = deduplicateDirectives([...asNext]);\n    for (const directive of asFirst) {\n        if (directiveAlreadyExists(result, directive)) {\n            const existingDirectiveIndex = result.findIndex(d => d.name.value === directive.name.value);\n            const existingDirective = result[existingDirectiveIndex];\n            result[existingDirectiveIndex].arguments = mergeArguments$1(directive.arguments || [], existingDirective.arguments || []);\n        }\n        else {\n            result.push(directive);\n        }\n    }\n    return result;\n}\nfunction validateInputs(node, existingNode) {\n    const printedNode = print(node);\n    const printedExistingNode = print(existingNode);\n    const leaveInputs = new RegExp('(directive @w*d*)|( on .*$)', 'g');\n    const sameArguments = printedNode.replace(leaveInputs, '') === printedExistingNode.replace(leaveInputs, '');\n    if (!sameArguments) {\n        throw new Error(`Unable to merge GraphQL directive \"${node.name.value}\". \\nExisting directive:  \\n\\t${printedExistingNode} \\nReceived directive: \\n\\t${printedNode}`);\n    }\n}\nfunction mergeDirective(node, existingNode) {\n    if (existingNode) {\n        validateInputs(node, existingNode);\n        return {\n            ...node,\n            locations: [\n                ...existingNode.locations,\n                ...node.locations.filter(name => !nameAlreadyExists(name, existingNode.locations)),\n            ],\n        };\n    }\n    return node;\n}\nfunction deduplicateLists(source, target, filterFn) {\n    return source.concat(target.filter(val => filterFn(val, source)));\n}\n\nfunction mergeEnumValues(first, second, config) {\n    const enumValueMap = new Map();\n    for (const firstValue of first) {\n        enumValueMap.set(firstValue.name.value, firstValue);\n    }\n    for (const secondValue of second) {\n        const enumValue = secondValue.name.value;\n        if (enumValueMap.has(enumValue)) {\n            const firstValue = enumValueMap.get(enumValue);\n            firstValue.description = secondValue.description || firstValue.description;\n            firstValue.directives = mergeDirectives(secondValue.directives, firstValue.directives);\n        }\n        else {\n            enumValueMap.set(enumValue, secondValue);\n        }\n    }\n    const result = [...enumValueMap.values()];\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\n\nfunction mergeEnum(e1, e2, config) {\n    if (e2) {\n        return {\n            name: e1.name,\n            description: e1['description'] || e2['description'],\n            kind: (config && config.convertExtensions) || e1.kind === 'EnumTypeDefinition' || e2.kind === 'EnumTypeDefinition'\n                ? 'EnumTypeDefinition'\n                : 'EnumTypeExtension',\n            loc: e1.loc,\n            directives: mergeDirectives(e1.directives, e2.directives, config),\n            values: mergeEnumValues(e1.values, e2.values, config),\n        };\n    }\n    return config && config.convertExtensions\n        ? {\n            ...e1,\n            kind: 'EnumTypeDefinition',\n        }\n        : e1;\n}\n\nfunction isStringTypes(types) {\n    return typeof types === 'string';\n}\nfunction isSourceTypes(types) {\n    return types instanceof Source;\n}\nfunction isGraphQLType(definition) {\n    return definition.kind === 'ObjectTypeDefinition';\n}\nfunction isGraphQLTypeExtension(definition) {\n    return definition.kind === 'ObjectTypeExtension';\n}\nfunction isGraphQLEnum(definition) {\n    return definition.kind === 'EnumTypeDefinition';\n}\nfunction isGraphQLEnumExtension(definition) {\n    return definition.kind === 'EnumTypeExtension';\n}\nfunction isGraphQLUnion(definition) {\n    return definition.kind === 'UnionTypeDefinition';\n}\nfunction isGraphQLUnionExtension(definition) {\n    return definition.kind === 'UnionTypeExtension';\n}\nfunction isGraphQLScalar(definition) {\n    return definition.kind === 'ScalarTypeDefinition';\n}\nfunction isGraphQLScalarExtension(definition) {\n    return definition.kind === 'ScalarTypeExtension';\n}\nfunction isGraphQLInputType(definition) {\n    return definition.kind === 'InputObjectTypeDefinition';\n}\nfunction isGraphQLInputTypeExtension(definition) {\n    return definition.kind === 'InputObjectTypeExtension';\n}\nfunction isGraphQLInterface(definition) {\n    return definition.kind === 'InterfaceTypeDefinition';\n}\nfunction isGraphQLInterfaceExtension(definition) {\n    return definition.kind === 'InterfaceTypeExtension';\n}\nfunction isGraphQLDirective(definition) {\n    return definition.kind === 'DirectiveDefinition';\n}\nfunction extractType(type) {\n    let visitedType = type;\n    while (visitedType.kind === 'ListType' || visitedType.kind === 'NonNullType') {\n        visitedType = visitedType.type;\n    }\n    return visitedType;\n}\nfunction isSchemaDefinition(node) {\n    return node.kind === 'SchemaDefinition';\n}\nfunction isWrappingTypeNode(type) {\n    return type.kind !== Kind.NAMED_TYPE;\n}\nfunction isListTypeNode(type) {\n    return type.kind === Kind.LIST_TYPE;\n}\nfunction isNonNullTypeNode(type) {\n    return type.kind === Kind.NON_NULL_TYPE;\n}\nfunction printTypeNode(type) {\n    if (isListTypeNode(type)) {\n        return `[${printTypeNode(type.type)}]`;\n    }\n    if (isNonNullTypeNode(type)) {\n        return `${printTypeNode(type.type)}!`;\n    }\n    return type.name.value;\n}\n\nfunction fieldAlreadyExists(fieldsArr, otherField) {\n    const result = fieldsArr.find(field => field.name.value === otherField.name.value);\n    if (result) {\n        const t1 = extractType(result.type);\n        const t2 = extractType(otherField.type);\n        if (t1.name.value !== t2.name.value) {\n            throw new Error(`Field \"${otherField.name.value}\" already defined with a different type. Declared as \"${t1.name.value}\", but you tried to override with \"${t2.name.value}\"`);\n        }\n    }\n    return !!result;\n}\nfunction mergeFields(type, f1, f2, config) {\n    const result = [...f2];\n    for (const field of f1) {\n        if (fieldAlreadyExists(result, field)) {\n            const existing = result.find((f) => f.name.value === field.name.value);\n            if (config && config.throwOnConflict) {\n                preventConflicts(type, existing, field, false);\n            }\n            else {\n                preventConflicts(type, existing, field, true);\n            }\n            if (isNonNullTypeNode(field.type) && !isNonNullTypeNode(existing.type)) {\n                existing.type = field.type;\n            }\n            existing.arguments = mergeArguments(field['arguments'] || [], existing.arguments || [], config);\n            existing.directives = mergeDirectives(field.directives, existing.directives, config);\n            existing.description = field.description || existing.description;\n        }\n        else {\n            result.push(field);\n        }\n    }\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    if (config && config.exclusions) {\n        return result.filter(field => !config.exclusions.includes(`${type.name.value}.${field.name.value}`));\n    }\n    return result;\n}\nfunction preventConflicts(type, a, b, ignoreNullability = false) {\n    const aType = printTypeNode(a.type);\n    const bType = printTypeNode(b.type);\n    if (isNotEqual(aType, bType)) {\n        if (safeChangeForFieldType(a.type, b.type, ignoreNullability) === false) {\n            throw new Error(`Field '${type.name.value}.${a.name.value}' changed type from '${aType}' to '${bType}'`);\n        }\n    }\n}\nfunction safeChangeForFieldType(oldType, newType, ignoreNullability = false) {\n    // both are named\n    if (!isWrappingTypeNode(oldType) && !isWrappingTypeNode(newType)) {\n        return oldType.toString() === newType.toString();\n    }\n    // new is non-null\n    if (isNonNullTypeNode(newType)) {\n        const ofType = isNonNullTypeNode(oldType) ? oldType.type : oldType;\n        return safeChangeForFieldType(ofType, newType.type);\n    }\n    // old is non-null\n    if (isNonNullTypeNode(oldType)) {\n        return safeChangeForFieldType(newType, oldType, ignoreNullability);\n    }\n    // old is list\n    if (isListTypeNode(oldType)) {\n        return ((isListTypeNode(newType) && safeChangeForFieldType(oldType.type, newType.type)) ||\n            (isNonNullTypeNode(newType) && safeChangeForFieldType(oldType, newType['type'])));\n    }\n    return false;\n}\n\nfunction mergeInputType(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config && config.convertExtensions) ||\n                    node.kind === 'InputObjectTypeDefinition' ||\n                    existingNode.kind === 'InputObjectTypeDefinition'\n                    ? 'InputObjectTypeDefinition'\n                    : 'InputObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL input type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config && config.convertExtensions\n        ? {\n            ...node,\n            kind: 'InputObjectTypeDefinition',\n        }\n        : node;\n}\n\nfunction mergeInterface(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config && config.convertExtensions) ||\n                    node.kind === 'InterfaceTypeDefinition' ||\n                    existingNode.kind === 'InterfaceTypeDefinition'\n                    ? 'InterfaceTypeDefinition'\n                    : 'InterfaceTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL interface \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config && config.convertExtensions\n        ? {\n            ...node,\n            kind: 'InterfaceTypeDefinition',\n        }\n        : node;\n}\n\nfunction alreadyExists(arr, other) {\n    return !!arr.find(i => i.name.value === other.name.value);\n}\nfunction mergeNamedTypeArray(first, second, config) {\n    const result = [...second, ...first.filter(d => !alreadyExists(second, d))];\n    if (config && config.sort) {\n        result.sort(compareNodes);\n    }\n    return result;\n}\n\nfunction mergeType(node, existingNode, config) {\n    if (existingNode) {\n        try {\n            return {\n                name: node.name,\n                description: node['description'] || existingNode['description'],\n                kind: (config && config.convertExtensions) ||\n                    node.kind === 'ObjectTypeDefinition' ||\n                    existingNode.kind === 'ObjectTypeDefinition'\n                    ? 'ObjectTypeDefinition'\n                    : 'ObjectTypeExtension',\n                loc: node.loc,\n                fields: mergeFields(node, node.fields, existingNode.fields, config),\n                directives: mergeDirectives(node.directives, existingNode.directives, config),\n                interfaces: mergeNamedTypeArray(node.interfaces, existingNode.interfaces, config),\n            };\n        }\n        catch (e) {\n            throw new Error(`Unable to merge GraphQL type \"${node.name.value}\": ${e.message}`);\n        }\n    }\n    return config && config.convertExtensions\n        ? {\n            ...node,\n            kind: 'ObjectTypeDefinition',\n        }\n        : node;\n}\n\nfunction mergeUnion(first, second, config) {\n    if (second) {\n        return {\n            name: first.name,\n            description: first['description'] || second['description'],\n            directives: mergeDirectives(first.directives, second.directives, config),\n            kind: (config && config.convertExtensions) ||\n                first.kind === 'UnionTypeDefinition' ||\n                second.kind === 'UnionTypeDefinition'\n                ? 'UnionTypeDefinition'\n                : 'UnionTypeExtension',\n            loc: first.loc,\n            types: mergeNamedTypeArray(first.types, second.types, config),\n        };\n    }\n    return config && config.convertExtensions\n        ? {\n            ...first,\n            kind: 'UnionTypeDefinition',\n        }\n        : first;\n}\n\nfunction mergeGraphQLNodes(nodes, config) {\n    return nodes.reduce((prev, nodeDefinition) => {\n        const node = nodeDefinition;\n        if (node && node.name && node.name.value) {\n            const name = node.name.value;\n            if (config && config.commentDescriptions) {\n                collectComment(node);\n            }\n            if (config &&\n                config.exclusions &&\n                (config.exclusions.includes(name + '.*') || config.exclusions.includes(name))) {\n                delete prev[name];\n            }\n            else if (isGraphQLType(nodeDefinition) || isGraphQLTypeExtension(nodeDefinition)) {\n                prev[name] = mergeType(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLEnum(nodeDefinition) || isGraphQLEnumExtension(nodeDefinition)) {\n                prev[name] = mergeEnum(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLUnion(nodeDefinition) || isGraphQLUnionExtension(nodeDefinition)) {\n                prev[name] = mergeUnion(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLScalar(nodeDefinition) || isGraphQLScalarExtension(nodeDefinition)) {\n                prev[name] = nodeDefinition;\n            }\n            else if (isGraphQLInputType(nodeDefinition) || isGraphQLInputTypeExtension(nodeDefinition)) {\n                prev[name] = mergeInputType(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLInterface(nodeDefinition) || isGraphQLInterfaceExtension(nodeDefinition)) {\n                prev[name] = mergeInterface(nodeDefinition, prev[name], config);\n            }\n            else if (isGraphQLDirective(nodeDefinition)) {\n                prev[name] = mergeDirective(nodeDefinition, prev[name]);\n            }\n        }\n        return prev;\n    }, {});\n}\n\nfunction mergeTypeDefs(types, config) {\n    resetComments();\n    const doc = {\n        kind: Kind.DOCUMENT,\n        definitions: mergeGraphQLTypes(types, {\n            useSchemaDefinition: true,\n            forceSchemaDefinition: false,\n            throwOnConflict: false,\n            commentDescriptions: false,\n            ...config,\n        }),\n    };\n    let result;\n    if (config && config.commentDescriptions) {\n        result = printWithComments(doc);\n    }\n    else {\n        result = doc;\n    }\n    resetComments();\n    return result;\n}\nfunction mergeGraphQLTypes(types, config) {\n    resetComments();\n    const allNodes = types\n        .map(type => {\n        if (Array.isArray(type)) {\n            type = mergeTypeDefs(type);\n        }\n        if (isSchema(type)) {\n            return parse(printSchemaWithDirectives(type));\n        }\n        else if (isStringTypes(type) || isSourceTypes(type)) {\n            return parse(type);\n        }\n        return type;\n    })\n        .map(ast => ast.definitions)\n        .reduce((defs, newDef = []) => [...defs, ...newDef], []);\n    // XXX: right now we don't handle multiple schema definitions\n    let schemaDef = allNodes.filter(isSchemaDefinition).reduce((def, node) => {\n        node.operationTypes\n            .filter(op => op.type.name.value)\n            .forEach(op => {\n            def[op.operation] = op.type.name.value;\n        });\n        return def;\n    }, {\n        query: null,\n        mutation: null,\n        subscription: null,\n    });\n    const mergedNodes = mergeGraphQLNodes(allNodes, config);\n    const allTypes = Object.keys(mergedNodes);\n    if (config && config.sort) {\n        allTypes.sort(typeof config.sort === 'function' ? config.sort : undefined);\n    }\n    if (config && config.useSchemaDefinition) {\n        const queryType = schemaDef.query ? schemaDef.query : allTypes.find(t => t === 'Query');\n        const mutationType = schemaDef.mutation ? schemaDef.mutation : allTypes.find(t => t === 'Mutation');\n        const subscriptionType = schemaDef.subscription ? schemaDef.subscription : allTypes.find(t => t === 'Subscription');\n        schemaDef = {\n            query: queryType,\n            mutation: mutationType,\n            subscription: subscriptionType,\n        };\n    }\n    const schemaDefinition = createSchemaDefinition(schemaDef, {\n        force: config.forceSchemaDefinition,\n    });\n    if (!schemaDefinition) {\n        return Object.values(mergedNodes);\n    }\n    return [...Object.values(mergedNodes), parse(schemaDefinition).definitions[0]];\n}\n\nfunction travelSchemaPossibleExtensions(schema, hooks) {\n    hooks.onSchema(schema);\n    const typesMap = schema.getTypeMap();\n    for (const [, type] of Object.entries(typesMap)) {\n        const isPredefinedScalar = isScalarType(type) && isSpecifiedScalarType(type);\n        const isIntrospection = isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        if (isObjectType(type)) {\n            hooks.onObjectType(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onObjectField(type, field);\n                const args = field.args || [];\n                for (const arg of args) {\n                    hooks.onObjectFieldArg(type, field, arg);\n                }\n            }\n        }\n        else if (isInterfaceType(type)) {\n            hooks.onInterface(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onInterfaceField(type, field);\n                const args = field.args || [];\n                for (const arg of args) {\n                    hooks.onInterfaceFieldArg(type, field, arg);\n                }\n            }\n        }\n        else if (isInputObjectType(type)) {\n            hooks.onInputType(type);\n            const fields = type.getFields();\n            for (const [, field] of Object.entries(fields)) {\n                hooks.onInputFieldType(type, field);\n            }\n        }\n        else if (isUnionType(type)) {\n            hooks.onUnion(type);\n        }\n        else if (isScalarType(type)) {\n            hooks.onScalar(type);\n        }\n        else if (isEnumType(type)) {\n            hooks.onEnum(type);\n            for (const value of type.getValues()) {\n                hooks.onEnumValue(type, value);\n            }\n        }\n    }\n}\nfunction mergeExtensions(extensions) {\n    return extensions.reduce((result, extensionObj) => [result, extensionObj].reduce(mergeDeep, {}), {});\n}\nfunction applyExtensionObject(obj, extensions) {\n    if (!obj) {\n        return;\n    }\n    obj.extensions = [obj.extensions || {}, extensions || {}].reduce(mergeDeep, {});\n}\nfunction applyExtensions(schema, extensions) {\n    applyExtensionObject(schema, extensions.schemaExtensions);\n    for (const [typeName, data] of Object.entries(extensions.types || {})) {\n        const type = schema.getType(typeName);\n        if (type) {\n            applyExtensionObject(type, data.extensions);\n            if (data.type === 'object' || data.type === 'interface') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    if (field) {\n                        applyExtensionObject(field, fieldData.extensions);\n                        for (const [arg, argData] of Object.entries(fieldData.arguments)) {\n                            applyExtensionObject(field.args.find(a => a.name === arg), argData);\n                        }\n                    }\n                }\n            }\n            else if (data.type === 'input') {\n                for (const [fieldName, fieldData] of Object.entries(data.fields)) {\n                    const field = type.getFields()[fieldName];\n                    applyExtensionObject(field, fieldData.extensions);\n                }\n            }\n            else if (data.type === 'enum') {\n                for (const [valueName, valueData] of Object.entries(data.values)) {\n                    const value = type.getValue(valueName);\n                    applyExtensionObject(value, valueData);\n                }\n            }\n        }\n    }\n    return schema;\n}\nfunction extractExtensionsFromSchema(schema) {\n    const result = {\n        schemaExtensions: {},\n        types: {},\n    };\n    travelSchemaPossibleExtensions(schema, {\n        onSchema: schema => (result.schemaExtensions = schema.extensions || {}),\n        onObjectType: type => (result.types[type.name] = { fields: {}, type: 'object', extensions: type.extensions || {} }),\n        onObjectField: (type, field) => (result.types[type.name].fields[field.name] = {\n            arguments: {},\n            extensions: field.extensions || {},\n        }),\n        onObjectFieldArg: (type, field, arg) => (result.types[type.name].fields[field.name].arguments[arg.name] = arg.extensions || {}),\n        onInterface: type => (result.types[type.name] = { fields: {}, type: 'interface', extensions: type.extensions || {} }),\n        onInterfaceField: (type, field) => (result.types[type.name].fields[field.name] = {\n            arguments: {},\n            extensions: field.extensions || {},\n        }),\n        onInterfaceFieldArg: (type, field, arg) => (result.types[type.name].fields[field.name].arguments[arg.name] =\n            arg.extensions || {}),\n        onEnum: type => (result.types[type.name] = { values: {}, type: 'enum', extensions: type.extensions || {} }),\n        onEnumValue: (type, value) => (result.types[type.name].values[value.name] = value.extensions || {}),\n        onScalar: type => (result.types[type.name] = { type: 'scalar', extensions: type.extensions || {} }),\n        onUnion: type => (result.types[type.name] = { type: 'union', extensions: type.extensions || {} }),\n        onInputType: type => (result.types[type.name] = { fields: {}, type: 'input', extensions: type.extensions || {} }),\n        onInputFieldType: (type, field) => (result.types[type.name].fields[field.name] = { extensions: field.extensions || {} }),\n    });\n    return result;\n}\n\nconst defaultResolverValidationOptions = {\n    requireResolversForArgs: false,\n    requireResolversForNonScalar: false,\n    requireResolversForAllFields: false,\n    requireResolversForResolveType: false,\n    allowResolversNotInSchema: true,\n};\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\nfunction mergeSchemas(config) {\n    const typeDefs = mergeTypes(config);\n    const extractedResolvers = [];\n    const extractedExtensions = [];\n    for (const schema of config.schemas) {\n        extractedResolvers.push(getResolversFromSchema(schema));\n        extractedExtensions.push(extractExtensionsFromSchema(schema));\n    }\n    extractedResolvers.push(...ensureResolvers(config));\n    const resolvers = mergeResolvers(extractedResolvers, config);\n    const extensions = mergeExtensions(extractedExtensions);\n    return makeSchema({ resolvers, typeDefs, extensions }, config);\n}\n/**\n * Synchronously merges multiple schemas, typeDefinitions and/or resolvers into a single schema.\n * @param config Configuration object\n */\nasync function mergeSchemasAsync(config) {\n    const [typeDefs, resolvers, extensions] = await Promise.all([\n        mergeTypes(config),\n        Promise.all(config.schemas.map(async (schema) => getResolversFromSchema(schema))).then(extractedResolvers => mergeResolvers([...extractedResolvers, ...ensureResolvers(config)], config)),\n        Promise.all(config.schemas.map(async (schema) => extractExtensionsFromSchema(schema))).then(extractedExtensions => mergeExtensions(extractedExtensions)),\n    ]);\n    return makeSchema({ resolvers, typeDefs, extensions }, config);\n}\nfunction mergeTypes({ schemas, typeDefs, ...config }) {\n    return mergeTypeDefs([...schemas, ...(typeDefs ? asArray(typeDefs) : [])], config);\n}\nfunction ensureResolvers(config) {\n    return config.resolvers ? asArray(config.resolvers) : [];\n}\nfunction makeSchema({ resolvers, typeDefs, extensions, }, config) {\n    let schema = typeof typeDefs === 'string' ? buildSchema(typeDefs, config) : buildASTSchema(typeDefs, config);\n    // add resolvers\n    if (resolvers) {\n        schema = addResolversToSchema({\n            schema,\n            resolvers,\n            resolverValidationOptions: {\n                ...defaultResolverValidationOptions,\n                ...(config.resolverValidationOptions || {}),\n            },\n        });\n    }\n    // use logger\n    if (config.logger) {\n        schema = addErrorLoggingToSchema(schema, config.logger);\n    }\n    // use schema directives\n    if (config.schemaDirectives) {\n        SchemaDirectiveVisitor.visitSchemaDirectives(schema, config.schemaDirectives);\n    }\n    // extensions\n    applyExtensions(schema, extensions);\n    return schema;\n}\n\nexport { applyExtensions, collectComment, extractExtensionsFromSchema, extractType, isGraphQLDirective, isGraphQLEnum, isGraphQLEnumExtension, isGraphQLInputType, isGraphQLInputTypeExtension, isGraphQLInterface, isGraphQLInterfaceExtension, isGraphQLScalar, isGraphQLScalarExtension, isGraphQLType, isGraphQLTypeExtension, isGraphQLUnion, isGraphQLUnionExtension, isListTypeNode, isNonNullTypeNode, isSchemaDefinition, isSourceTypes, isStringTypes, isWrappingTypeNode, mergeArguments, mergeDirective, mergeDirectives, mergeEnum, mergeEnumValues, mergeExtensions, mergeFields, mergeGraphQLNodes, mergeGraphQLTypes, mergeInputType, mergeInterface, mergeNamedTypeArray, mergeResolvers, mergeSchemas, mergeSchemasAsync, mergeType, mergeTypeDefs, mergeUnion, printComment, printTypeNode, printWithComments, pushComment, resetComments, travelSchemaPossibleExtensions };\n//# sourceMappingURL=index.esm.js.map\n","import { isValidPath, parseGraphQLSDL, } from '@graphql-tools/utils';\nimport { isAbsolute, resolve } from 'path';\nimport { readFile, readFileSync, pathExists, pathExistsSync } from 'fs-extra';\nimport { cwd as processCwd } from 'process';\nimport { isExecutableDefinitionNode, Kind } from 'graphql';\nimport { processImport } from '@graphql-tools/import';\nimport { mergeTypeDefs } from '@graphql-tools/merge';\nconst FILE_EXTENSIONS = ['.gql', '.gqls', '.graphql', '.graphqls'];\nfunction isGraphQLImportFile(rawSDL) {\n    const trimmedRawSDL = rawSDL.trim();\n    return trimmedRawSDL.startsWith('# import') || trimmedRawSDL.startsWith('#import');\n}\n/**\n * This loader loads documents and type definitions from `.graphql` files.\n *\n * You can load a single source:\n *\n * ```js\n * const schema = await loadSchema('schema.graphql', {\n *   loaders: [\n *     new GraphQLFileLoader()\n *   ]\n * });\n * ```\n *\n * Or provide a glob pattern to load multiple sources:\n *\n * ```js\n * const schema = await loadSchema('graphql/*.graphql', {\n *   loaders: [\n *     new GraphQLFileLoader()\n *   ]\n * });\n * ```\n */\nexport class GraphQLFileLoader {\n    loaderId() {\n        return 'graphql-file';\n    }\n    async canLoad(pointer, options) {\n        if (isValidPath(pointer)) {\n            if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {\n                const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || processCwd(), pointer);\n                return pathExists(normalizedFilePath);\n            }\n        }\n        return false;\n    }\n    canLoadSync(pointer, options) {\n        if (isValidPath(pointer)) {\n            if (FILE_EXTENSIONS.find(extension => pointer.endsWith(extension))) {\n                const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || processCwd(), pointer);\n                return pathExistsSync(normalizedFilePath);\n            }\n        }\n        return false;\n    }\n    async load(pointer, options) {\n        const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || processCwd(), pointer);\n        const rawSDL = await readFile(normalizedFilePath, { encoding: 'utf8' });\n        return this.handleFileContent(rawSDL, pointer, options);\n    }\n    loadSync(pointer, options) {\n        const normalizedFilePath = isAbsolute(pointer) ? pointer : resolve(options.cwd || processCwd(), pointer);\n        const rawSDL = readFileSync(normalizedFilePath, { encoding: 'utf8' });\n        return this.handleFileContent(rawSDL, pointer, options);\n    }\n    handleFileContent(rawSDL, pointer, options) {\n        if (!options.skipGraphQLImport && isGraphQLImportFile(rawSDL)) {\n            const document = processImport(pointer, options.cwd);\n            const typeSystemDefinitions = document.definitions\n                .filter(d => !isExecutableDefinitionNode(d))\n                .map(definition => ({\n                kind: Kind.DOCUMENT,\n                definitions: [definition],\n            }));\n            const mergedTypeDefs = mergeTypeDefs(typeSystemDefinitions, { useSchemaDefinition: false });\n            const executableDefinitions = document.definitions.filter(isExecutableDefinitionNode);\n            return {\n                location: pointer,\n                document: {\n                    ...mergedTypeDefs,\n                    definitions: [...mergedTypeDefs.definitions, ...executableDefinitions],\n                },\n            };\n        }\n        return parseGraphQLSDL(pointer, rawSDL, options);\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}