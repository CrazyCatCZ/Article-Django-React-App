{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar IRTransformer = require('../core/IRTransformer');\n\nvar RelayCompilerScope = require('../core/RelayCompilerScope');\n\nvar getIdentifierForArgumentValue = require('../core/getIdentifierForArgumentValue');\n\nvar murmurHash = require('../util/murmurHash');\n\nvar _require = require('../core/CompilerError'),\n    createCompilerError = _require.createCompilerError,\n    createNonRecoverableUserError = _require.createNonRecoverableUserError;\n\nvar getFragmentScope = RelayCompilerScope.getFragmentScope,\n    getRootScope = RelayCompilerScope.getRootScope;\n/**\n * A transform that converts a set of documents containing fragments/fragment\n * spreads *with* arguments to one where all arguments have been inlined. This\n * is effectively static currying of functions. Nodes are changed as follows:\n * - Fragment spreads with arguments are replaced with references to an inlined\n *   version of the referenced fragment.\n * - Fragments with argument definitions are cloned once per unique set of\n *   arguments, with the name changed to original name + hash and all nested\n *   variable references changed to the value of that variable given its\n *   arguments.\n * - Field & directive argument variables are replaced with the value of those\n *   variables in context.\n * - All nodes are cloned with updated children.\n *\n * The transform also handles statically passing/failing Condition nodes:\n * - Literal Conditions with a passing value are elided and their selections\n *   inlined in their parent.\n * - Literal Conditions with a failing value are removed.\n * - Nodes that would become empty as a result of the above are removed.\n *\n * Note that unreferenced fragments are not added to the output.\n */\n\nfunction applyFragmentArgumentTransform(context) {\n  var fragments = new Map();\n  var nextContext = IRTransformer.transform(context, {\n    Root: function Root(node) {\n      var scope = getRootScope(node.argumentDefinitions);\n      return transformNode(context, fragments, scope, node, [node]);\n    },\n    SplitOperation: function SplitOperation(node) {\n      return transformNode(context, fragments, {}, node, [node]);\n    },\n    // Fragments are included below where referenced.\n    // Unreferenced fragments are not included.\n    Fragment: function Fragment() {\n      return null;\n    }\n  });\n\n  var _iterator = _createForOfIteratorHelper(fragments.values()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var pendingFragment = _step.value;\n\n      if (pendingFragment.kind === 'resolved' && pendingFragment.value) {\n        nextContext = nextContext.add(pendingFragment.value);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return nextContext;\n}\n\nfunction transformNode(context, fragments, scope, node, errorContext) {\n  var selections = transformSelections(context, fragments, scope, node.selections, errorContext);\n\n  if (!selections) {\n    return null;\n  }\n\n  if (node.hasOwnProperty('directives')) {\n    var directives = transformDirectives(scope, node.directives, errorContext);\n    return _objectSpread({}, node, {\n      directives: directives,\n      selections: selections\n    });\n  }\n\n  return _objectSpread({}, node, {\n    selections: selections\n  });\n}\n\nfunction transformDeferStreamNode(context, fragments, scope, node, errorContext) {\n  var nextNode = transformNode(context, fragments, scope, node, errorContext);\n\n  if (!nextNode) {\n    return null;\n  }\n\n  nextNode;\n\n  if (nextNode[\"if\"]) {\n    var ifVal = transformValue(scope, nextNode[\"if\"], errorContext);\n\n    if (ifVal.kind === 'Literal' && ifVal.value === false && node.selections && node.selections.length === 1) {\n      // Skip Defer/Stream wrapper with literal if: false\n      return node.selections[0];\n    } // $FlowFixMe[cannot-write] nextNode is uniquely owned\n\n\n    nextNode[\"if\"] = ifVal;\n  }\n\n  if (nextNode.useCustomizedBatch) {\n    // $FlowFixMe[cannot-write] nextNode is uniquely owned\n    nextNode.useCustomizedBatch = transformValue(scope, nextNode.useCustomizedBatch, errorContext);\n  }\n\n  if (nextNode.initialCount) {\n    // $FlowFixMe[cannot-write] nextNode is uniquely owned\n    nextNode.initialCount = transformValue(scope, nextNode.initialCount, errorContext);\n  }\n\n  return nextNode;\n}\n\nfunction transformFragmentSpread(context, fragments, scope, spread, errorContext) {\n  var directives = transformDirectives(scope, spread.directives, errorContext);\n  var appliedFragment = transformFragment(context, fragments, scope, spread, spread.args, [].concat((0, _toConsumableArray2[\"default\"])(errorContext), [spread]));\n\n  if (!appliedFragment) {\n    return null;\n  }\n\n  var transformed = _objectSpread({}, spread, {\n    kind: 'FragmentSpread',\n    args: [],\n    directives: directives,\n    name: appliedFragment.name\n  });\n\n  return transformed;\n}\n\nfunction transformField(context, fragments, scope, field, errorContext) {\n  var args = transformArguments(scope, field.args, errorContext);\n  var directives = transformDirectives(scope, field.directives, errorContext);\n\n  if (field.kind === 'LinkedField') {\n    var selections = transformSelections(context, fragments, scope, field.selections, errorContext);\n\n    if (!selections) {\n      return null;\n    }\n\n    return _objectSpread({}, field, {\n      args: args,\n      directives: directives,\n      selections: selections\n    });\n  } else {\n    return _objectSpread({}, field, {\n      args: args,\n      directives: directives\n    });\n  }\n}\n\nfunction transformCondition(context, fragments, scope, node, errorContext) {\n  var condition = transformValue(scope, node.condition, errorContext);\n\n  if (!(condition.kind === 'Literal' || condition.kind === 'Variable')) {\n    // This transform does whole-program optimization, errors in\n    // a single document could break invariants and/or cause\n    // additional spurious errors.\n    throw createNonRecoverableUserError('A non-scalar value was applied to an @include or @skip directive, ' + 'the `if` argument value must be a ' + 'variable or a literal Boolean.', [condition.loc]);\n  }\n\n  if (condition.kind === 'Literal' && condition.value !== node.passingValue) {\n    // Dead code, no need to traverse further.\n    return null;\n  }\n\n  var selections = transformSelections(context, fragments, scope, node.selections, errorContext);\n\n  if (!selections) {\n    return null;\n  }\n\n  if (condition.kind === 'Literal' && condition.value === node.passingValue) {\n    // Always passes, return inlined selections\n    return selections;\n  }\n\n  return [_objectSpread({}, node, {\n    condition: condition,\n    selections: selections\n  })];\n}\n\nfunction transformSelections(context, fragments, scope, selections, errorContext) {\n  var nextSelections = null;\n  selections.forEach(function (selection) {\n    var nextSelection;\n\n    if (selection.kind === 'ClientExtension' || selection.kind === 'InlineDataFragmentSpread' || selection.kind === 'InlineFragment' || selection.kind === 'ModuleImport') {\n      nextSelection = transformNode(context, fragments, scope, selection, errorContext);\n    } else if (selection.kind === 'Defer' || selection.kind === 'Stream') {\n      nextSelection = transformDeferStreamNode(context, fragments, scope, selection, errorContext);\n    } else if (selection.kind === 'FragmentSpread') {\n      nextSelection = transformFragmentSpread(context, fragments, scope, selection, errorContext);\n    } else if (selection.kind === 'Condition') {\n      var conditionSelections = transformCondition(context, fragments, scope, selection, errorContext);\n\n      if (conditionSelections) {\n        var _nextSelections;\n\n        nextSelections = nextSelections || [];\n\n        (_nextSelections = nextSelections).push.apply(_nextSelections, (0, _toConsumableArray2[\"default\"])(conditionSelections));\n      }\n    } else if (selection.kind === 'LinkedField' || selection.kind === 'ScalarField') {\n      nextSelection = transformField(context, fragments, scope, selection, errorContext);\n    } else {\n      selection;\n      throw createCompilerError(\"ApplyFragmentArgumentTransform: Unsupported kind '\".concat(selection.kind, \"'.\"), [selection.loc]);\n    }\n\n    if (nextSelection) {\n      nextSelections = nextSelections || [];\n      nextSelections.push(nextSelection);\n    }\n  });\n  return nextSelections;\n}\n\nfunction transformDirectives(scope, directives, errorContext) {\n  return directives.map(function (directive) {\n    var args = transformArguments(scope, directive.args, errorContext);\n    return _objectSpread({}, directive, {\n      args: args\n    });\n  });\n}\n\nfunction transformArguments(scope, args, errorContext) {\n  return args.map(function (arg) {\n    var value = transformValue(scope, arg.value, errorContext);\n    return value === arg.value ? arg : _objectSpread({}, arg, {\n      value: value\n    });\n  });\n}\n\nfunction transformValue(scope, value, errorContext) {\n  if (value.kind === 'Variable') {\n    var scopeValue = scope[value.variableName];\n\n    if (scopeValue == null) {\n      var _errorContext$; // This transform does whole-program optimization, errors in\n      // a single document could break invariants and/or cause\n      // additional spurious errors.\n\n\n      throw createNonRecoverableUserError(\"Variable '$\".concat(value.variableName, \"' is not in scope.\"), [(_errorContext$ = errorContext[0]) === null || _errorContext$ === void 0 ? void 0 : _errorContext$.loc, value.loc].filter(Boolean));\n    }\n\n    return scopeValue;\n  } else if (value.kind === 'ObjectValue') {\n    return _objectSpread({}, value, {\n      fields: value.fields.map(function (field) {\n        return _objectSpread({}, field, {\n          value: transformValue(scope, field.value, errorContext)\n        });\n      })\n    });\n  } else if (value.kind === 'ListValue') {\n    return _objectSpread({}, value, {\n      items: value.items.map(function (item) {\n        return transformValue(scope, item, errorContext);\n      })\n    });\n  }\n\n  return value;\n}\n/**\n * Apply arguments to a fragment, creating a new fragment (with the given name)\n * with all values recursively applied.\n */\n\n\nfunction transformFragment(context, fragments, parentScope, spread, args, errorContext) {\n  var schema = context.getSchema();\n  var fragment = context.getFragment(spread.name, spread.loc);\n  var argumentsHash = hashArguments(args, parentScope, errorContext);\n  var fragmentName = argumentsHash ? \"\".concat(fragment.name, \"_\").concat(argumentsHash) : fragment.name;\n  var appliedFragment = fragments.get(fragmentName);\n\n  if (appliedFragment) {\n    if (appliedFragment.kind === 'resolved') {\n      return appliedFragment.value;\n    } else {\n      // This transform does whole-program optimization, errors in\n      // a single document could break invariants and/or cause\n      // additional spurious errors.\n      throw createNonRecoverableUserError(\"Found a circular reference from fragment '\".concat(fragment.name, \"'.\"), errorContext.map(function (node) {\n        return node.loc;\n      }));\n    }\n  }\n\n  var fragmentScope = getFragmentScope(schema, fragment.argumentDefinitions, args, parentScope, spread); // record that this fragment is pending to detect circular references\n\n  fragments.set(fragmentName, {\n    kind: 'pending'\n  });\n  var transformedFragment = null;\n  var selections = transformSelections(context, fragments, fragmentScope, fragment.selections, errorContext);\n\n  if (selections) {\n    transformedFragment = _objectSpread({}, fragment, {\n      selections: selections,\n      name: fragmentName,\n      argumentDefinitions: []\n    });\n  }\n\n  fragments.set(fragmentName, {\n    kind: 'resolved',\n    value: transformedFragment\n  });\n  return transformedFragment;\n}\n\nfunction hashArguments(args, scope, errorContext) {\n  if (!args.length) {\n    return null;\n  }\n\n  var sortedArgs = (0, _toConsumableArray2[\"default\"])(args).sort(function (a, b) {\n    return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;\n  });\n  var printedArgs = JSON.stringify(sortedArgs.map(function (arg) {\n    var value;\n\n    if (arg.value.kind === 'Variable') {\n      value = scope[arg.value.variableName];\n\n      if (value == null) {\n        var _errorContext$2; // This transform does whole-program optimization, errors in\n        // a single document could break invariants and/or cause\n        // additional spurious errors.\n\n\n        throw createNonRecoverableUserError(\"Variable '$\".concat(arg.value.variableName, \"' is not in scope.\"), [(_errorContext$2 = errorContext[0]) === null || _errorContext$2 === void 0 ? void 0 : _errorContext$2.loc, arg.value.loc].filter(Boolean));\n      }\n    } else {\n      value = arg.value;\n    }\n\n    return {\n      name: arg.name,\n      value: getIdentifierForArgumentValue(value)\n    };\n  }));\n  return murmurHash(printedArgs);\n}\n\nmodule.exports = {\n  transform: applyFragmentArgumentTransform\n};","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/relay-compiler/lib/transforms/ApplyFragmentArgumentTransform.js"],"names":["_interopRequireDefault","require","_defineProperty2","_toConsumableArray2","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","_createForOfIteratorHelper","o","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","F","s","n","done","value","e","_e","f","TypeError","it","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","IRTransformer","RelayCompilerScope","getIdentifierForArgumentValue","murmurHash","_require","createCompilerError","createNonRecoverableUserError","getFragmentScope","getRootScope","applyFragmentArgumentTransform","context","fragments","Map","nextContext","transform","Root","node","scope","argumentDefinitions","transformNode","SplitOperation","Fragment","_iterator","values","_step","pendingFragment","kind","add","errorContext","selections","transformSelections","hasOwnProperty","directives","transformDirectives","transformDeferStreamNode","nextNode","ifVal","transformValue","useCustomizedBatch","initialCount","transformFragmentSpread","spread","appliedFragment","transformFragment","args","concat","transformed","transformField","field","transformArguments","transformCondition","condition","loc","passingValue","nextSelections","selection","nextSelection","conditionSelections","_nextSelections","map","directive","arg","scopeValue","variableName","_errorContext$","Boolean","fields","items","item","parentScope","schema","getSchema","fragment","getFragment","argumentsHash","hashArguments","fragmentName","get","fragmentScope","set","transformedFragment","sortedArgs","sort","a","b","printedArgs","JSON","stringify","_errorContext$2","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar IRTransformer = require('../core/IRTransformer');\n\nvar RelayCompilerScope = require('../core/RelayCompilerScope');\n\nvar getIdentifierForArgumentValue = require('../core/getIdentifierForArgumentValue');\n\nvar murmurHash = require('../util/murmurHash');\n\nvar _require = require('../core/CompilerError'),\n    createCompilerError = _require.createCompilerError,\n    createNonRecoverableUserError = _require.createNonRecoverableUserError;\n\nvar getFragmentScope = RelayCompilerScope.getFragmentScope,\n    getRootScope = RelayCompilerScope.getRootScope;\n\n/**\n * A transform that converts a set of documents containing fragments/fragment\n * spreads *with* arguments to one where all arguments have been inlined. This\n * is effectively static currying of functions. Nodes are changed as follows:\n * - Fragment spreads with arguments are replaced with references to an inlined\n *   version of the referenced fragment.\n * - Fragments with argument definitions are cloned once per unique set of\n *   arguments, with the name changed to original name + hash and all nested\n *   variable references changed to the value of that variable given its\n *   arguments.\n * - Field & directive argument variables are replaced with the value of those\n *   variables in context.\n * - All nodes are cloned with updated children.\n *\n * The transform also handles statically passing/failing Condition nodes:\n * - Literal Conditions with a passing value are elided and their selections\n *   inlined in their parent.\n * - Literal Conditions with a failing value are removed.\n * - Nodes that would become empty as a result of the above are removed.\n *\n * Note that unreferenced fragments are not added to the output.\n */\nfunction applyFragmentArgumentTransform(context) {\n  var fragments = new Map();\n  var nextContext = IRTransformer.transform(context, {\n    Root: function Root(node) {\n      var scope = getRootScope(node.argumentDefinitions);\n      return transformNode(context, fragments, scope, node, [node]);\n    },\n    SplitOperation: function SplitOperation(node) {\n      return transformNode(context, fragments, {}, node, [node]);\n    },\n    // Fragments are included below where referenced.\n    // Unreferenced fragments are not included.\n    Fragment: function Fragment() {\n      return null;\n    }\n  });\n\n  var _iterator = _createForOfIteratorHelper(fragments.values()),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var pendingFragment = _step.value;\n\n      if (pendingFragment.kind === 'resolved' && pendingFragment.value) {\n        nextContext = nextContext.add(pendingFragment.value);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return nextContext;\n}\n\nfunction transformNode(context, fragments, scope, node, errorContext) {\n  var selections = transformSelections(context, fragments, scope, node.selections, errorContext);\n\n  if (!selections) {\n    return null;\n  }\n\n  if (node.hasOwnProperty('directives')) {\n    var directives = transformDirectives(scope, node.directives, errorContext);\n    return _objectSpread({}, node, {\n      directives: directives,\n      selections: selections\n    });\n  }\n\n  return _objectSpread({}, node, {\n    selections: selections\n  });\n}\n\nfunction transformDeferStreamNode(context, fragments, scope, node, errorContext) {\n  var nextNode = transformNode(context, fragments, scope, node, errorContext);\n\n  if (!nextNode) {\n    return null;\n  }\n\n  nextNode;\n\n  if (nextNode[\"if\"]) {\n    var ifVal = transformValue(scope, nextNode[\"if\"], errorContext);\n\n    if (ifVal.kind === 'Literal' && ifVal.value === false && node.selections && node.selections.length === 1) {\n      // Skip Defer/Stream wrapper with literal if: false\n      return node.selections[0];\n    } // $FlowFixMe[cannot-write] nextNode is uniquely owned\n\n\n    nextNode[\"if\"] = ifVal;\n  }\n\n  if (nextNode.useCustomizedBatch) {\n    // $FlowFixMe[cannot-write] nextNode is uniquely owned\n    nextNode.useCustomizedBatch = transformValue(scope, nextNode.useCustomizedBatch, errorContext);\n  }\n\n  if (nextNode.initialCount) {\n    // $FlowFixMe[cannot-write] nextNode is uniquely owned\n    nextNode.initialCount = transformValue(scope, nextNode.initialCount, errorContext);\n  }\n\n  return nextNode;\n}\n\nfunction transformFragmentSpread(context, fragments, scope, spread, errorContext) {\n  var directives = transformDirectives(scope, spread.directives, errorContext);\n  var appliedFragment = transformFragment(context, fragments, scope, spread, spread.args, [].concat((0, _toConsumableArray2[\"default\"])(errorContext), [spread]));\n\n  if (!appliedFragment) {\n    return null;\n  }\n\n  var transformed = _objectSpread({}, spread, {\n    kind: 'FragmentSpread',\n    args: [],\n    directives: directives,\n    name: appliedFragment.name\n  });\n\n  return transformed;\n}\n\nfunction transformField(context, fragments, scope, field, errorContext) {\n  var args = transformArguments(scope, field.args, errorContext);\n  var directives = transformDirectives(scope, field.directives, errorContext);\n\n  if (field.kind === 'LinkedField') {\n    var selections = transformSelections(context, fragments, scope, field.selections, errorContext);\n\n    if (!selections) {\n      return null;\n    }\n\n    return _objectSpread({}, field, {\n      args: args,\n      directives: directives,\n      selections: selections\n    });\n  } else {\n    return _objectSpread({}, field, {\n      args: args,\n      directives: directives\n    });\n  }\n}\n\nfunction transformCondition(context, fragments, scope, node, errorContext) {\n  var condition = transformValue(scope, node.condition, errorContext);\n\n  if (!(condition.kind === 'Literal' || condition.kind === 'Variable')) {\n    // This transform does whole-program optimization, errors in\n    // a single document could break invariants and/or cause\n    // additional spurious errors.\n    throw createNonRecoverableUserError('A non-scalar value was applied to an @include or @skip directive, ' + 'the `if` argument value must be a ' + 'variable or a literal Boolean.', [condition.loc]);\n  }\n\n  if (condition.kind === 'Literal' && condition.value !== node.passingValue) {\n    // Dead code, no need to traverse further.\n    return null;\n  }\n\n  var selections = transformSelections(context, fragments, scope, node.selections, errorContext);\n\n  if (!selections) {\n    return null;\n  }\n\n  if (condition.kind === 'Literal' && condition.value === node.passingValue) {\n    // Always passes, return inlined selections\n    return selections;\n  }\n\n  return [_objectSpread({}, node, {\n    condition: condition,\n    selections: selections\n  })];\n}\n\nfunction transformSelections(context, fragments, scope, selections, errorContext) {\n  var nextSelections = null;\n  selections.forEach(function (selection) {\n    var nextSelection;\n\n    if (selection.kind === 'ClientExtension' || selection.kind === 'InlineDataFragmentSpread' || selection.kind === 'InlineFragment' || selection.kind === 'ModuleImport') {\n      nextSelection = transformNode(context, fragments, scope, selection, errorContext);\n    } else if (selection.kind === 'Defer' || selection.kind === 'Stream') {\n      nextSelection = transformDeferStreamNode(context, fragments, scope, selection, errorContext);\n    } else if (selection.kind === 'FragmentSpread') {\n      nextSelection = transformFragmentSpread(context, fragments, scope, selection, errorContext);\n    } else if (selection.kind === 'Condition') {\n      var conditionSelections = transformCondition(context, fragments, scope, selection, errorContext);\n\n      if (conditionSelections) {\n        var _nextSelections;\n\n        nextSelections = nextSelections || [];\n\n        (_nextSelections = nextSelections).push.apply(_nextSelections, (0, _toConsumableArray2[\"default\"])(conditionSelections));\n      }\n    } else if (selection.kind === 'LinkedField' || selection.kind === 'ScalarField') {\n      nextSelection = transformField(context, fragments, scope, selection, errorContext);\n    } else {\n      selection;\n      throw createCompilerError(\"ApplyFragmentArgumentTransform: Unsupported kind '\".concat(selection.kind, \"'.\"), [selection.loc]);\n    }\n\n    if (nextSelection) {\n      nextSelections = nextSelections || [];\n      nextSelections.push(nextSelection);\n    }\n  });\n  return nextSelections;\n}\n\nfunction transformDirectives(scope, directives, errorContext) {\n  return directives.map(function (directive) {\n    var args = transformArguments(scope, directive.args, errorContext);\n    return _objectSpread({}, directive, {\n      args: args\n    });\n  });\n}\n\nfunction transformArguments(scope, args, errorContext) {\n  return args.map(function (arg) {\n    var value = transformValue(scope, arg.value, errorContext);\n    return value === arg.value ? arg : _objectSpread({}, arg, {\n      value: value\n    });\n  });\n}\n\nfunction transformValue(scope, value, errorContext) {\n  if (value.kind === 'Variable') {\n    var scopeValue = scope[value.variableName];\n\n    if (scopeValue == null) {\n      var _errorContext$;\n\n      // This transform does whole-program optimization, errors in\n      // a single document could break invariants and/or cause\n      // additional spurious errors.\n      throw createNonRecoverableUserError(\"Variable '$\".concat(value.variableName, \"' is not in scope.\"), [(_errorContext$ = errorContext[0]) === null || _errorContext$ === void 0 ? void 0 : _errorContext$.loc, value.loc].filter(Boolean));\n    }\n\n    return scopeValue;\n  } else if (value.kind === 'ObjectValue') {\n    return _objectSpread({}, value, {\n      fields: value.fields.map(function (field) {\n        return _objectSpread({}, field, {\n          value: transformValue(scope, field.value, errorContext)\n        });\n      })\n    });\n  } else if (value.kind === 'ListValue') {\n    return _objectSpread({}, value, {\n      items: value.items.map(function (item) {\n        return transformValue(scope, item, errorContext);\n      })\n    });\n  }\n\n  return value;\n}\n/**\n * Apply arguments to a fragment, creating a new fragment (with the given name)\n * with all values recursively applied.\n */\n\n\nfunction transformFragment(context, fragments, parentScope, spread, args, errorContext) {\n  var schema = context.getSchema();\n  var fragment = context.getFragment(spread.name, spread.loc);\n  var argumentsHash = hashArguments(args, parentScope, errorContext);\n  var fragmentName = argumentsHash ? \"\".concat(fragment.name, \"_\").concat(argumentsHash) : fragment.name;\n  var appliedFragment = fragments.get(fragmentName);\n\n  if (appliedFragment) {\n    if (appliedFragment.kind === 'resolved') {\n      return appliedFragment.value;\n    } else {\n      // This transform does whole-program optimization, errors in\n      // a single document could break invariants and/or cause\n      // additional spurious errors.\n      throw createNonRecoverableUserError(\"Found a circular reference from fragment '\".concat(fragment.name, \"'.\"), errorContext.map(function (node) {\n        return node.loc;\n      }));\n    }\n  }\n\n  var fragmentScope = getFragmentScope(schema, fragment.argumentDefinitions, args, parentScope, spread); // record that this fragment is pending to detect circular references\n\n  fragments.set(fragmentName, {\n    kind: 'pending'\n  });\n  var transformedFragment = null;\n  var selections = transformSelections(context, fragments, fragmentScope, fragment.selections, errorContext);\n\n  if (selections) {\n    transformedFragment = _objectSpread({}, fragment, {\n      selections: selections,\n      name: fragmentName,\n      argumentDefinitions: []\n    });\n  }\n\n  fragments.set(fragmentName, {\n    kind: 'resolved',\n    value: transformedFragment\n  });\n  return transformedFragment;\n}\n\nfunction hashArguments(args, scope, errorContext) {\n  if (!args.length) {\n    return null;\n  }\n\n  var sortedArgs = (0, _toConsumableArray2[\"default\"])(args).sort(function (a, b) {\n    return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;\n  });\n  var printedArgs = JSON.stringify(sortedArgs.map(function (arg) {\n    var value;\n\n    if (arg.value.kind === 'Variable') {\n      value = scope[arg.value.variableName];\n\n      if (value == null) {\n        var _errorContext$2;\n\n        // This transform does whole-program optimization, errors in\n        // a single document could break invariants and/or cause\n        // additional spurious errors.\n        throw createNonRecoverableUserError(\"Variable '$\".concat(arg.value.variableName, \"' is not in scope.\"), [(_errorContext$2 = errorContext[0]) === null || _errorContext$2 === void 0 ? void 0 : _errorContext$2.loc, arg.value.loc].filter(Boolean));\n      }\n    } else {\n      value = arg.value;\n    }\n\n    return {\n      name: arg.name,\n      value: getIdentifierForArgumentValue(value)\n    };\n  }));\n  return murmurHash(printedArgs);\n}\n\nmodule.exports = {\n  transform: applyFragmentArgumentTransform\n};"]},"metadata":{},"sourceType":"script"}