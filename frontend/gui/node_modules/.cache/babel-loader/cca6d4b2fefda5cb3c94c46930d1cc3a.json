{"ast":null,"code":"import { parse } from '@babel/parser';\nimport { isVariableDeclarator, isIdentifier, isTemplateLiteral, isImportDefaultSpecifier, isImportSpecifier } from '@babel/types';\nimport { asArray } from '@graphql-tools/utils';\nimport traverse from '@babel/traverse';\n\nconst getExtNameFromFilePath = filePath => {\n  const partials = filePath.split('.');\n  let ext = '.' + partials.pop();\n\n  if (partials.length > 1 && partials[partials.length - 1] === 'flow') {\n    ext = '.' + partials.pop() + ext;\n  }\n\n  return ext;\n};\n\nfunction generateConfig(filePath, code, _options) {\n  const plugins = ['asyncGenerators', 'bigInt', 'classProperties', 'classPrivateProperties', 'classPrivateMethods', 'decorators-legacy', 'doExpressions', 'dynamicImport', 'exportDefaultFrom', 'exportNamespaceFrom', 'functionBind', 'functionSent', 'importMeta', 'logicalAssignment', 'nullishCoalescingOperator', 'numericSeparator', 'objectRestSpread', 'optionalCatchBinding', 'optionalChaining', ['pipelineOperator', {\n    proposal: 'smart'\n  }], 'throwExpressions']; // { all: true } option is bullshit thus I do it manually, just in case\n  // I still specify it\n\n  const flowPlugins = [['flow', {\n    all: true\n  }], 'flowComments']; // If line has @flow header, include flow plug-ins\n\n  const dynamicFlowPlugins = code.includes('@flow') ? flowPlugins : [];\n  const fileExt = getExtNameFromFilePath(filePath);\n\n  switch (fileExt) {\n    case '.ts':\n      plugins.push('typescript');\n      break;\n\n    case '.tsx':\n      plugins.push('typescript', 'jsx');\n      break;\n    // Adding .jsx extension by default because it doesn't affect other syntax features\n    // (unlike .tsx) and because people are seem to use it with regular file extensions\n    // (e.g. .js) see https://github.com/dotansimha/graphql-code-generator/issues/1967\n\n    case '.js':\n      plugins.push('jsx', ...dynamicFlowPlugins);\n      break;\n\n    case '.jsx':\n      plugins.push('jsx', ...dynamicFlowPlugins);\n      break;\n\n    case '.flow.js':\n      plugins.push('jsx', ...flowPlugins);\n      break;\n\n    case '.flow.jsx':\n      plugins.push('jsx', ...flowPlugins);\n      break;\n\n    case '.flow':\n      plugins.push('jsx', ...flowPlugins);\n      break;\n\n    case '.vue':\n      plugins.push('vue');\n      break;\n\n    default:\n      plugins.push('jsx', ...dynamicFlowPlugins);\n      break;\n  } // The _options filed will be used to retrieve the original options.\n  // Useful when we wanna get not config related options later on\n\n\n  return {\n    sourceType: 'module',\n    plugins,\n    allowUndeclaredExports: true\n  };\n} // Will use the shortest indention as an axis\n\n\nconst freeText = text => {\n  if (text instanceof Array) {\n    text = text.join('');\n  } // This will allow inline text generation with external functions, same as ctrl+shift+c\n  // As long as we surround the inline text with ==>text<==\n\n\n  text = text.replace(/( *)==>((?:.|\\n)*?)<==/g, (_match, baseIndent, content) => {\n    return content.split('\\n').map(line => `${baseIndent}${line}`).join('\\n');\n  });\n  const lines = text.split('\\n');\n  const minIndent = lines.filter(line => line.trim()).reduce((minIndent, line) => {\n    const currIndent = line.match(/^ */)[0].length;\n    return currIndent < minIndent ? currIndent : minIndent;\n  }, Infinity);\n  return lines.map(line => line.slice(minIndent)).join('\\n').trim().replace(/\\n +\\n/g, '\\n\\n');\n};\n\nconst defaults = {\n  modules: [{\n    name: 'graphql-tag'\n  }, {\n    name: 'graphql-tag.macro'\n  }, {\n    name: '@apollo/client',\n    identifier: 'gql'\n  }, {\n    name: '@apollo/client/core',\n    identifier: 'gql'\n  }, {\n    name: 'apollo-angular',\n    identifier: 'gql'\n  }, {\n    name: 'gatsby',\n    identifier: 'graphql'\n  }, {\n    name: 'apollo-server-express',\n    identifier: 'gql'\n  }, {\n    name: 'apollo-server',\n    identifier: 'gql'\n  }, {\n    name: 'react-relay',\n    identifier: 'graphql'\n  }, {\n    name: 'apollo-boost',\n    identifier: 'gql'\n  }, {\n    name: 'apollo-server-koa',\n    identifier: 'gql'\n  }, {\n    name: 'apollo-server-hapi',\n    identifier: 'gql'\n  }, {\n    name: 'apollo-server-fastify',\n    identifier: 'gql'\n  }, {\n    name: ' apollo-server-lambda',\n    identifier: 'gql'\n  }, {\n    name: 'apollo-server-micro',\n    identifier: 'gql'\n  }, {\n    name: 'apollo-server-azure-functions',\n    identifier: 'gql'\n  }, {\n    name: 'apollo-server-cloud-functions',\n    identifier: 'gql'\n  }, {\n    name: 'apollo-server-cloudflare',\n    identifier: 'gql'\n  }, {\n    name: 'graphql.macro',\n    identifier: 'gql'\n  }],\n  gqlMagicComment: 'graphql',\n  globalGqlIdentifierName: ['gql', 'graphql']\n};\n\nconst createVisitor = (code, out, options = {}) => {\n  // Apply defaults to options\n  let {\n    modules,\n    globalGqlIdentifierName,\n    gqlMagicComment\n  } = { ...defaults,\n    ...options\n  }; // Prevent case related potential errors\n\n  gqlMagicComment = gqlMagicComment.toLowerCase(); // normalize `name` and `identifier` values\n\n  modules = modules.map(mod => {\n    return {\n      name: mod.name,\n      identifier: mod.identifier && mod.identifier.toLowerCase()\n    };\n  });\n  globalGqlIdentifierName = asArray(globalGqlIdentifierName).map(s => s.toLowerCase()); // Keep imported identifiers\n  // import gql from 'graphql-tag' -> gql\n  // import { graphql } from 'gatsby' -> graphql\n  // Will result with ['gql', 'graphql']\n\n  const definedIdentifierNames = []; // Will accumulate all template literals\n\n  const gqlTemplateLiterals = []; // Check if package is registered\n\n  function isValidPackage(name) {\n    return modules.some(pkg => pkg.name && name && pkg.name.toLowerCase() === name.toLowerCase());\n  } // Check if identifier is defined and imported from registered packages\n\n\n  function isValidIdentifier(name) {\n    return definedIdentifierNames.some(id => id === name) || globalGqlIdentifierName.includes(name);\n  }\n\n  const pluckStringFromFile = ({\n    start,\n    end\n  }) => {\n    return freeText(code // Slice quotes\n    .slice(start + 1, end - 1) // Erase string interpolations as we gonna export everything as a single\n    // string anyways\n    .replace(/\\$\\{[^}]*\\}/g, '').split('\\\\`').join('`'));\n  }; // Push all template literals leaded by graphql magic comment\n  // e.g. /* GraphQL */ `query myQuery {}` -> query myQuery {}\n\n\n  const pluckMagicTemplateLiteral = (node, takeExpression = false) => {\n    const leadingComments = node.leadingComments;\n\n    if (!leadingComments) {\n      return;\n    }\n\n    if (!leadingComments.length) {\n      return;\n    }\n\n    const leadingComment = leadingComments[leadingComments.length - 1];\n    const leadingCommentValue = leadingComment.value.trim().toLowerCase();\n\n    if (leadingCommentValue !== gqlMagicComment) {\n      return;\n    }\n\n    const gqlTemplateLiteral = pluckStringFromFile(takeExpression ? node.expression : node);\n\n    if (gqlTemplateLiteral) {\n      gqlTemplateLiterals.push(gqlTemplateLiteral);\n    }\n  };\n\n  return {\n    CallExpression: {\n      enter(path) {\n        // Find the identifier name used from graphql-tag, commonJS\n        // e.g. import gql from 'graphql-tag' -> gql\n        if (path.node.callee.name === 'require' && isValidPackage(path.node.arguments[0].value)) {\n          if (!isVariableDeclarator(path.parent)) {\n            return;\n          }\n\n          if (!isIdentifier(path.parent.id)) {\n            return;\n          }\n\n          definedIdentifierNames.push(path.parent.id.name);\n          return;\n        }\n\n        const arg0 = path.node.arguments[0]; // Push strings template literals to gql calls\n        // e.g. gql(`query myQuery {}`) -> query myQuery {}\n\n        if (isIdentifier(path.node.callee) && isValidIdentifier(path.node.callee.name) && isTemplateLiteral(arg0)) {\n          const gqlTemplateLiteral = pluckStringFromFile(arg0); // If the entire template was made out of interpolations it should be an empty\n          // string by now and thus should be ignored\n\n          if (gqlTemplateLiteral) {\n            gqlTemplateLiterals.push(gqlTemplateLiteral);\n          }\n        }\n      }\n\n    },\n    ImportDeclaration: {\n      enter(path) {\n        // Find the identifier name used from graphql-tag, es6\n        // e.g. import gql from 'graphql-tag' -> gql\n        if (!isValidPackage(path.node.source.value)) {\n          return;\n        }\n\n        const moduleNode = modules.find(pkg => pkg.name.toLowerCase() === path.node.source.value.toLowerCase());\n        const gqlImportSpecifier = path.node.specifiers.find(importSpecifier => {\n          // When it's a default import and registered package has no named identifier\n          if (isImportDefaultSpecifier(importSpecifier) && !moduleNode.identifier) {\n            return true;\n          } // When it's a named import that matches registered package's identifier\n\n\n          if (isImportSpecifier(importSpecifier) && importSpecifier.imported.name === moduleNode.identifier) {\n            return true;\n          }\n\n          return false;\n        });\n\n        if (!gqlImportSpecifier) {\n          return;\n        }\n\n        definedIdentifierNames.push(gqlImportSpecifier.local.name);\n      }\n\n    },\n    ExpressionStatement: {\n      exit(path) {\n        // Push all template literals leaded by graphql magic comment\n        // e.g. /* GraphQL */ `query myQuery {}` -> query myQuery {}\n        if (!isTemplateLiteral(path.node.expression)) {\n          return;\n        }\n\n        pluckMagicTemplateLiteral(path.node, true);\n      }\n\n    },\n    TemplateLiteral: {\n      exit(path) {\n        pluckMagicTemplateLiteral(path.node);\n      }\n\n    },\n    TaggedTemplateExpression: {\n      exit(path) {\n        // Push all template literals provided to the found identifier name\n        // e.g. gql `query myQuery {}` -> query myQuery {}\n        if (!isIdentifier(path.node.tag) || !isValidIdentifier(path.node.tag.name)) {\n          return;\n        }\n\n        const gqlTemplateLiteral = pluckStringFromFile(path.node.quasi);\n\n        if (gqlTemplateLiteral) {\n          gqlTemplateLiterals.push(gqlTemplateLiteral);\n        }\n      }\n\n    },\n\n    exit() {\n      out.returnValue = gqlTemplateLiterals.join('\\n\\n');\n    }\n\n  };\n};\n\nconst supportedExtensions = ['.js', '.jsx', '.ts', '.tsx', '.flow', '.flow.js', '.flow.jsx', '.vue']; // tslint:disable-next-line: no-implicit-dependencies\n\nfunction parseWithVue(vueTemplateCompiler, fileData) {\n  const parsed = vueTemplateCompiler.parseComponent(fileData);\n  return parsed.script ? parsed.script.content : '';\n}\n/**\n * Asynchronously plucks GraphQL template literals from a single file.\n *\n * Supported file extensions include: `.js`, `.jsx`, `.ts`, `.tsx`, `.flow`, `.flow.js`, `.flow.jsx`, `.vue`\n *\n * @param filePath Path to the file containing the code. Required to detect the file type\n * @param code The contents of the file being parsed.\n * @param options Additional options for determining how a file is parsed.\n */\n\n\nconst gqlPluckFromCodeString = async (filePath, code, options = {}) => {\n  validate({\n    code,\n    options\n  });\n  const fileExt = extractExtension(filePath);\n\n  if (fileExt === '.vue') {\n    code = await pluckVueFileScript(code);\n  }\n\n  return parseCode({\n    code,\n    filePath,\n    options\n  });\n};\n/**\n * Synchronously plucks GraphQL template literals from a single file\n *\n * Supported file extensions include: `.js`, `.jsx`, `.ts`, `.tsx`, `.flow`, `.flow.js`, `.flow.jsx`, `.vue`\n *\n * @param filePath Path to the file containing the code. Required to detect the file type\n * @param code The contents of the file being parsed.\n * @param options Additional options for determining how a file is parsed.\n */\n\n\nconst gqlPluckFromCodeStringSync = (filePath, code, options = {}) => {\n  validate({\n    code,\n    options\n  });\n  const fileExt = extractExtension(filePath);\n\n  if (fileExt === '.vue') {\n    code = pluckVueFileScriptSync(code);\n  }\n\n  return parseCode({\n    code,\n    filePath,\n    options\n  });\n};\n\nfunction parseCode({\n  code,\n  filePath,\n  options\n}) {\n  const out = {\n    returnValue: null\n  };\n  const ast = parse(code, generateConfig(filePath, code));\n  const visitor = createVisitor(code, out, options);\n  traverse(ast, visitor);\n  return out.returnValue;\n}\n\nfunction validate({\n  code,\n  options\n}) {\n  if (typeof code !== 'string') {\n    throw TypeError('Provided code must be a string');\n  }\n\n  if (!(options instanceof Object)) {\n    throw TypeError(`Options arg must be an object`);\n  }\n}\n\nfunction extractExtension(filePath) {\n  const fileExt = getExtNameFromFilePath(filePath);\n\n  if (fileExt) {\n    if (!supportedExtensions.includes(fileExt)) {\n      throw TypeError(`Provided file type must be one of ${supportedExtensions.join(', ')} `);\n    }\n  }\n\n  return fileExt;\n}\n\nconst MissingVueTemplateCompilerError = new Error(freeText(`\n    GraphQL template literals cannot be plucked from a Vue template code without having the \"vue-template-compiler\" package installed.\n    Please install it and try again.\n\n    Via NPM:\n\n        $ npm install vue-template-compiler\n\n    Via Yarn:\n\n        $ yarn add vue-template-compiler\n  `));\n\nasync function pluckVueFileScript(fileData) {\n  // tslint:disable-next-line: no-implicit-dependencies\n  let vueTemplateCompiler;\n\n  try {\n    // tslint:disable-next-line: no-implicit-dependencies\n    vueTemplateCompiler = await import('vue-template-compiler');\n  } catch (e) {\n    throw MissingVueTemplateCompilerError;\n  }\n\n  return parseWithVue(vueTemplateCompiler, fileData);\n}\n\nfunction pluckVueFileScriptSync(fileData) {\n  // tslint:disable-next-line: no-implicit-dependencies\n  let vueTemplateCompiler;\n\n  try {\n    // tslint:disable-next-line: no-implicit-dependencies\n    vueTemplateCompiler = require('vue-template-compiler');\n  } catch (e) {\n    throw MissingVueTemplateCompilerError;\n  }\n\n  return parseWithVue(vueTemplateCompiler, fileData);\n}\n\nexport { gqlPluckFromCodeString, gqlPluckFromCodeStringSync };","map":{"version":3,"sources":["../../../dist/graphql-tag-pluck/src/libs/extname.js","../../../dist/graphql-tag-pluck/src/config.js","../../../dist/graphql-tag-pluck/src/utils.js","../../../dist/graphql-tag-pluck/src/visitor.js","../../../dist/graphql-tag-pluck/src/index.js"],"names":[],"mappings":"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","sourcesContent":["export const getExtNameFromFilePath = (filePath) => {\n    const partials = filePath.split('.');\n    let ext = '.' + partials.pop();\n    if (partials.length > 1 && partials[partials.length - 1] === 'flow') {\n        ext = '.' + partials.pop() + ext;\n    }\n    return ext;\n};\n//# sourceMappingURL=extname.js.map","import { getExtNameFromFilePath } from './libs/extname';\nexport default function generateConfig(filePath, code, _options) {\n    const plugins = [\n        'asyncGenerators',\n        'bigInt',\n        'classProperties',\n        'classPrivateProperties',\n        'classPrivateMethods',\n        'decorators-legacy',\n        'doExpressions',\n        'dynamicImport',\n        'exportDefaultFrom',\n        'exportNamespaceFrom',\n        'functionBind',\n        'functionSent',\n        'importMeta',\n        'logicalAssignment',\n        'nullishCoalescingOperator',\n        'numericSeparator',\n        'objectRestSpread',\n        'optionalCatchBinding',\n        'optionalChaining',\n        ['pipelineOperator', { proposal: 'smart' }],\n        'throwExpressions',\n    ];\n    // { all: true } option is bullshit thus I do it manually, just in case\n    // I still specify it\n    const flowPlugins = [['flow', { all: true }], 'flowComments'];\n    // If line has @flow header, include flow plug-ins\n    const dynamicFlowPlugins = code.includes('@flow') ? flowPlugins : [];\n    const fileExt = getExtNameFromFilePath(filePath);\n    switch (fileExt) {\n        case '.ts':\n            plugins.push('typescript');\n            break;\n        case '.tsx':\n            plugins.push('typescript', 'jsx');\n            break;\n        // Adding .jsx extension by default because it doesn't affect other syntax features\n        // (unlike .tsx) and because people are seem to use it with regular file extensions\n        // (e.g. .js) see https://github.com/dotansimha/graphql-code-generator/issues/1967\n        case '.js':\n            plugins.push('jsx', ...dynamicFlowPlugins);\n            break;\n        case '.jsx':\n            plugins.push('jsx', ...dynamicFlowPlugins);\n            break;\n        case '.flow.js':\n            plugins.push('jsx', ...flowPlugins);\n            break;\n        case '.flow.jsx':\n            plugins.push('jsx', ...flowPlugins);\n            break;\n        case '.flow':\n            plugins.push('jsx', ...flowPlugins);\n            break;\n        case '.vue':\n            plugins.push('vue');\n            break;\n        default:\n            plugins.push('jsx', ...dynamicFlowPlugins);\n            break;\n    }\n    // The _options filed will be used to retrieve the original options.\n    // Useful when we wanna get not config related options later on\n    return {\n        sourceType: 'module',\n        plugins,\n        allowUndeclaredExports: true,\n    };\n}\n//# sourceMappingURL=config.js.map","// Will use the shortest indention as an axis\nexport const freeText = (text) => {\n    if (text instanceof Array) {\n        text = text.join('');\n    }\n    // This will allow inline text generation with external functions, same as ctrl+shift+c\n    // As long as we surround the inline text with ==>text<==\n    text = text.replace(/( *)==>((?:.|\\n)*?)<==/g, (_match, baseIndent, content) => {\n        return content\n            .split('\\n')\n            .map(line => `${baseIndent}${line}`)\n            .join('\\n');\n    });\n    const lines = text.split('\\n');\n    const minIndent = lines\n        .filter(line => line.trim())\n        .reduce((minIndent, line) => {\n        const currIndent = line.match(/^ */)[0].length;\n        return currIndent < minIndent ? currIndent : minIndent;\n    }, Infinity);\n    return lines\n        .map(line => line.slice(minIndent))\n        .join('\\n')\n        .trim()\n        .replace(/\\n +\\n/g, '\\n\\n');\n};\n// foo_barBaz -> ['foo', 'bar', 'Baz']\nexport const splitWords = (str) => {\n    return str.replace(/[A-Z]/, ' $&').split(/[^a-zA-Z0-9]+/);\n};\n// upper -> Upper\nexport const toUpperFirst = (str) => {\n    return str.substr(0, 1).toUpperCase() + str.substr(1).toLowerCase();\n};\n// foo-bar-baz -> fooBarBaz\nexport const toCamelCase = (str) => {\n    const words = splitWords(str);\n    const first = words.shift().toLowerCase();\n    const rest = words.map(toUpperFirst);\n    return [first, ...rest].join('');\n};\n//# sourceMappingURL=utils.js.map","import { freeText } from './utils';\nimport { isVariableDeclarator, isIdentifier, isTemplateLiteral, isImportDefaultSpecifier, isImportSpecifier, } from '@babel/types';\nimport { asArray } from '@graphql-tools/utils';\nconst defaults = {\n    modules: [\n        {\n            name: 'graphql-tag',\n        },\n        {\n            name: 'graphql-tag.macro',\n        },\n        {\n            name: '@apollo/client',\n            identifier: 'gql',\n        },\n        {\n            name: '@apollo/client/core',\n            identifier: 'gql',\n        },\n        {\n            name: 'apollo-angular',\n            identifier: 'gql',\n        },\n        {\n            name: 'gatsby',\n            identifier: 'graphql',\n        },\n        {\n            name: 'apollo-server-express',\n            identifier: 'gql',\n        },\n        {\n            name: 'apollo-server',\n            identifier: 'gql',\n        },\n        {\n            name: 'react-relay',\n            identifier: 'graphql',\n        },\n        {\n            name: 'apollo-boost',\n            identifier: 'gql',\n        },\n        {\n            name: 'apollo-server-koa',\n            identifier: 'gql',\n        },\n        {\n            name: 'apollo-server-hapi',\n            identifier: 'gql',\n        },\n        {\n            name: 'apollo-server-fastify',\n            identifier: 'gql',\n        },\n        {\n            name: ' apollo-server-lambda',\n            identifier: 'gql',\n        },\n        {\n            name: 'apollo-server-micro',\n            identifier: 'gql',\n        },\n        {\n            name: 'apollo-server-azure-functions',\n            identifier: 'gql',\n        },\n        {\n            name: 'apollo-server-cloud-functions',\n            identifier: 'gql',\n        },\n        {\n            name: 'apollo-server-cloudflare',\n            identifier: 'gql',\n        },\n        {\n            name: 'graphql.macro',\n            identifier: 'gql',\n        },\n    ],\n    gqlMagicComment: 'graphql',\n    globalGqlIdentifierName: ['gql', 'graphql'],\n};\nexport default (code, out, options = {}) => {\n    // Apply defaults to options\n    let { modules, globalGqlIdentifierName, gqlMagicComment } = {\n        ...defaults,\n        ...options,\n    };\n    // Prevent case related potential errors\n    gqlMagicComment = gqlMagicComment.toLowerCase();\n    // normalize `name` and `identifier` values\n    modules = modules.map(mod => {\n        return {\n            name: mod.name,\n            identifier: mod.identifier && mod.identifier.toLowerCase(),\n        };\n    });\n    globalGqlIdentifierName = asArray(globalGqlIdentifierName).map(s => s.toLowerCase());\n    // Keep imported identifiers\n    // import gql from 'graphql-tag' -> gql\n    // import { graphql } from 'gatsby' -> graphql\n    // Will result with ['gql', 'graphql']\n    const definedIdentifierNames = [];\n    // Will accumulate all template literals\n    const gqlTemplateLiterals = [];\n    // Check if package is registered\n    function isValidPackage(name) {\n        return modules.some(pkg => pkg.name && name && pkg.name.toLowerCase() === name.toLowerCase());\n    }\n    // Check if identifier is defined and imported from registered packages\n    function isValidIdentifier(name) {\n        return definedIdentifierNames.some(id => id === name) || globalGqlIdentifierName.includes(name);\n    }\n    const pluckStringFromFile = ({ start, end }) => {\n        return freeText(code\n            // Slice quotes\n            .slice(start + 1, end - 1)\n            // Erase string interpolations as we gonna export everything as a single\n            // string anyways\n            .replace(/\\$\\{[^}]*\\}/g, '')\n            .split('\\\\`')\n            .join('`'));\n    };\n    // Push all template literals leaded by graphql magic comment\n    // e.g. /* GraphQL */ `query myQuery {}` -> query myQuery {}\n    const pluckMagicTemplateLiteral = (node, takeExpression = false) => {\n        const leadingComments = node.leadingComments;\n        if (!leadingComments) {\n            return;\n        }\n        if (!leadingComments.length) {\n            return;\n        }\n        const leadingComment = leadingComments[leadingComments.length - 1];\n        const leadingCommentValue = leadingComment.value.trim().toLowerCase();\n        if (leadingCommentValue !== gqlMagicComment) {\n            return;\n        }\n        const gqlTemplateLiteral = pluckStringFromFile(takeExpression ? node.expression : node);\n        if (gqlTemplateLiteral) {\n            gqlTemplateLiterals.push(gqlTemplateLiteral);\n        }\n    };\n    return {\n        CallExpression: {\n            enter(path) {\n                // Find the identifier name used from graphql-tag, commonJS\n                // e.g. import gql from 'graphql-tag' -> gql\n                if (path.node.callee.name === 'require' && isValidPackage(path.node.arguments[0].value)) {\n                    if (!isVariableDeclarator(path.parent)) {\n                        return;\n                    }\n                    if (!isIdentifier(path.parent.id)) {\n                        return;\n                    }\n                    definedIdentifierNames.push(path.parent.id.name);\n                    return;\n                }\n                const arg0 = path.node.arguments[0];\n                // Push strings template literals to gql calls\n                // e.g. gql(`query myQuery {}`) -> query myQuery {}\n                if (isIdentifier(path.node.callee) && isValidIdentifier(path.node.callee.name) && isTemplateLiteral(arg0)) {\n                    const gqlTemplateLiteral = pluckStringFromFile(arg0);\n                    // If the entire template was made out of interpolations it should be an empty\n                    // string by now and thus should be ignored\n                    if (gqlTemplateLiteral) {\n                        gqlTemplateLiterals.push(gqlTemplateLiteral);\n                    }\n                }\n            },\n        },\n        ImportDeclaration: {\n            enter(path) {\n                // Find the identifier name used from graphql-tag, es6\n                // e.g. import gql from 'graphql-tag' -> gql\n                if (!isValidPackage(path.node.source.value)) {\n                    return;\n                }\n                const moduleNode = modules.find(pkg => pkg.name.toLowerCase() === path.node.source.value.toLowerCase());\n                const gqlImportSpecifier = path.node.specifiers.find((importSpecifier) => {\n                    // When it's a default import and registered package has no named identifier\n                    if (isImportDefaultSpecifier(importSpecifier) && !moduleNode.identifier) {\n                        return true;\n                    }\n                    // When it's a named import that matches registered package's identifier\n                    if (isImportSpecifier(importSpecifier) && importSpecifier.imported.name === moduleNode.identifier) {\n                        return true;\n                    }\n                    return false;\n                });\n                if (!gqlImportSpecifier) {\n                    return;\n                }\n                definedIdentifierNames.push(gqlImportSpecifier.local.name);\n            },\n        },\n        ExpressionStatement: {\n            exit(path) {\n                // Push all template literals leaded by graphql magic comment\n                // e.g. /* GraphQL */ `query myQuery {}` -> query myQuery {}\n                if (!isTemplateLiteral(path.node.expression)) {\n                    return;\n                }\n                pluckMagicTemplateLiteral(path.node, true);\n            },\n        },\n        TemplateLiteral: {\n            exit(path) {\n                pluckMagicTemplateLiteral(path.node);\n            },\n        },\n        TaggedTemplateExpression: {\n            exit(path) {\n                // Push all template literals provided to the found identifier name\n                // e.g. gql `query myQuery {}` -> query myQuery {}\n                if (!isIdentifier(path.node.tag) || !isValidIdentifier(path.node.tag.name)) {\n                    return;\n                }\n                const gqlTemplateLiteral = pluckStringFromFile(path.node.quasi);\n                if (gqlTemplateLiteral) {\n                    gqlTemplateLiterals.push(gqlTemplateLiteral);\n                }\n            },\n        },\n        exit() {\n            out.returnValue = gqlTemplateLiterals.join('\\n\\n');\n        },\n    };\n};\n//# sourceMappingURL=visitor.js.map","import generateConfig from './config';\nimport { parse } from '@babel/parser';\nimport { getExtNameFromFilePath } from './libs/extname';\nimport createVisitor from './visitor';\nimport traverse from '@babel/traverse';\nimport { freeText } from './utils';\nconst supportedExtensions = ['.js', '.jsx', '.ts', '.tsx', '.flow', '.flow.js', '.flow.jsx', '.vue'];\n// tslint:disable-next-line: no-implicit-dependencies\nfunction parseWithVue(vueTemplateCompiler, fileData) {\n    const parsed = vueTemplateCompiler.parseComponent(fileData);\n    return parsed.script ? parsed.script.content : '';\n}\n/**\n * Asynchronously plucks GraphQL template literals from a single file.\n *\n * Supported file extensions include: `.js`, `.jsx`, `.ts`, `.tsx`, `.flow`, `.flow.js`, `.flow.jsx`, `.vue`\n *\n * @param filePath Path to the file containing the code. Required to detect the file type\n * @param code The contents of the file being parsed.\n * @param options Additional options for determining how a file is parsed.\n */\nexport const gqlPluckFromCodeString = async (filePath, code, options = {}) => {\n    validate({ code, options });\n    const fileExt = extractExtension(filePath);\n    if (fileExt === '.vue') {\n        code = await pluckVueFileScript(code);\n    }\n    return parseCode({ code, filePath, options });\n};\n/**\n * Synchronously plucks GraphQL template literals from a single file\n *\n * Supported file extensions include: `.js`, `.jsx`, `.ts`, `.tsx`, `.flow`, `.flow.js`, `.flow.jsx`, `.vue`\n *\n * @param filePath Path to the file containing the code. Required to detect the file type\n * @param code The contents of the file being parsed.\n * @param options Additional options for determining how a file is parsed.\n */\nexport const gqlPluckFromCodeStringSync = (filePath, code, options = {}) => {\n    validate({ code, options });\n    const fileExt = extractExtension(filePath);\n    if (fileExt === '.vue') {\n        code = pluckVueFileScriptSync(code);\n    }\n    return parseCode({ code, filePath, options });\n};\nfunction parseCode({ code, filePath, options, }) {\n    const out = { returnValue: null };\n    const ast = parse(code, generateConfig(filePath, code, options));\n    const visitor = createVisitor(code, out, options);\n    traverse(ast, visitor);\n    return out.returnValue;\n}\nfunction validate({ code, options }) {\n    if (typeof code !== 'string') {\n        throw TypeError('Provided code must be a string');\n    }\n    if (!(options instanceof Object)) {\n        throw TypeError(`Options arg must be an object`);\n    }\n}\nfunction extractExtension(filePath) {\n    const fileExt = getExtNameFromFilePath(filePath);\n    if (fileExt) {\n        if (!supportedExtensions.includes(fileExt)) {\n            throw TypeError(`Provided file type must be one of ${supportedExtensions.join(', ')} `);\n        }\n    }\n    return fileExt;\n}\nconst MissingVueTemplateCompilerError = new Error(freeText(`\n    GraphQL template literals cannot be plucked from a Vue template code without having the \"vue-template-compiler\" package installed.\n    Please install it and try again.\n\n    Via NPM:\n\n        $ npm install vue-template-compiler\n\n    Via Yarn:\n\n        $ yarn add vue-template-compiler\n  `));\nasync function pluckVueFileScript(fileData) {\n    // tslint:disable-next-line: no-implicit-dependencies\n    let vueTemplateCompiler;\n    try {\n        // tslint:disable-next-line: no-implicit-dependencies\n        vueTemplateCompiler = await import('vue-template-compiler');\n    }\n    catch (e) {\n        throw MissingVueTemplateCompilerError;\n    }\n    return parseWithVue(vueTemplateCompiler, fileData);\n}\nfunction pluckVueFileScriptSync(fileData) {\n    // tslint:disable-next-line: no-implicit-dependencies\n    let vueTemplateCompiler;\n    try {\n        // tslint:disable-next-line: no-implicit-dependencies\n        vueTemplateCompiler = require('vue-template-compiler');\n    }\n    catch (e) {\n        throw MissingVueTemplateCompilerError;\n    }\n    return parseWithVue(vueTemplateCompiler, fileData);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}