{"ast":null,"code":"import { ApolloLink, Observable, concat, toPromise, execute } from 'apollo-link';\nimport { createUploadLink, isExtractableFile, formDataAppendFile } from 'apollo-upload-client';\nimport FormData from 'form-data';\nimport { fetch } from 'cross-fetch';\nimport { observableToAsyncIterable } from '@graphql-tools/utils';\nimport { GraphQLScalarType, GraphQLError } from 'graphql';\nimport isPromise from 'is-promise';\n\nfunction getFinalPromise(object) {\n  return Promise.resolve(object).then(resolvedObject => {\n    if (resolvedObject == null) {\n      return resolvedObject;\n    }\n\n    if (Array.isArray(resolvedObject)) {\n      return Promise.all(resolvedObject.map(o => getFinalPromise(o)));\n    } else if (typeof resolvedObject === 'object') {\n      const keys = Object.keys(resolvedObject);\n      return Promise.all(keys.map(key => getFinalPromise(resolvedObject[key]))).then(awaitedValues => {\n        for (let i = 0; i < keys.length; i++) {\n          resolvedObject[keys[i]] = awaitedValues[i];\n        }\n\n        return resolvedObject;\n      });\n    }\n\n    return resolvedObject;\n  });\n}\n\nclass AwaitVariablesLink extends ApolloLink {\n  request(operation, forward) {\n    return new Observable(observer => {\n      let subscription;\n      getFinalPromise(operation.variables).then(resolvedVariables => {\n        operation.variables = resolvedVariables;\n        subscription = forward(operation).subscribe({\n          next: observer.next.bind(observer),\n          error: observer.error.bind(observer),\n          complete: observer.complete.bind(observer)\n        });\n      }).catch(observer.error.bind(observer));\n      return () => {\n        if (subscription != null) {\n          subscription.unsubscribe();\n        }\n      };\n    });\n  }\n\n}\n\nclass FormDataWithStreamSupport extends FormData {\n  constructor(options) {\n    super(options);\n    this.hasUnknowableLength = false;\n  }\n\n  append(key, value, optionsOrFilename = {}) {\n    // allow filename as single option\n    const options = typeof optionsOrFilename === 'string' ? {\n      filename: optionsOrFilename\n    } : optionsOrFilename; // empty or either doesn't have path or not an http response\n\n    if (!options.knownLength && !Buffer.isBuffer(value) && typeof value !== 'string' && !value.path && !(value.readable && 'httpVersion' in value)) {\n      this.hasUnknowableLength = true;\n    }\n\n    super.append(key, value, options);\n  }\n\n  getLength(callback) {\n    if (this.hasUnknowableLength) {\n      return null;\n    }\n\n    return super.getLength(callback);\n  }\n\n  getLengthSync() {\n    if (this.hasUnknowableLength) {\n      return null;\n    } // eslint-disable-next-line no-sync\n\n\n    return super.getLengthSync();\n  }\n\n}\n\nconst createServerHttpLink = options => concat(new AwaitVariablesLink(), createUploadLink({ ...options,\n  fetch,\n  FormData: FormDataWithStreamSupport,\n  isExtractableFile: value => isExtractableFile(value) || (value === null || value === void 0 ? void 0 : value.createReadStream),\n  formDataAppendFile: (form, index, file) => {\n    if (file.createReadStream != null) {\n      form.append(index, file.createReadStream(), {\n        filename: file.filename,\n        contentType: file.mimetype\n      });\n    } else {\n      formDataAppendFile(form, index, file);\n    }\n  }\n}));\n\nconst linkToExecutor = link => ({\n  document,\n  variables,\n  context,\n  info\n}) => toPromise(execute(link, {\n  query: document,\n  variables,\n  context: {\n    graphqlContext: context,\n    graphqlResolveInfo: info,\n    clientAwareness: {}\n  }\n}));\n\nconst linkToSubscriber = link => async ({\n  document,\n  variables,\n  context,\n  info\n}) => observableToAsyncIterable(execute(link, {\n  query: document,\n  variables,\n  context: {\n    graphqlContext: context,\n    graphqlResolveInfo: info,\n    clientAwareness: {}\n  }\n}));\n\nconst GraphQLUpload = new GraphQLScalarType({\n  name: 'Upload',\n  description: 'The `Upload` scalar type represents a file upload.',\n  parseValue: value => {\n    if (value != null && isPromise(value.promise)) {\n      // graphql-upload v10\n      return value.promise;\n    } else if (isPromise(value)) {\n      // graphql-upload v9\n      return value;\n    }\n\n    throw new GraphQLError('Upload value invalid.');\n  },\n  // serialization requires to support schema stitching\n  serialize: value => value,\n  parseLiteral: ast => {\n    throw new GraphQLError('Upload literal unsupported.', ast);\n  }\n});\nexport { AwaitVariablesLink, GraphQLUpload, createServerHttpLink, linkToExecutor, linkToSubscriber };","map":{"version":3,"sources":["../../../dist/links/src/AwaitVariablesLink.js","../../../dist/links/src/createServerHttpLink.js","../../../dist/links/src/linkToExecutor.js","../../../dist/links/src/linkToSubscriber.js","../../../dist/links/src/GraphQLUpload.js"],"names":[],"mappings":"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","sourcesContent":["import { ApolloLink, Observable } from 'apollo-link';\nfunction getFinalPromise(object) {\n    return Promise.resolve(object).then(resolvedObject => {\n        if (resolvedObject == null) {\n            return resolvedObject;\n        }\n        if (Array.isArray(resolvedObject)) {\n            return Promise.all(resolvedObject.map(o => getFinalPromise(o)));\n        }\n        else if (typeof resolvedObject === 'object') {\n            const keys = Object.keys(resolvedObject);\n            return Promise.all(keys.map(key => getFinalPromise(resolvedObject[key]))).then(awaitedValues => {\n                for (let i = 0; i < keys.length; i++) {\n                    resolvedObject[keys[i]] = awaitedValues[i];\n                }\n                return resolvedObject;\n            });\n        }\n        return resolvedObject;\n    });\n}\nexport class AwaitVariablesLink extends ApolloLink {\n    request(operation, forward) {\n        return new Observable(observer => {\n            let subscription;\n            getFinalPromise(operation.variables)\n                .then(resolvedVariables => {\n                operation.variables = resolvedVariables;\n                subscription = forward(operation).subscribe({\n                    next: observer.next.bind(observer),\n                    error: observer.error.bind(observer),\n                    complete: observer.complete.bind(observer),\n                });\n            })\n                .catch(observer.error.bind(observer));\n            return () => {\n                if (subscription != null) {\n                    subscription.unsubscribe();\n                }\n            };\n        });\n    }\n}\n//# sourceMappingURL=AwaitVariablesLink.js.map","import { concat } from 'apollo-link';\nimport { createUploadLink, formDataAppendFile, isExtractableFile } from 'apollo-upload-client';\nimport FormData from 'form-data';\nimport { fetch } from 'cross-fetch';\nimport { AwaitVariablesLink } from './AwaitVariablesLink';\nclass FormDataWithStreamSupport extends FormData {\n    constructor(options) {\n        super(options);\n        this.hasUnknowableLength = false;\n    }\n    append(key, value, optionsOrFilename = {}) {\n        // allow filename as single option\n        const options = typeof optionsOrFilename === 'string' ? { filename: optionsOrFilename } : optionsOrFilename;\n        // empty or either doesn't have path or not an http response\n        if (!options.knownLength &&\n            !Buffer.isBuffer(value) &&\n            typeof value !== 'string' &&\n            !value.path &&\n            !(value.readable && 'httpVersion' in value)) {\n            this.hasUnknowableLength = true;\n        }\n        super.append(key, value, options);\n    }\n    getLength(callback) {\n        if (this.hasUnknowableLength) {\n            return null;\n        }\n        return super.getLength(callback);\n    }\n    getLengthSync() {\n        if (this.hasUnknowableLength) {\n            return null;\n        }\n        // eslint-disable-next-line no-sync\n        return super.getLengthSync();\n    }\n}\nexport const createServerHttpLink = (options) => concat(new AwaitVariablesLink(), createUploadLink({\n    ...options,\n    fetch,\n    FormData: FormDataWithStreamSupport,\n    isExtractableFile: (value) => isExtractableFile(value) || (value === null || value === void 0 ? void 0 : value.createReadStream),\n    formDataAppendFile: (form, index, file) => {\n        if (file.createReadStream != null) {\n            form.append(index, file.createReadStream(), {\n                filename: file.filename,\n                contentType: file.mimetype,\n            });\n        }\n        else {\n            formDataAppendFile(form, index, file);\n        }\n    },\n}));\n//# sourceMappingURL=createServerHttpLink.js.map","import { toPromise, execute } from 'apollo-link';\nexport const linkToExecutor = (link) => ({ document, variables, context, info, }) => toPromise(execute(link, {\n    query: document,\n    variables,\n    context: {\n        graphqlContext: context,\n        graphqlResolveInfo: info,\n        clientAwareness: {},\n    },\n}));\n//# sourceMappingURL=linkToExecutor.js.map","import { execute } from 'apollo-link';\nimport { observableToAsyncIterable } from '@graphql-tools/utils';\nexport const linkToSubscriber = (link) => async ({ document, variables, context, info, }) => observableToAsyncIterable(execute(link, {\n    query: document,\n    variables,\n    context: {\n        graphqlContext: context,\n        graphqlResolveInfo: info,\n        clientAwareness: {},\n    },\n}));\n//# sourceMappingURL=linkToSubscriber.js.map","import { GraphQLScalarType, GraphQLError } from 'graphql';\nimport isPromise from 'is-promise';\nconst GraphQLUpload = new GraphQLScalarType({\n    name: 'Upload',\n    description: 'The `Upload` scalar type represents a file upload.',\n    parseValue: value => {\n        if (value != null && isPromise(value.promise)) {\n            // graphql-upload v10\n            return value.promise;\n        }\n        else if (isPromise(value)) {\n            // graphql-upload v9\n            return value;\n        }\n        throw new GraphQLError('Upload value invalid.');\n    },\n    // serialization requires to support schema stitching\n    serialize: value => value,\n    parseLiteral: ast => {\n        throw new GraphQLError('Upload literal unsupported.', ast);\n    },\n});\nexport { GraphQLUpload };\n//# sourceMappingURL=GraphQLUpload.js.map"]},"metadata":{},"sourceType":"module"}