{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nfunction _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar _require = require('./CompilerError'),\n    createCompilerError = _require.createCompilerError;\n\nvar _require2 = require('graphql'),\n    SchemaMetaFieldDef = _require2.SchemaMetaFieldDef,\n    TypeMetaFieldDef = _require2.TypeMetaFieldDef;\n/**\n * Find the definition of a field of the specified type using strict\n * resolution rules per the GraphQL spec.\n */\n\n\nfunction getFieldDefinitionStrict(schema, parentType, fieldName) {\n  var type = schema.getRawType(parentType);\n  var queryType = schema.getQueryType();\n  var isQueryType = queryType != null && schema.areEqualTypes(type, queryType);\n  var hasTypeName = schema.isAbstractType(type) || schema.isObject(type);\n  var schemaFieldDef;\n\n  if (isQueryType && fieldName === SchemaMetaFieldDef.name) {\n    schemaFieldDef = queryType != null ? schema.getFieldByName(queryType, '__schema') : null;\n  } else if (isQueryType && fieldName === TypeMetaFieldDef.name) {\n    schemaFieldDef = queryType != null ? schema.getFieldByName(queryType, '__type') : null;\n  } else if (hasTypeName && fieldName === '__typename') {\n    schemaFieldDef = schema.getFieldByName(schema.assertCompositeType(type), '__typename');\n  } else if (hasTypeName && fieldName === '__id') {\n    schemaFieldDef = schema.getFieldByName(schema.assertCompositeType(type), '__id');\n  } else if (schema.isInterface(type) || schema.isObject(type)) {\n    var compositeType = schema.assertCompositeType(type);\n\n    if (schema.hasField(compositeType, fieldName)) {\n      schemaFieldDef = schema.getFieldByName(compositeType, fieldName);\n    } else {\n      return null;\n    }\n  }\n\n  return schemaFieldDef;\n}\n/**\n * Find the definition of a field of the specified type, first trying\n * the standard spec-compliant resolution process and falling back\n * to legacy mode that supports fat interfaces.\n */\n\n\nfunction getFieldDefinitionLegacy(schema, parentType, fieldName, fieldAST) {\n  var _schemaFieldDef;\n\n  var schemaFieldDef = getFieldDefinitionStrict(schema, parentType, fieldName);\n\n  if (!schemaFieldDef) {\n    schemaFieldDef = getFieldDefinitionLegacyImpl(schema, parentType, fieldName, fieldAST);\n  }\n\n  return (_schemaFieldDef = schemaFieldDef) !== null && _schemaFieldDef !== void 0 ? _schemaFieldDef : null;\n}\n/**\n * @private\n */\n\n\nfunction getFieldDefinitionLegacyImpl(schema, type, fieldName, fieldAST) {\n  var rawType = schema.getRawType(type);\n\n  if (schema.isAbstractType(rawType) && fieldAST && fieldAST.directives && fieldAST.directives.some(function (directive) {\n    return getName(directive) === 'fixme_fat_interface';\n  })) {\n    var possibleTypes = schema.getPossibleTypes(schema.assertAbstractType(rawType));\n    var schemaFieldDef;\n\n    var _iterator = _createForOfIteratorHelper(possibleTypes),\n        _step;\n\n    try {\n      var _loop = function _loop() {\n        var possibleType = _step.value;\n        var possibleField = schema.getFieldByName(possibleType, fieldName);\n\n        if (possibleField) {\n          // Fat interface fields can have differing arguments. Try to return\n          // a field with matching arguments, but still return a field if the\n          // arguments do not match.\n          schemaFieldDef = possibleField;\n\n          if (fieldAST && fieldAST.arguments) {\n            var argumentsAllExist = fieldAST.arguments.every(function (argument) {\n              return schema.getFieldArgByName(possibleField, getName(argument)) != null;\n            });\n\n            if (argumentsAllExist) {\n              return \"break\";\n            }\n          }\n        }\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _ret = _loop();\n\n        if (_ret === \"break\") break;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return schemaFieldDef;\n  }\n}\n/**\n * @private\n */\n\n\nfunction getName(ast) {\n  var name = ast.name ? ast.name.value : null;\n\n  if (typeof name !== 'string') {\n    throw createCompilerError(\"Expected ast node to have a 'name'.\", null, [ast]);\n  }\n\n  return name;\n}\n\nmodule.exports = {\n  getFieldDefinitionLegacy: getFieldDefinitionLegacy,\n  getFieldDefinitionStrict: getFieldDefinitionStrict\n};","map":{"version":3,"sources":["C:/Users/Admin/programs/django+react/tutorials/graphql_django/frontend/gui/node_modules/relay-compiler/lib/core/getFieldDefinition.js"],"names":["_createForOfIteratorHelper","o","Symbol","iterator","Array","isArray","_unsupportedIterableToArray","i","F","s","n","length","done","value","e","_e","f","TypeError","it","normalCompletion","didErr","err","step","next","_e2","minLen","_arrayLikeToArray","Object","prototype","toString","call","slice","constructor","name","from","test","arr","len","arr2","_require","require","createCompilerError","_require2","SchemaMetaFieldDef","TypeMetaFieldDef","getFieldDefinitionStrict","schema","parentType","fieldName","type","getRawType","queryType","getQueryType","isQueryType","areEqualTypes","hasTypeName","isAbstractType","isObject","schemaFieldDef","getFieldByName","assertCompositeType","isInterface","compositeType","hasField","getFieldDefinitionLegacy","fieldAST","_schemaFieldDef","getFieldDefinitionLegacyImpl","rawType","directives","some","directive","getName","possibleTypes","getPossibleTypes","assertAbstractType","_iterator","_step","_loop","possibleType","possibleField","arguments","argumentsAllExist","every","argument","getFieldArgByName","_ret","ast","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n// flowlint ambiguous-object-type:error\n'use strict';\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require('./CompilerError'),\n    createCompilerError = _require.createCompilerError;\n\nvar _require2 = require('graphql'),\n    SchemaMetaFieldDef = _require2.SchemaMetaFieldDef,\n    TypeMetaFieldDef = _require2.TypeMetaFieldDef;\n\n/**\n * Find the definition of a field of the specified type using strict\n * resolution rules per the GraphQL spec.\n */\nfunction getFieldDefinitionStrict(schema, parentType, fieldName) {\n  var type = schema.getRawType(parentType);\n  var queryType = schema.getQueryType();\n  var isQueryType = queryType != null && schema.areEqualTypes(type, queryType);\n  var hasTypeName = schema.isAbstractType(type) || schema.isObject(type);\n  var schemaFieldDef;\n\n  if (isQueryType && fieldName === SchemaMetaFieldDef.name) {\n    schemaFieldDef = queryType != null ? schema.getFieldByName(queryType, '__schema') : null;\n  } else if (isQueryType && fieldName === TypeMetaFieldDef.name) {\n    schemaFieldDef = queryType != null ? schema.getFieldByName(queryType, '__type') : null;\n  } else if (hasTypeName && fieldName === '__typename') {\n    schemaFieldDef = schema.getFieldByName(schema.assertCompositeType(type), '__typename');\n  } else if (hasTypeName && fieldName === '__id') {\n    schemaFieldDef = schema.getFieldByName(schema.assertCompositeType(type), '__id');\n  } else if (schema.isInterface(type) || schema.isObject(type)) {\n    var compositeType = schema.assertCompositeType(type);\n\n    if (schema.hasField(compositeType, fieldName)) {\n      schemaFieldDef = schema.getFieldByName(compositeType, fieldName);\n    } else {\n      return null;\n    }\n  }\n\n  return schemaFieldDef;\n}\n/**\n * Find the definition of a field of the specified type, first trying\n * the standard spec-compliant resolution process and falling back\n * to legacy mode that supports fat interfaces.\n */\n\n\nfunction getFieldDefinitionLegacy(schema, parentType, fieldName, fieldAST) {\n  var _schemaFieldDef;\n\n  var schemaFieldDef = getFieldDefinitionStrict(schema, parentType, fieldName);\n\n  if (!schemaFieldDef) {\n    schemaFieldDef = getFieldDefinitionLegacyImpl(schema, parentType, fieldName, fieldAST);\n  }\n\n  return (_schemaFieldDef = schemaFieldDef) !== null && _schemaFieldDef !== void 0 ? _schemaFieldDef : null;\n}\n/**\n * @private\n */\n\n\nfunction getFieldDefinitionLegacyImpl(schema, type, fieldName, fieldAST) {\n  var rawType = schema.getRawType(type);\n\n  if (schema.isAbstractType(rawType) && fieldAST && fieldAST.directives && fieldAST.directives.some(function (directive) {\n    return getName(directive) === 'fixme_fat_interface';\n  })) {\n    var possibleTypes = schema.getPossibleTypes(schema.assertAbstractType(rawType));\n    var schemaFieldDef;\n\n    var _iterator = _createForOfIteratorHelper(possibleTypes),\n        _step;\n\n    try {\n      var _loop = function _loop() {\n        var possibleType = _step.value;\n        var possibleField = schema.getFieldByName(possibleType, fieldName);\n\n        if (possibleField) {\n          // Fat interface fields can have differing arguments. Try to return\n          // a field with matching arguments, but still return a field if the\n          // arguments do not match.\n          schemaFieldDef = possibleField;\n\n          if (fieldAST && fieldAST.arguments) {\n            var argumentsAllExist = fieldAST.arguments.every(function (argument) {\n              return schema.getFieldArgByName(possibleField, getName(argument)) != null;\n            });\n\n            if (argumentsAllExist) {\n              return \"break\";\n            }\n          }\n        }\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _ret = _loop();\n\n        if (_ret === \"break\") break;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return schemaFieldDef;\n  }\n}\n/**\n * @private\n */\n\n\nfunction getName(ast) {\n  var name = ast.name ? ast.name.value : null;\n\n  if (typeof name !== 'string') {\n    throw createCompilerError(\"Expected ast node to have a 'name'.\", null, [ast]);\n  }\n\n  return name;\n}\n\nmodule.exports = {\n  getFieldDefinitionLegacy: getFieldDefinitionLegacy,\n  getFieldDefinitionStrict: getFieldDefinitionStrict\n};"]},"metadata":{},"sourceType":"script"}