{"ast":null,"code":"import { parse, isNonNullType, GraphQLError, Kind, valueFromAST, print, isObjectType, isScalarType, isSpecifiedScalarType, isIntrospectionType, printType, specifiedRules, validate, buildSchema, Source, TokenKind, visit, isTypeSystemDefinitionNode, buildClientSchema, isListType, getNamedType, isEnumType, isUnionType, isInterfaceType, GraphQLString, GraphQLNonNull, GraphQLList, isInputObjectType, GraphQLID, GraphQLBoolean, GraphQLFloat, GraphQLInt, GraphQLObjectType, GraphQLInterfaceType, GraphQLInputObjectType, isSpecifiedDirective, GraphQLDirective, GraphQLUnionType, GraphQLEnumType, GraphQLScalarType, isNamedType, getNullableType, isLeafType, GraphQLSchema, isSchema, isInputType, valueFromASTUntyped, isDirective, getDirectiveValues as getDirectiveValues$1, GraphQLSkipDirective, GraphQLIncludeDirective, typeFromAST, isAbstractType, isCompositeType, doTypesOverlap, getOperationAST, getOperationRootType } from 'graphql';\nimport AggregateError from '@ardatan/aggregate-error';\nimport { camelCase } from 'camel-case';\n\nconst asArray = fns => Array.isArray(fns) ? fns : fns ? [fns] : [];\n\nfunction isEqual(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] !== b[index]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return a === b || !a && !b;\n}\n\nfunction isNotEqual(a, b) {\n  return !isEqual(a, b);\n}\n\nfunction isDocumentString(str) {\n  // XXX: is-valid-path or is-glob treat SDL as a valid path\n  // (`scalar Date` for example)\n  // this why checking the extension is fast enough\n  // and prevent from parsing the string in order to find out\n  // if the string is a SDL\n  if (/\\.[a-z0-9]+$/i.test(str)) {\n    return false;\n  }\n\n  try {\n    parse(str);\n    return true;\n  } catch (e) {}\n\n  return false;\n}\n\nconst invalidPathRegex = /[‘“!$%&^<=>`]/;\n\nfunction isValidPath(str) {\n  return typeof str === 'string' && !invalidPathRegex.test(str);\n}\n\nfunction compareStrings(a, b) {\n  if (a.toString() < b.toString()) {\n    return -1;\n  }\n\n  if (a.toString() > b.toString()) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction nodeToString(a) {\n  if ('alias' in a) {\n    return a.alias.value;\n  }\n\n  if ('name' in a) {\n    return a.name.value;\n  }\n\n  return a.kind;\n}\n\nfunction compareNodes(a, b, customFn) {\n  const aStr = nodeToString(a);\n  const bStr = nodeToString(b);\n\n  if (typeof customFn === 'function') {\n    return customFn(aStr, bStr);\n  }\n\n  return compareStrings(aStr, bStr);\n}\n\nfunction debugLog(...args) {\n  if (process && process.env && process.env.DEBUG && !process.env.GQL_tools_NODEBUG) {\n    // tslint:disable-next-line: no-console\n    console.log(...args);\n  }\n}\n\nconst fixWindowsPath = path => path.replace(/\\\\/g, '/');\n\nconst flattenArray = arr => arr.reduce((acc, next) => acc.concat(Array.isArray(next) ? flattenArray(next) : next), []);\n\nconst MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\n\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (typeof value) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? `[function ${value.name}]` : '[function]';\n\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  const seenValues = [...previouslySeenValues, value];\n  const customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    const customValue = customInspectFn.call(value); // check for infinite recursion\n\n    if (customValue !== value) {\n      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object, seenValues) {\n  const keys = Object.keys(object);\n\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  const properties = keys.map(key => {\n    const value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  const remaining = array.length - len;\n  const items = [];\n\n  for (let i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(`... ${remaining.toString(10)} more items`);\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(obj) {\n  if (typeof obj.inspect === 'function') {\n    return obj.inspect;\n  }\n}\n\nfunction getObjectTag(obj) {\n  const tag = Object.prototype.toString.call(obj).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof obj.constructor === 'function') {\n    const name = obj.constructor.name;\n\n    if (typeof name === 'string' && name !== '') {\n      return name;\n    }\n  }\n\n  return tag;\n}\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\n\n\nfunction getArgumentValues(def, node, variableValues = {}) {\n  var _a;\n\n  const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({ ...prev,\n    [key]: value\n  }), {});\n  const coercedValues = {}; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\n  const argNodeMap = argumentNodes.reduce((prev, arg) => ({ ...prev,\n    [arg.name.value]: arg\n  }), {});\n\n  for (const argDef of def.args) {\n    const name = argDef.name;\n    const argType = argDef.type;\n    const argumentNode = argNodeMap[name];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + 'was not provided.', node);\n      }\n\n      continue;\n    }\n\n    const valueNode = argumentNode.value;\n    let isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      const variableName = valueNode.name.value;\n\n      if (variableValues == null || !(variableName in variableMap)) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, valueNode);\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(`Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` + 'must not be null.', valueNode);\n    }\n\n    const coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(`Argument \"${name}\" has invalid value ${print(valueNode)}.`, valueNode);\n    }\n\n    coercedValues[name] = coercedValue;\n  }\n\n  return coercedValues;\n}\n\nfunction getDirectives(schema, node) {\n  const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n  const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap, schemaDirective) => {\n    schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n    return schemaDirectiveMap;\n  }, {});\n  let astNodes = [];\n\n  if (node.astNode) {\n    astNodes.push(node.astNode);\n  }\n\n  if ('extensionASTNodes' in node && node.extensionASTNodes) {\n    astNodes = [...astNodes, ...node.extensionASTNodes];\n  }\n\n  const result = {};\n  astNodes.forEach(astNode => {\n    if (astNode.directives) {\n      astNode.directives.forEach(directive => {\n        const schemaDirective = schemaDirectiveMap[directive.name.value];\n\n        if (schemaDirective) {\n          const directiveValue = getDirectiveValues(schemaDirective, astNode);\n\n          if (schemaDirective.isRepeatable) {\n            if (result[schemaDirective.name]) {\n              result[schemaDirective.name] = result[schemaDirective.name].concat([directiveValue]);\n            } else {\n              result[schemaDirective.name] = [directiveValue];\n            }\n          } else {\n            result[schemaDirective.name] = directiveValue;\n          }\n        }\n      });\n    }\n  });\n  return result;\n} // graphql-js getDirectiveValues does not handle repeatable directives\n\n\nfunction getDirectiveValues(directiveDef, node) {\n  if (node.directives) {\n    if (directiveDef.isRepeatable) {\n      const directiveNodes = node.directives.filter(directive => directive.name.value === directiveDef.name);\n      return directiveNodes.map(directiveNode => getArgumentValues(directiveDef, directiveNode));\n    }\n\n    const directiveNode = node.directives.find(directive => directive.name.value === directiveDef.name);\n    return getArgumentValues(directiveDef, directiveNode);\n  }\n}\n\nfunction parseDirectiveValue(value) {\n  switch (value.kind) {\n    case Kind.INT:\n      return parseInt(value.value);\n\n    case Kind.FLOAT:\n      return parseFloat(value.value);\n\n    case Kind.BOOLEAN:\n      return Boolean(value.value);\n\n    case Kind.STRING:\n    case Kind.ENUM:\n      return value.value;\n\n    case Kind.LIST:\n      return value.values.map(v => parseDirectiveValue(v));\n\n    case Kind.OBJECT:\n      return value.fields.reduce((prev, v) => ({ ...prev,\n        [v.name.value]: parseDirectiveValue(v.value)\n      }), {});\n\n    case Kind.NULL:\n      return null;\n\n    default:\n      return null;\n  }\n}\n\nfunction getFieldsWithDirectives(documentNode, options = {}) {\n  const result = {};\n  let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n\n  if (options.includeInputTypes) {\n    selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];\n  }\n\n  const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));\n\n  for (const type of allTypes) {\n    const typeName = type.name.value;\n\n    for (const field of type.fields) {\n      if (field.directives && field.directives.length > 0) {\n        const fieldName = field.name.value;\n        const key = `${typeName}.${fieldName}`;\n        const directives = field.directives.map(d => ({\n          name: d.name.value,\n          args: (d.arguments || []).reduce((prev, arg) => ({ ...prev,\n            [arg.name.value]: parseDirectiveValue(arg.value)\n          }), {})\n        }));\n        result[key] = directives;\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction getImplementingTypes(interfaceName, schema) {\n  const allTypesMap = schema.getTypeMap();\n  const result = [];\n\n  for (const graphqlTypeName in allTypesMap) {\n    const graphqlType = allTypesMap[graphqlTypeName];\n\n    if (isObjectType(graphqlType)) {\n      const allInterfaces = graphqlType.getInterfaces();\n\n      if (allInterfaces.find(int => int.name === interfaceName)) {\n        result.push(graphqlType.name);\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction createSchemaDefinition(def, config) {\n  const schemaRoot = {};\n\n  if (def.query) {\n    schemaRoot.query = def.query.toString();\n  }\n\n  if (def.mutation) {\n    schemaRoot.mutation = def.mutation.toString();\n  }\n\n  if (def.subscription) {\n    schemaRoot.subscription = def.subscription.toString();\n  }\n\n  const fields = Object.keys(schemaRoot).map(rootType => schemaRoot[rootType] ? `${rootType}: ${schemaRoot[rootType]}` : null).filter(a => a);\n\n  if (fields.length) {\n    return `schema { ${fields.join('\\n')} }`;\n  }\n\n  if (config && config.force) {\n    return ` schema { query: Query } `;\n  }\n\n  return undefined;\n}\n\nfunction printSchemaWithDirectives(schema, _options = {}) {\n  var _a;\n\n  const typesMap = schema.getTypeMap();\n  const result = [getSchemaDefinition(schema)];\n\n  for (const typeName in typesMap) {\n    const type = typesMap[typeName];\n    const isPredefinedScalar = isScalarType(type) && isSpecifiedScalarType(type);\n    const isIntrospection = isIntrospectionType(type);\n\n    if (isPredefinedScalar || isIntrospection) {\n      continue;\n    } // KAMIL: we might want to turn on descriptions in future\n\n\n    result.push(print((_a = correctType(typeName, typesMap)) === null || _a === void 0 ? void 0 : _a.astNode));\n  }\n\n  const directives = schema.getDirectives();\n\n  for (const directive of directives) {\n    if (directive.astNode) {\n      result.push(print(directive.astNode));\n    }\n  }\n\n  return result.join('\\n');\n}\n\nfunction extendDefinition(type) {\n  switch (type.astNode.kind) {\n    case Kind.OBJECT_TYPE_DEFINITION:\n      return { ...type.astNode,\n        fields: type.astNode.fields.concat(type.extensionASTNodes.reduce((fields, node) => fields.concat(node.fields), []))\n      };\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n      return { ...type.astNode,\n        fields: type.astNode.fields.concat(type.extensionASTNodes.reduce((fields, node) => fields.concat(node.fields), []))\n      };\n\n    default:\n      return type.astNode;\n  }\n}\n\nfunction correctType(typeName, typesMap) {\n  var _a;\n\n  const type = typesMap[typeName];\n  type.name = typeName.toString();\n\n  if (type.astNode && type.extensionASTNodes) {\n    type.astNode = type.extensionASTNodes ? extendDefinition(type) : type.astNode;\n  }\n\n  const doc = parse(printType(type));\n  const fixedAstNode = doc.definitions[0];\n  const originalAstNode = type === null || type === void 0 ? void 0 : type.astNode;\n\n  if (originalAstNode) {\n    fixedAstNode.directives = originalAstNode === null || originalAstNode === void 0 ? void 0 : originalAstNode.directives;\n\n    if (fixedAstNode && 'fields' in fixedAstNode && originalAstNode && 'fields' in originalAstNode) {\n      for (const fieldDefinitionNode of fixedAstNode.fields) {\n        const originalFieldDefinitionNode = originalAstNode.fields.find(field => field.name.value === fieldDefinitionNode.name.value);\n        fieldDefinitionNode.directives = originalFieldDefinitionNode === null || originalFieldDefinitionNode === void 0 ? void 0 : originalFieldDefinitionNode.directives;\n\n        if (fieldDefinitionNode && 'arguments' in fieldDefinitionNode && originalFieldDefinitionNode && 'arguments' in originalFieldDefinitionNode) {\n          for (const argument of fieldDefinitionNode.arguments) {\n            const originalArgumentNode = (_a = originalFieldDefinitionNode.arguments) === null || _a === void 0 ? void 0 : _a.find(arg => arg.name.value === argument.name.value);\n            argument.directives = originalArgumentNode.directives;\n          }\n        }\n      }\n    } else if (fixedAstNode && 'values' in fixedAstNode && originalAstNode && 'values' in originalAstNode) {\n      for (const valueDefinitionNode of fixedAstNode.values) {\n        const originalValueDefinitionNode = originalAstNode.values.find(valueNode => valueNode.name.value === valueDefinitionNode.name.value);\n        valueDefinitionNode.directives = originalValueDefinitionNode === null || originalValueDefinitionNode === void 0 ? void 0 : originalValueDefinitionNode.directives;\n      }\n    }\n  }\n\n  type.astNode = fixedAstNode;\n  return type;\n}\n\nfunction getSchemaDefinition(schema) {\n  if (!Object.getOwnPropertyDescriptor(schema, 'astNode').get && schema.astNode) {\n    return print(schema.astNode);\n  } else {\n    return createSchemaDefinition({\n      query: schema.getQueryType(),\n      mutation: schema.getMutationType(),\n      subscription: schema.getSubscriptionType()\n    });\n  }\n}\n\nasync function validateGraphQlDocuments(schema, documentFiles, effectiveRules) {\n  effectiveRules = effectiveRules || createDefaultRules();\n  const allFragments = [];\n  documentFiles.forEach(documentFile => {\n    if (documentFile.document) {\n      for (const definitionNode of documentFile.document.definitions) {\n        if (definitionNode.kind === Kind.FRAGMENT_DEFINITION) {\n          allFragments.push(definitionNode);\n        }\n      }\n    }\n  });\n  const allErrors = [];\n  await Promise.all(documentFiles.map(async documentFile => {\n    const documentToValidate = {\n      kind: Kind.DOCUMENT,\n      definitions: [...allFragments, ...documentFile.document.definitions].filter((definition, index, list) => {\n        if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n          const firstIndex = list.findIndex(def => def.kind === Kind.FRAGMENT_DEFINITION && def.name.value === definition.name.value);\n          const isDuplicated = firstIndex !== index;\n\n          if (isDuplicated) {\n            return false;\n          }\n        }\n\n        return true;\n      })\n    };\n    const errors = validate(schema, documentToValidate, effectiveRules);\n\n    if (errors.length > 0) {\n      allErrors.push({\n        filePath: documentFile.location,\n        errors\n      });\n    }\n  }));\n  return allErrors;\n}\n\nfunction checkValidationErrors(loadDocumentErrors) {\n  if (loadDocumentErrors.length > 0) {\n    const errors = [];\n\n    for (const loadDocumentError of loadDocumentErrors) {\n      for (const graphQLError of loadDocumentError.errors) {\n        const error = new Error();\n        error.name = 'GraphQLDocumentError';\n        error.message = `${error.name}: ${graphQLError.message}`;\n        error.stack = error.message;\n        graphQLError.locations.forEach(location => error.stack += `\\n    at ${loadDocumentError.filePath}:${location.line}:${location.column}`);\n        errors.push(error);\n      }\n    }\n\n    throw new AggregateError(errors);\n  }\n}\n\nfunction createDefaultRules() {\n  const ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule']; // GraphQL v14 has no Rule suffix in function names\n  // Adding `*Rule` makes validation backwards compatible\n\n  ignored.forEach(rule => {\n    ignored.push(rule.replace(/Rule$/, ''));\n  });\n  return specifiedRules.filter(f => !ignored.includes(f.name));\n}\n\nfunction buildFixedSchema(schema, options) {\n  return buildSchema(printSchemaWithDirectives(schema, options), {\n    noLocation: true,\n    ...(options || {})\n  });\n}\n\nfunction fixSchemaAst(schema, options) {\n  let schemaWithValidAst;\n\n  if (!schema.astNode) {\n    Object.defineProperty(schema, 'astNode', {\n      get() {\n        if (!schemaWithValidAst) {\n          schemaWithValidAst = buildFixedSchema(schema, options);\n        }\n\n        return schemaWithValidAst.astNode;\n      }\n\n    });\n  }\n\n  if (!schema.extensionASTNodes) {\n    Object.defineProperty(schema, 'extensionASTNodes', {\n      get() {\n        if (!schemaWithValidAst) {\n          schemaWithValidAst = buildFixedSchema(schema, options);\n        }\n\n        return schemaWithValidAst.extensionASTNodes;\n      }\n\n    });\n  }\n\n  return schema;\n}\n/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\n\n\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\n\n\nfunction getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n\nfunction parseGraphQLSDL(location, rawSDL, options = {}) {\n  let document;\n  const sdl = rawSDL;\n  let sdlModified = false;\n\n  try {\n    if (options.commentDescriptions && sdl.includes('#')) {\n      sdlModified = true;\n      document = transformCommentsToDescriptions(rawSDL, options); // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n      // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n      // into descriptions.\n\n      if (options.noLocation) {\n        document = parse(print(document), options);\n      }\n    } else {\n      document = parse(new Source(sdl, location), options);\n    }\n  } catch (e) {\n    if (e.message.includes('EOF')) {\n      document = {\n        kind: Kind.DOCUMENT,\n        definitions: []\n      };\n    } else {\n      throw e;\n    }\n  }\n\n  return {\n    location,\n    document,\n    rawSDL: sdlModified ? print(document) : sdl\n  };\n}\n\nfunction getLeadingCommentBlock(node) {\n  const loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  const comments = [];\n  let token = loc.startToken.prev;\n\n  while (token != null && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    const value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n\nfunction transformCommentsToDescriptions(sourceSdl, options = {}) {\n  const parsedDoc = parse(sourceSdl, { ...options,\n    noLocation: false\n  });\n  const modifiedDoc = visit(parsedDoc, {\n    leave: node => {\n      if (isDescribable(node)) {\n        const rawValue = getLeadingCommentBlock(node);\n\n        if (rawValue !== undefined) {\n          const commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n          const isBlock = commentsBlock.includes('\\n');\n\n          if (!node.description) {\n            return { ...node,\n              description: {\n                kind: Kind.STRING,\n                value: commentsBlock,\n                block: isBlock\n              }\n            };\n          } else {\n            return { ...node,\n              description: { ...node.description,\n                value: node.description.value + '\\n' + commentsBlock,\n                block: true\n              }\n            };\n          }\n        }\n      }\n    }\n  });\n  return modifiedDoc;\n}\n\nfunction isDescribable(node) {\n  return isTypeSystemDefinitionNode(node) || node.kind === Kind.FIELD_DEFINITION || node.kind === Kind.INPUT_VALUE_DEFINITION || node.kind === Kind.ENUM_VALUE_DEFINITION;\n}\n\nfunction stripBOM(content) {\n  content = content.toString(); // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n  // because the buffer-to-string conversion in `fs.readFileSync()`\n  // translates it to FEFF, the UTF-16 BOM.\n\n  if (content.charCodeAt(0) === 0xfeff) {\n    content = content.slice(1);\n  }\n\n  return content;\n}\n\nfunction parseBOM(content) {\n  return JSON.parse(stripBOM(content));\n}\n\nfunction parseGraphQLJSON(location, jsonContent, options) {\n  let parsedJson = parseBOM(jsonContent);\n\n  if (parsedJson.data) {\n    parsedJson = parsedJson.data;\n  }\n\n  if (parsedJson.kind === 'Document') {\n    const document = parsedJson;\n    return {\n      location,\n      document\n    };\n  } else if (parsedJson.__schema) {\n    const schema = buildClientSchema(parsedJson, options);\n    const rawSDL = printSchemaWithDirectives(schema, options);\n    return {\n      location,\n      document: parseGraphQLSDL(location, rawSDL, options).document,\n      rawSDL,\n      schema\n    };\n  }\n\n  throw new Error(`Not valid JSON content`);\n}\n/**\n * Get all GraphQL types from schema without:\n *\n * - Query, Mutation, Subscription objects\n * - Internal scalars added by parser\n *\n * @param schema\n */\n\n\nfunction getUserTypesFromSchema(schema) {\n  const allTypesMap = schema.getTypeMap(); // tslint:disable-next-line: no-unnecessary-local-variable\n\n  const modelTypes = Object.values(allTypesMap).filter(graphqlType => {\n    if (isObjectType(graphqlType)) {\n      // Filter out private types\n      if (graphqlType.name.startsWith('__')) {\n        return false;\n      }\n\n      if (schema.getMutationType() && graphqlType.name === schema.getMutationType().name) {\n        return false;\n      }\n\n      if (schema.getQueryType() && graphqlType.name === schema.getQueryType().name) {\n        return false;\n      }\n\n      if (schema.getSubscriptionType() && graphqlType.name === schema.getSubscriptionType().name) {\n        return false;\n      }\n\n      return true;\n    }\n\n    return false;\n  });\n  return modelTypes;\n}\n\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\n\nfunction addOperationVariable(variable) {\n  operationVariables.push(variable);\n}\n\nfunction resetOperationVariables() {\n  operationVariables = [];\n}\n\nfunction resetFieldMap() {\n  fieldTypeMap = new Map();\n}\n\nfunction buildOperationName(name) {\n  return camelCase(name);\n}\n\nfunction buildOperationNodeForField({\n  schema,\n  kind,\n  field,\n  models,\n  ignore,\n  depthLimit,\n  circularReferenceDepth,\n  argNames,\n  selectedFields = true\n}) {\n  resetOperationVariables();\n  resetFieldMap();\n  const operationNode = buildOperationAndCollectVariables({\n    schema,\n    fieldName: field,\n    kind,\n    models: models || [],\n    ignore: ignore || [],\n    depthLimit: depthLimit || Infinity,\n    circularReferenceDepth: circularReferenceDepth || 1,\n    argNames,\n    selectedFields\n  }); // attach variables\n\n  operationNode.variableDefinitions = [...operationVariables];\n  resetOperationVariables();\n  resetFieldMap();\n  return operationNode;\n}\n\nfunction buildOperationAndCollectVariables({\n  schema,\n  fieldName,\n  kind,\n  models,\n  ignore,\n  depthLimit,\n  circularReferenceDepth,\n  argNames,\n  selectedFields\n}) {\n  const typeMap = {\n    query: schema.getQueryType(),\n    mutation: schema.getMutationType(),\n    subscription: schema.getSubscriptionType()\n  };\n  const type = typeMap[kind];\n  const field = type.getFields()[fieldName];\n  const operationName = buildOperationName(`${fieldName}_${kind}`);\n\n  if (field.args) {\n    field.args.forEach(arg => {\n      const argName = arg.name;\n\n      if (!argNames || argNames.includes(argName)) {\n        addOperationVariable(resolveVariable(arg, argName));\n      }\n    });\n  }\n\n  return {\n    kind: Kind.OPERATION_DEFINITION,\n    operation: kind,\n    name: {\n      kind: 'Name',\n      value: operationName\n    },\n    variableDefinitions: [],\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: [resolveField({\n        type,\n        field,\n        models,\n        firstCall: true,\n        path: [],\n        ancestors: [],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: 0,\n        argNames,\n        selectedFields\n      })]\n    }\n  };\n}\n\nfunction resolveSelectionSet({\n  parent,\n  type,\n  models,\n  firstCall,\n  path,\n  ancestors,\n  ignore,\n  depthLimit,\n  circularReferenceDepth,\n  schema,\n  depth,\n  argNames,\n  selectedFields\n}) {\n  if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n    return;\n  }\n\n  if (isUnionType(type)) {\n    const types = type.getTypes();\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n\n  if (isInterfaceType(type)) {\n    const types = Object.values(schema.getTypeMap()).filter(t => isObjectType(t) && t.getInterfaces().includes(type));\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: types.filter(t => !hasCircularRef([...ancestors, t], {\n        depth: circularReferenceDepth\n      })).map(t => {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: t.name\n            }\n          },\n          selectionSet: resolveSelectionSet({\n            parent: type,\n            type: t,\n            models,\n            path,\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields\n          })\n        };\n      }).filter(fragmentNode => {\n        var _a, _b;\n\n        return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0;\n      })\n    };\n  }\n\n  if (isObjectType(type)) {\n    const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n    const isModel = models.includes(type.name);\n\n    if (!firstCall && isModel && !isIgnored) {\n      return {\n        kind: Kind.SELECTION_SET,\n        selections: [{\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: 'id'\n          }\n        }]\n      };\n    }\n\n    const fields = type.getFields();\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: Object.keys(fields).filter(fieldName => {\n        return !hasCircularRef([...ancestors, getNamedType(fields[fieldName].type)], {\n          depth: circularReferenceDepth\n        });\n      }).map(fieldName => {\n        const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n\n        if (selectedSubFields) {\n          return resolveField({\n            type: type,\n            field: fields[fieldName],\n            models,\n            path: [...path, fieldName],\n            ancestors,\n            ignore,\n            depthLimit,\n            circularReferenceDepth,\n            schema,\n            depth,\n            argNames,\n            selectedFields: selectedSubFields\n          });\n        }\n      }).filter(f => {\n        var _a, _b;\n\n        if (f) {\n          if ('selectionSet' in f) {\n            return (_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length;\n          } else {\n            return true;\n          }\n        }\n\n        return false;\n      })\n    };\n  }\n}\n\nfunction resolveVariable(arg, name) {\n  function resolveVariableType(type) {\n    if (isListType(type)) {\n      return {\n        kind: Kind.LIST_TYPE,\n        type: resolveVariableType(type.ofType)\n      };\n    }\n\n    if (isNonNullType(type)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: resolveVariableType(type.ofType)\n      };\n    }\n\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: {\n        kind: Kind.NAME,\n        value: type.name\n      }\n    };\n  }\n\n  return {\n    kind: Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: name || arg.name\n      }\n    },\n    type: resolveVariableType(arg.type)\n  };\n}\n\nfunction getArgumentName(name, path) {\n  return camelCase([...path, name].join('_'));\n}\n\nfunction resolveField({\n  type,\n  field,\n  models,\n  firstCall,\n  path,\n  ancestors,\n  ignore,\n  depthLimit,\n  circularReferenceDepth,\n  schema,\n  depth,\n  argNames,\n  selectedFields\n}) {\n  const namedType = getNamedType(field.type);\n  let args = [];\n  let removeField = false;\n\n  if (field.args && field.args.length) {\n    args = field.args.map(arg => {\n      const argumentName = getArgumentName(arg.name, path);\n\n      if (argNames && !argNames.includes(argumentName)) {\n        if (isNonNullType(arg.type)) {\n          removeField = true;\n        }\n\n        return null;\n      }\n\n      if (!firstCall) {\n        addOperationVariable(resolveVariable(arg, argumentName));\n      }\n\n      return {\n        kind: Kind.ARGUMENT,\n        name: {\n          kind: Kind.NAME,\n          value: arg.name\n        },\n        value: {\n          kind: Kind.VARIABLE,\n          name: {\n            kind: Kind.NAME,\n            value: getArgumentName(arg.name, path)\n          }\n        }\n      };\n    }).filter(Boolean);\n  }\n\n  if (removeField) {\n    return null;\n  }\n\n  const fieldPath = [...path, field.name];\n  const fieldPathStr = fieldPath.join('.');\n  let fieldName = field.name;\n\n  if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n    fieldName += field.type.toString().replace('!', 'NonNull');\n  }\n\n  fieldTypeMap.set(fieldPathStr, field.type.toString());\n\n  if (!isScalarType(namedType) && !isEnumType(namedType)) {\n    return {\n      kind: Kind.FIELD,\n      name: {\n        kind: Kind.NAME,\n        value: field.name\n      },\n      ...(fieldName !== field.name && {\n        alias: {\n          kind: Kind.NAME,\n          value: fieldName\n        }\n      }),\n      selectionSet: resolveSelectionSet({\n        parent: type,\n        type: namedType,\n        models,\n        firstCall,\n        path: fieldPath,\n        ancestors: [...ancestors, type],\n        ignore,\n        depthLimit,\n        circularReferenceDepth,\n        schema,\n        depth: depth + 1,\n        argNames,\n        selectedFields\n      }) || undefined,\n      arguments: args\n    };\n  }\n\n  return {\n    kind: Kind.FIELD,\n    name: {\n      kind: Kind.NAME,\n      value: field.name\n    },\n    ...(fieldName !== field.name && {\n      alias: {\n        kind: Kind.NAME,\n        value: fieldName\n      }\n    }),\n    arguments: args\n  };\n}\n\nfunction hasCircularRef(types, config = {\n  depth: 1\n}) {\n  const type = types[types.length - 1];\n\n  if (isScalarType(type)) {\n    return false;\n  }\n\n  const size = types.filter(t => t.name === type.name).length;\n  return size > config.depth;\n}\n\nvar VisitSchemaKind;\n\n(function (VisitSchemaKind) {\n  VisitSchemaKind[\"TYPE\"] = \"VisitSchemaKind.TYPE\";\n  VisitSchemaKind[\"SCALAR_TYPE\"] = \"VisitSchemaKind.SCALAR_TYPE\";\n  VisitSchemaKind[\"ENUM_TYPE\"] = \"VisitSchemaKind.ENUM_TYPE\";\n  VisitSchemaKind[\"COMPOSITE_TYPE\"] = \"VisitSchemaKind.COMPOSITE_TYPE\";\n  VisitSchemaKind[\"OBJECT_TYPE\"] = \"VisitSchemaKind.OBJECT_TYPE\";\n  VisitSchemaKind[\"INPUT_OBJECT_TYPE\"] = \"VisitSchemaKind.INPUT_OBJECT_TYPE\";\n  VisitSchemaKind[\"ABSTRACT_TYPE\"] = \"VisitSchemaKind.ABSTRACT_TYPE\";\n  VisitSchemaKind[\"UNION_TYPE\"] = \"VisitSchemaKind.UNION_TYPE\";\n  VisitSchemaKind[\"INTERFACE_TYPE\"] = \"VisitSchemaKind.INTERFACE_TYPE\";\n  VisitSchemaKind[\"ROOT_OBJECT\"] = \"VisitSchemaKind.ROOT_OBJECT\";\n  VisitSchemaKind[\"QUERY\"] = \"VisitSchemaKind.QUERY\";\n  VisitSchemaKind[\"MUTATION\"] = \"VisitSchemaKind.MUTATION\";\n  VisitSchemaKind[\"SUBSCRIPTION\"] = \"VisitSchemaKind.SUBSCRIPTION\";\n})(VisitSchemaKind || (VisitSchemaKind = {}));\n\nvar MapperKind;\n\n(function (MapperKind) {\n  MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n  MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n  MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n  MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n  MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n  MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n  MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n  MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n  MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n  MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n  MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n  MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n  MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n  MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n  MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n  MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n  MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n  MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n  MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n  MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n  MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n  MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n  MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n  MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n  MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(MapperKind || (MapperKind = {}));\n\nfunction createNamedStub(name, type) {\n  let constructor;\n\n  if (type === 'object') {\n    constructor = GraphQLObjectType;\n  } else if (type === 'interface') {\n    constructor = GraphQLInterfaceType;\n  } else {\n    constructor = GraphQLInputObjectType;\n  }\n\n  return new constructor({\n    name,\n    fields: {\n      __fake: {\n        type: GraphQLString\n      }\n    }\n  });\n}\n\nfunction createStub(node, type) {\n  switch (node.kind) {\n    case Kind.LIST_TYPE:\n      return new GraphQLList(createStub(node.type, type));\n\n    case Kind.NON_NULL_TYPE:\n      return new GraphQLNonNull(createStub(node.type, type));\n\n    default:\n      if (type === 'output') {\n        return createNamedStub(node.name.value, 'object');\n      }\n\n      return createNamedStub(node.name.value, 'input');\n  }\n}\n\nfunction isNamedStub(type) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    const fields = type.getFields();\n    const fieldNames = Object.keys(fields);\n    return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';\n  }\n\n  return false;\n}\n\nfunction getBuiltInForStub(type) {\n  switch (type.name) {\n    case GraphQLInt.name:\n      return GraphQLInt;\n\n    case GraphQLFloat.name:\n      return GraphQLFloat;\n\n    case GraphQLString.name:\n      return GraphQLString;\n\n    case GraphQLBoolean.name:\n      return GraphQLBoolean;\n\n    case GraphQLID.name:\n      return GraphQLID;\n\n    default:\n      return type;\n  }\n}\n\nfunction rewireTypes(originalTypeMap, directives, options = {\n  skipPruning: false\n}) {\n  const referenceTypeMap = Object.create(null);\n  Object.keys(originalTypeMap).forEach(typeName => {\n    referenceTypeMap[typeName] = originalTypeMap[typeName];\n  });\n  const newTypeMap = Object.create(null);\n  Object.keys(referenceTypeMap).forEach(typeName => {\n    const namedType = referenceTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      return;\n    }\n\n    const newName = namedType.name;\n\n    if (newName.startsWith('__')) {\n      return;\n    }\n\n    if (newTypeMap[newName] != null) {\n      throw new Error(`Duplicate schema type name ${newName}`);\n    }\n\n    newTypeMap[newName] = namedType;\n  });\n  Object.keys(newTypeMap).forEach(typeName => {\n    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n  });\n  const newDirectives = directives.map(directive => rewireDirective(directive)); // TODO:\n  // consider removing the default level of pruning in v7,\n  // see comments below on the pruneTypes function.\n\n  return options.skipPruning ? {\n    typeMap: newTypeMap,\n    directives: newDirectives\n  } : pruneTypes(newTypeMap, newDirectives);\n\n  function rewireDirective(directive) {\n    if (isSpecifiedDirective(directive)) {\n      return directive;\n    }\n\n    const directiveConfig = directive.toConfig();\n    directiveConfig.args = rewireArgs(directiveConfig.args);\n    return new GraphQLDirective(directiveConfig);\n  }\n\n  function rewireArgs(args) {\n    const rewiredArgs = {};\n    Object.keys(args).forEach(argName => {\n      const arg = args[argName];\n      const rewiredArgType = rewireType(arg.type);\n\n      if (rewiredArgType != null) {\n        arg.type = rewiredArgType;\n        rewiredArgs[argName] = arg;\n      }\n    });\n    return rewiredArgs;\n  }\n\n  function rewireNamedType(type) {\n    if (isObjectType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireFields(config.fields),\n        interfaces: () => rewireNamedTypes(config.interfaces)\n      };\n      return new GraphQLObjectType(newConfig);\n    } else if (isInterfaceType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireFields(config.fields)\n      };\n\n      if ('interfaces' in newConfig) {\n        newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n      }\n\n      return new GraphQLInterfaceType(newConfig);\n    } else if (isUnionType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        types: () => rewireNamedTypes(config.types)\n      };\n      return new GraphQLUnionType(newConfig);\n    } else if (isInputObjectType(type)) {\n      const config = type.toConfig();\n      const newConfig = { ...config,\n        fields: () => rewireInputFields(config.fields)\n      };\n      return new GraphQLInputObjectType(newConfig);\n    } else if (isEnumType(type)) {\n      const enumConfig = type.toConfig();\n      return new GraphQLEnumType(enumConfig);\n    } else if (isScalarType(type)) {\n      if (isSpecifiedScalarType(type)) {\n        return type;\n      }\n\n      const scalarConfig = type.toConfig();\n      return new GraphQLScalarType(scalarConfig);\n    }\n\n    throw new Error(`Unexpected schema type: ${type}`);\n  }\n\n  function rewireFields(fields) {\n    const rewiredFields = {};\n    Object.keys(fields).forEach(fieldName => {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        field.args = rewireArgs(field.args);\n        rewiredFields[fieldName] = field;\n      }\n    });\n    return rewiredFields;\n  }\n\n  function rewireInputFields(fields) {\n    const rewiredFields = {};\n    Object.keys(fields).forEach(fieldName => {\n      const field = fields[fieldName];\n      const rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        rewiredFields[fieldName] = field;\n      }\n    });\n    return rewiredFields;\n  }\n\n  function rewireNamedTypes(namedTypes) {\n    const rewiredTypes = [];\n    namedTypes.forEach(namedType => {\n      const rewiredType = rewireType(namedType);\n\n      if (rewiredType != null) {\n        rewiredTypes.push(rewiredType);\n      }\n    });\n    return rewiredTypes;\n  }\n\n  function rewireType(type) {\n    if (isListType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new GraphQLList(rewiredType) : null;\n    } else if (isNonNullType(type)) {\n      const rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;\n    } else if (isNamedType(type)) {\n      let rewiredType = referenceTypeMap[type.name];\n\n      if (rewiredType === undefined) {\n        rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n        newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n      }\n\n      return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n    }\n\n    return null;\n  }\n} // TODO:\n// consider removing the default level of pruning in v7\n//\n// Pruning during mapSchema limits the ability to create an unpruned schema, which may be of use\n// to some library users. pruning is now recommended via the dedicated pruneSchema function\n// which does not force pruning on library users and gives granular control in terms of pruning\n// types.\n\n\nfunction pruneTypes(typeMap, directives) {\n  const newTypeMap = {};\n  const implementedInterfaces = {};\n  Object.keys(typeMap).forEach(typeName => {\n    const namedType = typeMap[typeName];\n\n    if ('getInterfaces' in namedType) {\n      namedType.getInterfaces().forEach(iface => {\n        implementedInterfaces[iface.name] = true;\n      });\n    }\n  });\n  let prunedTypeMap = false;\n  const typeNames = Object.keys(typeMap);\n\n  for (let i = 0; i < typeNames.length; i++) {\n    const typeName = typeNames[i];\n    const type = typeMap[typeName];\n\n    if (isObjectType(type) || isInputObjectType(type)) {\n      // prune types with no fields\n      if (Object.keys(type.getFields()).length) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else if (isUnionType(type)) {\n      // prune unions without underlying types\n      if (type.getTypes().length) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else if (isInterfaceType(type)) {\n      // prune interfaces without fields or without implementations\n      if (Object.keys(type.getFields()).length && implementedInterfaces[type.name]) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else {\n      newTypeMap[typeName] = type;\n    }\n  } // every prune requires another round of healing\n\n\n  return prunedTypeMap ? rewireTypes(newTypeMap, directives) : {\n    typeMap,\n    directives\n  };\n}\n\nfunction transformInputValue(type, value, transformer) {\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = getNullableType(type);\n\n  if (isLeafType(nullableType)) {\n    return transformer(nullableType, value);\n  } else if (isListType(nullableType)) {\n    return value.map(listMember => transformInputValue(nullableType.ofType, listMember, transformer));\n  } else if (isInputObjectType(nullableType)) {\n    const fields = nullableType.getFields();\n    const newValue = {};\n    Object.keys(value).forEach(key => {\n      newValue[key] = transformInputValue(fields[key].type, value[key], transformer);\n    });\n    return newValue;\n  } // unreachable, no other possible return value\n\n}\n\nfunction serializeInputValue(type, value) {\n  return transformInputValue(type, value, (t, v) => t.serialize(v));\n}\n\nfunction parseInputValue(type, value) {\n  return transformInputValue(type, value, (t, v) => t.parseValue(v));\n}\n\nfunction parseInputValueLiteral(type, value) {\n  return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n\nfunction mapSchema(schema, schemaMapper = {}) {\n  const originalTypeMap = schema.getTypeMap();\n  let newTypeMap = mapDefaultValues(originalTypeMap, schema, serializeInputValue);\n  newTypeMap = mapTypes(newTypeMap, schema, schemaMapper, type => isLeafType(type));\n  newTypeMap = mapEnumValues(newTypeMap, schema, schemaMapper);\n  newTypeMap = mapDefaultValues(newTypeMap, schema, parseInputValue);\n  newTypeMap = mapTypes(newTypeMap, schema, schemaMapper, type => !isLeafType(type));\n  newTypeMap = mapFields(newTypeMap, schema, schemaMapper);\n  newTypeMap = mapArguments(newTypeMap, schema, schemaMapper);\n  const originalDirectives = schema.getDirectives();\n  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n  const queryType = schema.getQueryType();\n  const mutationType = schema.getMutationType();\n  const subscriptionType = schema.getSubscriptionType();\n  const newQueryTypeName = queryType != null ? newTypeMap[queryType.name] != null ? newTypeMap[queryType.name].name : undefined : undefined;\n  const newMutationTypeName = mutationType != null ? newTypeMap[mutationType.name] != null ? newTypeMap[mutationType.name].name : undefined : undefined;\n  const newSubscriptionTypeName = subscriptionType != null ? newTypeMap[subscriptionType.name] != null ? newTypeMap[subscriptionType.name].name : undefined : undefined;\n  const {\n    typeMap,\n    directives\n  } = rewireTypes(newTypeMap, newDirectives);\n  return new GraphQLSchema({ ...schema.toConfig(),\n    query: newQueryTypeName ? typeMap[newQueryTypeName] : undefined,\n    mutation: newMutationTypeName ? typeMap[newMutationTypeName] : undefined,\n    subscription: newSubscriptionTypeName != null ? typeMap[newSubscriptionTypeName] : undefined,\n    types: Object.keys(typeMap).map(typeName => typeMap[typeName]),\n    directives\n  });\n}\n\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {\n  const newTypeMap = {};\n  Object.keys(originalTypeMap).forEach(typeName => {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (originalType == null || !testFn(originalType)) {\n        newTypeMap[typeName] = originalType;\n        return;\n      }\n\n      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n\n      if (typeMapper == null) {\n        newTypeMap[typeName] = originalType;\n        return;\n      }\n\n      const maybeNewType = typeMapper(originalType, schema);\n\n      if (maybeNewType === undefined) {\n        newTypeMap[typeName] = originalType;\n        return;\n      }\n\n      newTypeMap[typeName] = maybeNewType;\n    }\n  });\n  return newTypeMap;\n}\n\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n  const enumValueMapper = getEnumValueMapper(schemaMapper);\n\n  if (!enumValueMapper) {\n    return originalTypeMap;\n  }\n\n  return mapTypes(originalTypeMap, schema, {\n    [MapperKind.ENUM_TYPE]: type => {\n      const config = type.toConfig();\n      const originalEnumValueConfigMap = config.values;\n      const newEnumValueConfigMap = {};\n      Object.keys(originalEnumValueConfigMap).forEach(externalValue => {\n        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n\n        if (mappedEnumValue === undefined) {\n          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n        } else if (Array.isArray(mappedEnumValue)) {\n          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n        } else if (mappedEnumValue !== null) {\n          newEnumValueConfigMap[externalValue] = mappedEnumValue;\n        }\n      });\n      return correctASTNodes(new GraphQLEnumType({ ...config,\n        values: newEnumValueConfigMap\n      }));\n    }\n  }, type => isEnumType(type));\n}\n\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n  const newTypeMap = mapArguments(originalTypeMap, schema, {\n    [MapperKind.ARGUMENT]: argumentConfig => {\n      if (argumentConfig.defaultValue === undefined) {\n        return argumentConfig;\n      }\n\n      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n\n      if (maybeNewType != null) {\n        return { ...argumentConfig,\n          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)\n        };\n      }\n    }\n  });\n  return mapFields(newTypeMap, schema, {\n    [MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n      if (inputFieldConfig.defaultValue === undefined) {\n        return inputFieldConfig;\n      }\n\n      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n\n      if (maybeNewType != null) {\n        return { ...inputFieldConfig,\n          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)\n        };\n      }\n    }\n  });\n}\n\nfunction getNewType(newTypeMap, type) {\n  if (isListType(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new GraphQLList(newType) : null;\n  } else if (isNonNullType(type)) {\n    const newType = getNewType(newTypeMap, type.ofType);\n    return newType != null ? new GraphQLNonNull(newType) : null;\n  } else if (isNamedType(type)) {\n    const newType = newTypeMap[type.name];\n    return newType != null ? newType : null;\n  }\n\n  return null;\n}\n\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n  Object.keys(originalTypeMap).forEach(typeName => {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        return;\n      }\n\n      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n\n      if (fieldMapper == null) {\n        newTypeMap[typeName] = originalType;\n        return;\n      }\n\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n      Object.keys(originalFieldConfigMap).forEach(fieldName => {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n\n        if (mappedField === undefined) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n        } else if (Array.isArray(mappedField)) {\n          const [newFieldName, newFieldConfig] = mappedField;\n\n          if (newFieldConfig.astNode != null) {\n            newFieldConfig.astNode = { ...newFieldConfig.astNode,\n              name: { ...newFieldConfig.astNode.name,\n                value: newFieldName\n              }\n            };\n          }\n\n          newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n        } else if (mappedField !== null) {\n          newFieldConfigMap[fieldName] = mappedField;\n        }\n      });\n\n      if (isObjectType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      } else if (isInterfaceType(originalType)) {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      } else {\n        newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n  return newTypeMap;\n}\n\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n  const newTypeMap = {};\n  Object.keys(originalTypeMap).forEach(typeName => {\n    if (!typeName.startsWith('__')) {\n      const originalType = originalTypeMap[typeName];\n\n      if (!isObjectType(originalType) && !isInterfaceType(originalType)) {\n        newTypeMap[typeName] = originalType;\n        return;\n      }\n\n      const argumentMapper = getArgumentMapper(schemaMapper);\n\n      if (argumentMapper == null) {\n        newTypeMap[typeName] = originalType;\n        return;\n      }\n\n      const config = originalType.toConfig();\n      const originalFieldConfigMap = config.fields;\n      const newFieldConfigMap = {};\n      Object.keys(originalFieldConfigMap).forEach(fieldName => {\n        const originalFieldConfig = originalFieldConfigMap[fieldName];\n        const originalArgumentConfigMap = originalFieldConfig.args;\n\n        if (originalArgumentConfigMap == null) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          return;\n        }\n\n        const argumentNames = Object.keys(originalArgumentConfigMap);\n\n        if (!argumentNames.length) {\n          newFieldConfigMap[fieldName] = originalFieldConfig;\n          return;\n        }\n\n        const newArgumentConfigMap = {};\n        argumentNames.forEach(argumentName => {\n          const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n\n          if (mappedArgument === undefined) {\n            newArgumentConfigMap[argumentName] = originalArgumentConfig;\n          } else if (Array.isArray(mappedArgument)) {\n            const [newArgumentName, newArgumentConfig] = mappedArgument;\n            newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n          } else if (mappedArgument !== null) {\n            newArgumentConfigMap[argumentName] = mappedArgument;\n          }\n        });\n        newFieldConfigMap[fieldName] = { ...originalFieldConfig,\n          args: newArgumentConfigMap\n        };\n      });\n\n      if (isObjectType(originalType)) {\n        newTypeMap[typeName] = new GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        });\n      } else if (isInterfaceType(originalType)) {\n        newTypeMap[typeName] = new GraphQLInterfaceType({ ...config,\n          fields: newFieldConfigMap\n        });\n      } else {\n        newTypeMap[typeName] = new GraphQLInputObjectType({ ...config,\n          fields: newFieldConfigMap\n        });\n      }\n    }\n  });\n  return newTypeMap;\n}\n\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n  const directiveMapper = getDirectiveMapper(schemaMapper);\n\n  if (directiveMapper == null) {\n    return originalDirectives.slice();\n  }\n\n  const newDirectives = [];\n  originalDirectives.forEach(directive => {\n    const mappedDirective = directiveMapper(directive, schema);\n\n    if (mappedDirective === undefined) {\n      newDirectives.push(directive);\n    } else if (mappedDirective !== null) {\n      newDirectives.push(mappedDirective);\n    }\n  });\n  return newDirectives;\n}\n\nfunction getTypeSpecifiers(schema, typeName) {\n  const type = schema.getType(typeName);\n  const specifiers = [MapperKind.TYPE];\n\n  if (isObjectType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n    const query = schema.getQueryType();\n    const mutation = schema.getMutationType();\n    const subscription = schema.getSubscriptionType();\n\n    if (query != null && typeName === query.name) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n    } else if (mutation != null && typeName === mutation.name) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n    } else if (subscription != null && typeName === subscription.name) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n    }\n  } else if (isInputObjectType(type)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n  } else if (isUnionType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n  } else if (isEnumType(type)) {\n    specifiers.push(MapperKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(MapperKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n  const specifiers = getTypeSpecifiers(schema, typeName);\n  let typeMapper;\n  const stack = [...specifiers];\n\n  while (!typeMapper && stack.length > 0) {\n    const next = stack.pop();\n    typeMapper = schemaMapper[next];\n  }\n\n  return typeMapper != null ? typeMapper : null;\n}\n\nfunction getFieldSpecifiers(schema, typeName) {\n  const type = schema.getType(typeName);\n  const specifiers = [MapperKind.FIELD];\n\n  if (isObjectType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);\n    const query = schema.getQueryType();\n    const mutation = schema.getMutationType();\n    const subscription = schema.getSubscriptionType();\n\n    if (query != null && typeName === query.name) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);\n    } else if (mutation != null && typeName === mutation.name) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);\n    } else if (subscription != null && typeName === subscription.name) {\n      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);\n    }\n  } else if (isInterfaceType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);\n  } else if (isInputObjectType(type)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);\n  }\n\n  return specifiers;\n}\n\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n  const specifiers = getFieldSpecifiers(schema, typeName);\n  let fieldMapper;\n  const stack = [...specifiers];\n\n  while (!fieldMapper && stack.length > 0) {\n    const next = stack.pop();\n    fieldMapper = schemaMapper[next];\n  }\n\n  return fieldMapper != null ? fieldMapper : null;\n}\n\nfunction getArgumentMapper(schemaMapper) {\n  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];\n  return argumentMapper != null ? argumentMapper : null;\n}\n\nfunction getDirectiveMapper(schemaMapper) {\n  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n  return directiveMapper != null ? directiveMapper : null;\n}\n\nfunction getEnumValueMapper(schemaMapper) {\n  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];\n  return enumValueMapper != null ? enumValueMapper : null;\n}\n\nfunction correctASTNodes(type) {\n  if (isObjectType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n      Object.values(config.fields).forEach(fieldConfig => {\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      });\n      config.astNode = { ...config.astNode,\n        kind: Kind.OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: Kind.OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new GraphQLObjectType(config);\n  } else if (isInterfaceType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n      Object.values(config.fields).forEach(fieldConfig => {\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      });\n      config.astNode = { ...config.astNode,\n        kind: Kind.INTERFACE_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: Kind.INTERFACE_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new GraphQLInterfaceType(config);\n  } else if (isInputObjectType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const fields = [];\n      Object.values(config.fields).forEach(fieldConfig => {\n        if (fieldConfig.astNode != null) {\n          fields.push(fieldConfig.astNode);\n        }\n      });\n      config.astNode = { ...config.astNode,\n        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n        fields\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n        fields: undefined\n      }));\n    }\n\n    return new GraphQLInputObjectType(config);\n  } else if (isEnumType(type)) {\n    const config = type.toConfig();\n\n    if (config.astNode != null) {\n      const values = [];\n      Object.values(config.values).forEach(enumValueConfig => {\n        if (enumValueConfig.astNode != null) {\n          values.push(enumValueConfig.astNode);\n        }\n      });\n      config.astNode = { ...config.astNode,\n        values\n      };\n    }\n\n    if (config.extensionASTNodes != null) {\n      config.extensionASTNodes = config.extensionASTNodes.map(node => ({ ...node,\n        values: undefined\n      }));\n    }\n\n    return new GraphQLEnumType(config);\n  } else {\n    return type;\n  }\n}\n\nfunction filterSchema({\n  schema,\n  rootFieldFilter = () => true,\n  typeFilter = () => true,\n  fieldFilter = () => true\n}) {\n  const filteredSchema = mapSchema(schema, {\n    [MapperKind.QUERY]: type => filterRootFields(type, 'Query', rootFieldFilter),\n    [MapperKind.MUTATION]: type => filterRootFields(type, 'Mutation', rootFieldFilter),\n    [MapperKind.SUBSCRIPTION]: type => filterRootFields(type, 'Subscription', rootFieldFilter),\n    [MapperKind.OBJECT_TYPE]: type => typeFilter(type.name, type) ? filterObjectFields(type, fieldFilter) : null,\n    [MapperKind.INTERFACE_TYPE]: type => typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.UNION_TYPE]: type => typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.INPUT_OBJECT_TYPE]: type => typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.ENUM_TYPE]: type => typeFilter(type.name, type) ? undefined : null,\n    [MapperKind.SCALAR_TYPE]: type => typeFilter(type.name, type) ? undefined : null\n  });\n  return filteredSchema;\n}\n\nfunction filterRootFields(type, operation, rootFieldFilter) {\n  const config = type.toConfig();\n  Object.keys(config.fields).forEach(fieldName => {\n    if (!rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n      delete config.fields[fieldName];\n    }\n  });\n  return new GraphQLObjectType(config);\n}\n\nfunction filterObjectFields(type, fieldFilter) {\n  const config = type.toConfig();\n  Object.keys(config.fields).forEach(fieldName => {\n    if (!fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n      delete config.fields[fieldName];\n    }\n  });\n  return new GraphQLObjectType(config);\n}\n\nfunction cloneDirective(directive) {\n  return isSpecifiedDirective(directive) ? directive : new GraphQLDirective(directive.toConfig());\n}\n\nfunction cloneType(type) {\n  if (isObjectType(type)) {\n    const config = type.toConfig();\n    return new GraphQLObjectType({ ...config,\n      interfaces: typeof config.interfaces === 'function' ? config.interfaces : config.interfaces.slice()\n    });\n  } else if (isInterfaceType(type)) {\n    const config = type.toConfig();\n    const newConfig = { ...config,\n      interfaces: [...((typeof config.interfaces === 'function' ? config.interfaces() : config.interfaces) || [])]\n    };\n    return new GraphQLInterfaceType(newConfig);\n  } else if (isUnionType(type)) {\n    const config = type.toConfig();\n    return new GraphQLUnionType({ ...config,\n      types: config.types.slice()\n    });\n  } else if (isInputObjectType(type)) {\n    return new GraphQLInputObjectType(type.toConfig());\n  } else if (isEnumType(type)) {\n    return new GraphQLEnumType(type.toConfig());\n  } else if (isScalarType(type)) {\n    return isSpecifiedScalarType(type) ? type : new GraphQLScalarType(type.toConfig());\n  }\n\n  throw new Error(`Invalid type ${type}`);\n}\n\nfunction cloneSchema(schema) {\n  return mapSchema(schema);\n} // Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\n\n\nfunction healSchema(schema) {\n  healTypes(schema.getTypeMap(), schema.getDirectives());\n  return schema;\n}\n\nfunction healTypes(originalTypeMap, directives, config = {\n  skipPruning: false\n}) {\n  const actualNamedTypeMap = Object.create(null); // If any of the .name properties of the GraphQLNamedType objects in\n  // schema.getTypeMap() have changed, the keys of the type map need to\n  // be updated accordingly.\n\n  Object.entries(originalTypeMap).forEach(([typeName, namedType]) => {\n    if (namedType == null || typeName.startsWith('__')) {\n      return;\n    }\n\n    const actualName = namedType.name;\n\n    if (actualName.startsWith('__')) {\n      return;\n    }\n\n    if (actualName in actualNamedTypeMap) {\n      throw new Error(`Duplicate schema type name ${actualName}`);\n    }\n\n    actualNamedTypeMap[actualName] = namedType; // Note: we are deliberately leaving namedType in the schema by its\n    // original name (which might be different from actualName), so that\n    // references by that name can be healed.\n  }); // Now add back every named type by its actual name.\n\n  Object.entries(actualNamedTypeMap).forEach(([typeName, namedType]) => {\n    originalTypeMap[typeName] = namedType;\n  }); // Directive declaration argument types can refer to named types.\n\n  directives.forEach(decl => {\n    decl.args = decl.args.filter(arg => {\n      arg.type = healType(arg.type);\n      return arg.type !== null;\n    });\n  });\n  Object.entries(originalTypeMap).forEach(([typeName, namedType]) => {\n    // Heal all named types, except for dangling references, kept only to redirect.\n    if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n      if (namedType != null) {\n        healNamedType(namedType);\n      }\n    }\n  });\n\n  for (const typeName of Object.keys(originalTypeMap)) {\n    if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n      delete originalTypeMap[typeName];\n    }\n  }\n\n  if (!config.skipPruning) {\n    // TODO:\n    // consider removing the default level of pruning in v7,\n    // see comments below on the pruneTypes function.\n    pruneTypes$1(originalTypeMap, directives);\n  }\n\n  function healNamedType(type) {\n    if (isObjectType(type)) {\n      healFields(type);\n      healInterfaces(type);\n      return;\n    } else if (isInterfaceType(type)) {\n      healFields(type);\n\n      if ('getInterfaces' in type) {\n        healInterfaces(type);\n      }\n\n      return;\n    } else if (isUnionType(type)) {\n      healUnderlyingTypes(type);\n      return;\n    } else if (isInputObjectType(type)) {\n      healInputFields(type);\n      return;\n    } else if (isLeafType(type)) {\n      return;\n    }\n\n    throw new Error(`Unexpected schema type: ${type}`);\n  }\n\n  function healFields(type) {\n    const fieldMap = type.getFields();\n\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.args.map(arg => {\n        arg.type = healType(arg.type);\n        return arg.type === null ? null : arg;\n      }).filter(Boolean);\n      field.type = healType(field.type);\n\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healInterfaces(type) {\n    if ('getInterfaces' in type) {\n      const interfaces = type.getInterfaces();\n      interfaces.push(...interfaces.splice(0).map(iface => healType(iface)).filter(Boolean));\n    }\n  }\n\n  function healInputFields(type) {\n    const fieldMap = type.getFields();\n\n    for (const [key, field] of Object.entries(fieldMap)) {\n      field.type = healType(field.type);\n\n      if (field.type === null) {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  function healUnderlyingTypes(type) {\n    const types = type.getTypes();\n    types.push(...types.splice(0).map(t => healType(t)).filter(Boolean));\n  }\n\n  function healType(type) {\n    // Unwrap the two known wrapper types\n    if (isListType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLList(healedType) : null;\n    } else if (isNonNullType(type)) {\n      const healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLNonNull(healedType) : null;\n    } else if (isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      // Note that new types can still be simply added by adding a field, as\n      // the official type will be undefined, not null.\n      const officialType = originalTypeMap[type.name];\n\n      if (officialType && type !== officialType) {\n        return officialType;\n      }\n    }\n\n    return type;\n  }\n} // TODO:\n// consider removing the default level of pruning in v7\n//\n// Pruning was introduced into healSchema in v5, so legacy schema directives relying on pruning\n// during healing are likely to be rare. pruning is now recommended via the dedicated pruneSchema\n// function which does not force pruning on library users and gives granular control in terms of\n// pruning types. pruneSchema does recreate the schema -- a parallel version that prunes in place\n// could be considered.\n\n\nfunction pruneTypes$1(typeMap, directives) {\n  const implementedInterfaces = {};\n  Object.values(typeMap).forEach(namedType => {\n    if ('getInterfaces' in namedType) {\n      namedType.getInterfaces().forEach(iface => {\n        implementedInterfaces[iface.name] = true;\n      });\n    }\n  });\n  let prunedTypeMap = false;\n  const typeNames = Object.keys(typeMap);\n\n  for (let i = 0; i < typeNames.length; i++) {\n    const typeName = typeNames[i];\n    const type = typeMap[typeName];\n\n    if (isObjectType(type) || isInputObjectType(type)) {\n      // prune types with no fields\n      if (!Object.keys(type.getFields()).length) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    } else if (isUnionType(type)) {\n      // prune unions without underlying types\n      if (!type.getTypes().length) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    } else if (isInterfaceType(type)) {\n      // prune interfaces without fields or without implementations\n      if (!Object.keys(type.getFields()).length || !(type.name in implementedInterfaces)) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    }\n  } // every prune requires another round of healing\n\n\n  if (prunedTypeMap) {\n    healTypes(typeMap, directives);\n  }\n} // Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\n\n\nclass SchemaVisitor {\n  // Determine if this SchemaVisitor (sub)class implements a particular\n  // visitor method.\n  static implementsVisitorMethod(methodName) {\n    if (!methodName.startsWith('visit')) {\n      return false;\n    }\n\n    const method = this.prototype[methodName];\n\n    if (typeof method !== 'function') {\n      return false;\n    }\n\n    if (this.name === 'SchemaVisitor') {\n      // The SchemaVisitor class implements every visitor method.\n      return true;\n    }\n\n    const stub = SchemaVisitor.prototype[methodName];\n\n    if (method === stub) {\n      // If this.prototype[methodName] was just inherited from SchemaVisitor,\n      // then this class does not really implement the method.\n      return false;\n    }\n\n    return true;\n  } // Concrete subclasses of SchemaVisitor should override one or more of these\n  // visitor methods, in order to express their interest in handling certain\n  // schema types/locations. Each method may return null to remove the given\n  // type from the schema, a non-null value of the same type to update the\n  // type in the schema, or nothing to leave the type as it was.\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  visitSchema(_schema) {}\n\n  visitScalar(_scalar // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ) {}\n\n  visitObject(_object // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ) {}\n\n  visitFieldDefinition(_field, _details // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ) {}\n\n  visitArgumentDefinition(_argument, _details // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ) {}\n\n  visitInterface(_iface // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ) {} // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  visitUnion(_union) {} // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  visitEnum(_type) {}\n\n  visitEnumValue(_value, _details // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ) {}\n\n  visitInputObject(_object // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ) {}\n\n  visitInputFieldDefinition(_field, _details // eslint-disable-next-line @typescript-eslint/no-empty-function\n  ) {}\n\n}\n\nfunction isSchemaVisitor(obj) {\n  if ('schema' in obj && isSchema(obj.schema)) {\n    if ('visitSchema' in obj && typeof obj.visitSchema === 'function') {\n      return true;\n    }\n  }\n\n  return false;\n} // Generic function for visiting GraphQLSchema objects.\n\n\nfunction visitSchema(schema, // To accommodate as many different visitor patterns as possible, the\n// visitSchema function does not simply accept a single instance of the\n// SchemaVisitor class, but instead accepts a function that takes the\n// current VisitableSchemaType object and the name of a visitor method and\n// returns an array of SchemaVisitor instances that implement the visitor\n// method and have an interest in handling the given VisitableSchemaType\n// object. In the simplest case, this function can always return an array\n// containing a single visitor object, without even looking at the type or\n// methodName parameters. In other cases, this function might sometimes\n// return an empty array to indicate there are no visitors that should be\n// applied to the given VisitableSchemaType object. For an example of a\n// visitor pattern that benefits from this abstraction, see the\n// SchemaDirectiveVisitor class below.\nvisitorOrVisitorSelector) {\n  const visitorSelector = typeof visitorOrVisitorSelector === 'function' ? visitorOrVisitorSelector : () => visitorOrVisitorSelector; // Helper function that calls visitorSelector and applies the resulting\n  // visitors to the given type, with arguments [type, ...args].\n\n  function callMethod(methodName, type, ...args) {\n    let visitors = visitorSelector(type, methodName);\n    visitors = Array.isArray(visitors) ? visitors : [visitors];\n    let finalType = type;\n    visitors.every(visitorOrVisitorDef => {\n      let newType;\n\n      if (isSchemaVisitor(visitorOrVisitorDef)) {\n        newType = visitorOrVisitorDef[methodName](finalType, ...args);\n      } else if (isNamedType(finalType) && (methodName === 'visitScalar' || methodName === 'visitEnum' || methodName === 'visitObject' || methodName === 'visitInputObject' || methodName === 'visitUnion' || methodName === 'visitInterface')) {\n        const specifiers = getTypeSpecifiers$1(finalType, schema);\n        const typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);\n        newType = typeVisitor != null ? typeVisitor(finalType, schema) : undefined;\n      }\n\n      if (typeof newType === 'undefined') {\n        // Keep going without modifying type.\n        return true;\n      }\n\n      if (methodName === 'visitSchema' || isSchema(finalType)) {\n        throw new Error(`Method ${methodName} cannot replace schema with ${newType}`);\n      }\n\n      if (newType === null) {\n        // Stop the loop and return null form callMethod, which will cause\n        // the type to be removed from the schema.\n        finalType = null;\n        return false;\n      } // Update type to the new type returned by the visitor method, so that\n      // later directives will see the new type, and callMethod will return\n      // the final type.\n\n\n      finalType = newType;\n      return true;\n    }); // If there were no directives for this type object, or if all visitor\n    // methods returned nothing, type will be returned unmodified.\n\n    return finalType;\n  } // Recursive helper function that calls any appropriate visitor methods for\n  // each object in the schema, then traverses the object's children (if any).\n\n\n  function visit(type) {\n    if (isSchema(type)) {\n      // Unlike the other types, the root GraphQLSchema object cannot be\n      // replaced by visitor methods, because that would make life very hard\n      // for SchemaVisitor subclasses that rely on the original schema object.\n      callMethod('visitSchema', type);\n      const typeMap = type.getTypeMap();\n      Object.entries(typeMap).forEach(([typeName, namedType]) => {\n        if (!typeName.startsWith('__') && namedType != null) {\n          // Call visit recursively to let it determine which concrete\n          // subclass of GraphQLNamedType we found in the type map.\n          // We do not use updateEachKey because we want to preserve\n          // deleted types in the typeMap so that other types that reference\n          // the deleted types can be healed.\n          typeMap[typeName] = visit(namedType);\n        }\n      });\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      // Note that callMethod('visitObject', type) may not actually call any\n      // methods, if there are no @directive annotations associated with this\n      // type, or if this SchemaDirectiveVisitor subclass does not override\n      // the visitObject method.\n      const newObject = callMethod('visitObject', type);\n\n      if (newObject != null) {\n        visitFields(newObject);\n      }\n\n      return newObject;\n    }\n\n    if (isInterfaceType(type)) {\n      const newInterface = callMethod('visitInterface', type);\n\n      if (newInterface != null) {\n        visitFields(newInterface);\n      }\n\n      return newInterface;\n    }\n\n    if (isInputObjectType(type)) {\n      const newInputObject = callMethod('visitInputObject', type);\n\n      if (newInputObject != null) {\n        const fieldMap = newInputObject.getFields();\n\n        for (const key of Object.keys(fieldMap)) {\n          fieldMap[key] = callMethod('visitInputFieldDefinition', fieldMap[key], {\n            // Since we call a different method for input object fields, we\n            // can't reuse the visitFields function here.\n            objectType: newInputObject\n          });\n\n          if (!fieldMap[key]) {\n            delete fieldMap[key];\n          }\n        }\n      }\n\n      return newInputObject;\n    }\n\n    if (isScalarType(type)) {\n      return callMethod('visitScalar', type);\n    }\n\n    if (isUnionType(type)) {\n      return callMethod('visitUnion', type);\n    }\n\n    if (isEnumType(type)) {\n      let newEnum = callMethod('visitEnum', type);\n\n      if (newEnum != null) {\n        const newValues = newEnum.getValues().map(value => callMethod('visitEnumValue', value, {\n          enumType: newEnum\n        })).filter(Boolean); // Recreate the enum type if any of the values changed\n\n        const valuesUpdated = newValues.some((value, index) => value !== newEnum.getValues()[index]);\n\n        if (valuesUpdated) {\n          newEnum = new GraphQLEnumType({ ...newEnum.toConfig(),\n            values: newValues.reduce((prev, value) => ({ ...prev,\n              [value.name]: {\n                value: value.value,\n                deprecationReason: value.deprecationReason,\n                description: value.description,\n                astNode: value.astNode\n              }\n            }), {})\n          });\n        }\n      }\n\n      return newEnum;\n    }\n\n    throw new Error(`Unexpected schema type: ${type}`);\n  }\n\n  function visitFields(type) {\n    const fieldMap = type.getFields();\n\n    for (const [key, field] of Object.entries(fieldMap)) {\n      // It would be nice if we could call visit(field) recursively here, but\n      // GraphQLField is merely a type, not a value that can be detected using\n      // an instanceof check, so we have to visit the fields in this lexical\n      // context, so that TypeScript can validate the call to\n      // visitFieldDefinition.\n      const newField = callMethod('visitFieldDefinition', field, {\n        // While any field visitor needs a reference to the field object, some\n        // field visitors may also need to know the enclosing (parent) type,\n        // perhaps to determine if the parent is a GraphQLObjectType or a\n        // GraphQLInterfaceType. To obtain a reference to the parent, a\n        // visitor method can have a second parameter, which will be an object\n        // with an .objectType property referring to the parent.\n        objectType: type\n      });\n\n      if (newField.args != null) {\n        newField.args = newField.args.map(arg => callMethod('visitArgumentDefinition', arg, {\n          // Like visitFieldDefinition, visitArgumentDefinition takes a\n          // second parameter that provides additional context, namely the\n          // parent .field and grandparent .objectType. Remember that the\n          // current GraphQLSchema is always available via this.schema.\n          field: newField,\n          objectType: type\n        })).filter(Boolean);\n      } // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n\n      if (newField) {\n        fieldMap[key] = newField;\n      } else {\n        delete fieldMap[key];\n      }\n    }\n  }\n\n  visit(schema); // Automatically update any references to named schema types replaced\n  // during the traversal, so implementors don't have to worry about that.\n\n  healSchema(schema); // Return schema for convenience, even though schema parameter has all updated types.\n\n  return schema;\n}\n\nfunction getTypeSpecifiers$1(type, schema) {\n  const specifiers = [VisitSchemaKind.TYPE];\n\n  if (isObjectType(type)) {\n    specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);\n    const query = schema.getQueryType();\n    const mutation = schema.getMutationType();\n    const subscription = schema.getSubscriptionType();\n\n    if (type === query) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);\n    } else if (type === mutation) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);\n    } else if (type === subscription) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);\n    }\n  } else if (isInputType(type)) {\n    specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);\n  } else if (isUnionType(type)) {\n    specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);\n  } else if (isEnumType(type)) {\n    specifiers.push(VisitSchemaKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(VisitSchemaKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getVisitor(visitorDef, specifiers) {\n  let typeVisitor;\n  const stack = [...specifiers];\n\n  while (!typeVisitor && stack.length > 0) {\n    const next = stack.pop();\n    typeVisitor = visitorDef[next];\n  }\n\n  return typeVisitor != null ? typeVisitor : null;\n} // This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\n\n\nclass SchemaDirectiveVisitor extends SchemaVisitor {\n  // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n  // subclasses (not instances) to visitSchemaDirectives.\n  constructor(config) {\n    super();\n    this.name = config.name;\n    this.args = config.args;\n    this.visitedType = config.visitedType;\n    this.schema = config.schema;\n    this.context = config.context;\n  } // Override this method to return a custom GraphQLDirective (or modify one\n  // already present in the schema) to enforce argument types, provide default\n  // argument values, or specify schema locations where this @directive may\n  // appear. By default, any declaration found in the schema will be returned.\n\n\n  static getDirectiveDeclaration(directiveName, schema) {\n    return schema.getDirective(directiveName);\n  } // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n  // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n  // instance to visit the object decorated by the @directive.\n\n\n  static visitSchemaDirectives(schema, // The keys of this object correspond to directive names as they appear\n  // in the schema, and the values should be subclasses (not instances!)\n  // of the SchemaDirectiveVisitor class. This distinction is important\n  // because a new SchemaDirectiveVisitor instance will be created each\n  // time a matching directive is found in the schema AST, with arguments\n  // and other metadata specific to that occurrence. To help prevent the\n  // mistake of passing instances, the SchemaDirectiveVisitor constructor\n  // method is marked as protected.\n  directiveVisitors, // Optional context object that will be available to all visitor instances\n  // via this.context. Defaults to an empty null-prototype object.\n  context = Object.create(null) // The visitSchemaDirectives method returns a map from directive names to\n  // lists of SchemaDirectiveVisitors created while visiting the schema.\n  ) {\n    // If the schema declares any directives for public consumption, record\n    // them here so that we can properly coerce arguments when/if we encounter\n    // an occurrence of the directive while walking the schema below.\n    const declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors); // Map from directive names to lists of SchemaDirectiveVisitor instances\n    // created while visiting the schema.\n\n    const createdVisitors = Object.keys(directiveVisitors).reduce((prev, item) => ({ ...prev,\n      [item]: []\n    }), {});\n    const directiveVisitorMap = Object.entries(directiveVisitors).reduce((prev, [key, value]) => ({ ...prev,\n      [key]: value\n    }), {});\n\n    function visitorSelector(type, methodName) {\n      var _a, _b;\n\n      let directiveNodes = (_b = (_a = type === null || type === void 0 ? void 0 : type.astNode) === null || _a === void 0 ? void 0 : _a.directives) !== null && _b !== void 0 ? _b : [];\n      const extensionASTNodes = type.extensionASTNodes;\n\n      if (extensionASTNodes != null) {\n        extensionASTNodes.forEach(extensionASTNode => {\n          if (extensionASTNode.directives != null) {\n            directiveNodes = directiveNodes.concat(extensionASTNode.directives);\n          }\n        });\n      }\n\n      const visitors = [];\n      directiveNodes.forEach(directiveNode => {\n        const directiveName = directiveNode.name.value;\n\n        if (!(directiveName in directiveVisitorMap)) {\n          return;\n        }\n\n        const VisitorClass = directiveVisitorMap[directiveName]; // Avoid creating visitor objects if visitorClass does not override\n        // the visitor method named by methodName.\n\n        if (!VisitorClass.implementsVisitorMethod(methodName)) {\n          return;\n        }\n\n        const decl = declaredDirectives[directiveName];\n        let args;\n\n        if (decl != null) {\n          // If this directive was explicitly declared, use the declared\n          // argument types (and any default values) to check, coerce, and/or\n          // supply default values for the given arguments.\n          args = getArgumentValues(decl, directiveNode);\n        } else {\n          // If this directive was not explicitly declared, just convert the\n          // argument nodes to their corresponding JavaScript values.\n          args = Object.create(null);\n\n          if (directiveNode.arguments != null) {\n            directiveNode.arguments.forEach(arg => {\n              args[arg.name.value] = valueFromASTUntyped(arg.value);\n            });\n          }\n        } // As foretold in comments near the top of the visitSchemaDirectives\n        // method, this is where instances of the SchemaDirectiveVisitor class\n        // get created and assigned names. While subclasses could override the\n        // constructor method, the constructor is marked as protected, so\n        // these are the only arguments that will ever be passed.\n\n\n        visitors.push(new VisitorClass({\n          name: directiveName,\n          args,\n          visitedType: type,\n          schema,\n          context\n        }));\n      });\n\n      if (visitors.length > 0) {\n        visitors.forEach(visitor => {\n          createdVisitors[visitor.name].push(visitor);\n        });\n      }\n\n      return visitors;\n    }\n\n    visitSchema(schema, visitorSelector);\n    return createdVisitors;\n  }\n\n  static getDeclaredDirectives(schema, directiveVisitors) {\n    const declaredDirectives = schema.getDirectives().reduce((prev, curr) => ({ ...prev,\n      [curr.name]: curr\n    }), {}); // If the visitor subclass overrides getDirectiveDeclaration, and it\n    // returns a non-null GraphQLDirective, use that instead of any directive\n    // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n    // goes to the trouble of implementing getDirectiveDeclaration, it should\n    // be able to rely on that implementation.\n\n    Object.entries(directiveVisitors).forEach(([directiveName, visitorClass]) => {\n      const decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\n\n      if (decl != null) {\n        declaredDirectives[directiveName] = decl;\n      }\n    });\n    Object.entries(declaredDirectives).forEach(([name, decl]) => {\n      if (!(name in directiveVisitors)) {\n        // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n        // multiple times with partial directiveVisitors maps, so it's not\n        // necessarily an error for directiveVisitors to be missing an\n        // implementation of a directive that was declared in the schema.\n        return;\n      }\n\n      const visitorClass = directiveVisitors[name];\n      decl.locations.forEach(loc => {\n        const visitorMethodName = directiveLocationToVisitorMethodName(loc);\n\n        if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) && !visitorClass.implementsVisitorMethod(visitorMethodName)) {\n          // While visitor subclasses may implement extra visitor methods,\n          // it's definitely a mistake if the GraphQLDirective declares itself\n          // applicable to certain schema locations, and the visitor subclass\n          // does not implement all the corresponding methods.\n          throw new Error(`SchemaDirectiveVisitor for @${name} must implement ${visitorMethodName} method`);\n        }\n      });\n    });\n    return declaredDirectives;\n  }\n\n} // Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\n\n\nfunction directiveLocationToVisitorMethodName(loc) {\n  return 'visit' + loc.replace(/([^_]*)_?/g, (_wholeMatch, part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase());\n}\n\nfunction getResolversFromSchema(schema) {\n  const resolvers = Object.create({});\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach(typeName => {\n    const type = typeMap[typeName];\n\n    if (isScalarType(type)) {\n      if (!isSpecifiedScalarType(type)) {\n        resolvers[typeName] = cloneType(type);\n      }\n    } else if (isEnumType(type)) {\n      resolvers[typeName] = {};\n      const values = type.getValues();\n      values.forEach(value => {\n        resolvers[typeName][value.name] = value.value;\n      });\n    } else if (isInterfaceType(type)) {\n      if (type.resolveType != null) {\n        resolvers[typeName] = {\n          __resolveType: type.resolveType\n        };\n      }\n    } else if (isUnionType(type)) {\n      if (type.resolveType != null) {\n        resolvers[typeName] = {\n          __resolveType: type.resolveType\n        };\n      }\n    } else if (isObjectType(type)) {\n      resolvers[typeName] = {};\n\n      if (type.isTypeOf != null) {\n        resolvers[typeName].__isTypeOf = type.isTypeOf;\n      }\n\n      const fields = type.getFields();\n      Object.keys(fields).forEach(fieldName => {\n        const field = fields[fieldName];\n        resolvers[typeName][fieldName] = {\n          resolve: field.resolve,\n          subscribe: field.subscribe\n        };\n      });\n    }\n  });\n  return resolvers;\n}\n\nfunction forEachField(schema, fn) {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach(typeName => {\n    const type = typeMap[typeName]; // TODO: maybe have an option to include these?\n\n    if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n      const fields = type.getFields();\n      Object.keys(fields).forEach(fieldName => {\n        const field = fields[fieldName];\n        fn(field, typeName, fieldName);\n      });\n    }\n  });\n}\n\nfunction forEachDefaultValue(schema, fn) {\n  const typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach(typeName => {\n    const type = typeMap[typeName];\n\n    if (!getNamedType(type).name.startsWith('__')) {\n      if (isObjectType(type)) {\n        const fields = type.getFields();\n        Object.keys(fields).forEach(fieldName => {\n          const field = fields[fieldName];\n          field.args.forEach(arg => {\n            arg.defaultValue = fn(arg.type, arg.defaultValue);\n          });\n        });\n      } else if (isInputObjectType(type)) {\n        const fields = type.getFields();\n        Object.keys(fields).forEach(fieldName => {\n          const field = fields[fieldName];\n          field.defaultValue = fn(field.type, field.defaultValue);\n        });\n      }\n    }\n  });\n} // addTypes uses toConfig to create a new schema with a new or replaced\n\n\nfunction addTypes(schema, newTypesOrDirectives) {\n  const queryType = schema.getQueryType();\n  const mutationType = schema.getMutationType();\n  const subscriptionType = schema.getSubscriptionType();\n  const queryTypeName = queryType != null ? queryType.name : undefined;\n  const mutationTypeName = mutationType != null ? mutationType.name : undefined;\n  const subscriptionTypeName = subscriptionType != null ? subscriptionType.name : undefined;\n  const config = schema.toConfig();\n  const originalTypeMap = {};\n  config.types.forEach(type => {\n    originalTypeMap[type.name] = type;\n  });\n  const originalDirectiveMap = {};\n  config.directives.forEach(directive => {\n    originalDirectiveMap[directive.name] = directive;\n  });\n  newTypesOrDirectives.forEach(newTypeOrDirective => {\n    if (isNamedType(newTypeOrDirective)) {\n      originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n    } else if (isDirective(newTypeOrDirective)) {\n      originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n    }\n  });\n  const {\n    typeMap,\n    directives\n  } = rewireTypes(originalTypeMap, Object.keys(originalDirectiveMap).map(directiveName => originalDirectiveMap[directiveName]));\n  return new GraphQLSchema({ ...config,\n    query: queryTypeName ? typeMap[queryTypeName] : undefined,\n    mutation: mutationTypeName ? typeMap[mutationTypeName] : undefined,\n    subscription: subscriptionTypeName != null ? typeMap[subscriptionTypeName] : undefined,\n    types: Object.keys(typeMap).map(typeName => typeMap[typeName]),\n    directives\n  });\n}\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\n\n\nfunction pruneSchema(schema, options = {}) {\n  const pruningContext = {\n    schema,\n    unusedTypes: Object.create(null),\n    implementations: Object.create(null)\n  };\n  Object.keys(schema.getTypeMap()).forEach(typeName => {\n    const type = schema.getType(typeName);\n\n    if ('getInterfaces' in type) {\n      type.getInterfaces().forEach(iface => {\n        if (pruningContext.implementations[iface.name] == null) {\n          pruningContext.implementations[iface.name] = Object.create(null);\n        }\n\n        pruningContext.implementations[iface.name][type.name] = true;\n      });\n    }\n  });\n  visitTypes(pruningContext, schema);\n  return mapSchema(schema, {\n    [MapperKind.TYPE]: type => {\n      if (isObjectType(type) || isInputObjectType(type)) {\n        if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      } else if (isUnionType(type)) {\n        if (!type.getTypes().length && !options.skipEmptyUnionPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      } else if (isInterfaceType(type)) {\n        if (!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning || !Object.keys(pruningContext.implementations[type.name]).length && !options.skipUnimplementedInterfacesPruning || pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      } else {\n        if (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n          return null;\n        }\n      }\n    }\n  });\n}\n\nfunction visitOutputType(visitedTypes, pruningContext, type) {\n  if (visitedTypes[type.name]) {\n    return;\n  }\n\n  visitedTypes[type.name] = true;\n  pruningContext.unusedTypes[type.name] = false;\n\n  if (isObjectType(type) || isInterfaceType(type)) {\n    const fields = type.getFields();\n    Object.keys(fields).forEach(fieldName => {\n      const field = fields[fieldName];\n      const namedType = getNamedType(field.type);\n      visitOutputType(visitedTypes, pruningContext, namedType);\n      const args = field.args;\n      args.forEach(arg => {\n        const type = getNamedType(arg.type);\n        visitInputType(visitedTypes, pruningContext, type);\n      });\n    });\n\n    if (isInterfaceType(type)) {\n      Object.keys(pruningContext.implementations[type.name]).forEach(typeName => {\n        visitOutputType(visitedTypes, pruningContext, pruningContext.schema.getType(typeName));\n      });\n    }\n\n    if ('getInterfaces' in type) {\n      type.getInterfaces().forEach(type => {\n        visitOutputType(visitedTypes, pruningContext, type);\n      });\n    }\n  } else if (isUnionType(type)) {\n    const types = type.getTypes();\n    types.forEach(type => visitOutputType(visitedTypes, pruningContext, type));\n  }\n}\n\nfunction visitInputType(visitedTypes, pruningContext, type) {\n  if (visitedTypes[type.name]) {\n    return;\n  }\n\n  pruningContext.unusedTypes[type.name] = false;\n  visitedTypes[type.name] = true;\n\n  if (isInputObjectType(type)) {\n    const fields = type.getFields();\n    Object.keys(fields).forEach(fieldName => {\n      const field = fields[fieldName];\n      const namedType = getNamedType(field.type);\n      visitInputType(visitedTypes, pruningContext, namedType);\n    });\n  }\n}\n\nfunction visitTypes(pruningContext, schema) {\n  Object.keys(schema.getTypeMap()).forEach(typeName => {\n    if (!typeName.startsWith('__')) {\n      pruningContext.unusedTypes[typeName] = true;\n    }\n  });\n  const visitedTypes = Object.create(null);\n  const rootTypes = [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()].filter(type => type != null);\n  rootTypes.forEach(rootType => visitOutputType(visitedTypes, pruningContext, rootType));\n  schema.getDirectives().forEach(directive => {\n    directive.args.forEach(arg => {\n      const type = getNamedType(arg.type);\n      visitInputType(visitedTypes, pruningContext, type);\n    });\n  });\n}\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n\n\nfunction mergeDeep(target, ...sources) {\n  if (isScalarType(target)) {\n    return target;\n  }\n\n  const output = { ...target\n  };\n\n  for (const source of sources) {\n    if (isObject(target) && isObject(source)) {\n      for (const key in source) {\n        if (isObject(source[key])) {\n          if (!(key in target)) {\n            Object.assign(output, {\n              [key]: source[key]\n            });\n          } else {\n            output[key] = mergeDeep(target[key], source[key]);\n          }\n        } else {\n          Object.assign(output, {\n            [key]: source[key]\n          });\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\nfunction isObject(item) {\n  return item && typeof item === 'object' && !Array.isArray(item);\n}\n\nfunction renameFieldNode(fieldNode, name) {\n  return { ...fieldNode,\n    alias: {\n      kind: Kind.NAME,\n      value: fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value\n    },\n    name: {\n      kind: Kind.NAME,\n      value: name\n    }\n  };\n}\n\nfunction preAliasFieldNode(fieldNode, str) {\n  return { ...fieldNode,\n    alias: {\n      kind: Kind.NAME,\n      value: `${str}${fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value}`\n    }\n  };\n}\n\nfunction wrapFieldNode(fieldNode, path) {\n  let newFieldNode = fieldNode;\n  path.forEach(fieldName => {\n    newFieldNode = {\n      kind: Kind.FIELD,\n      name: {\n        kind: Kind.NAME,\n        value: fieldName\n      },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [fieldNode]\n      }\n    };\n  });\n  return newFieldNode;\n}\n\nfunction collectFields(selectionSet, fragments, fields = [], visitedFragmentNames = {}) {\n  if (selectionSet != null) {\n    selectionSet.selections.forEach(selection => {\n      switch (selection.kind) {\n        case Kind.FIELD:\n          fields.push(selection);\n          break;\n\n        case Kind.INLINE_FRAGMENT:\n          collectFields(selection.selectionSet, fragments, fields, visitedFragmentNames);\n          break;\n\n        case Kind.FRAGMENT_SPREAD:\n          {\n            const fragmentName = selection.name.value;\n\n            if (!visitedFragmentNames[fragmentName]) {\n              visitedFragmentNames[fragmentName] = true;\n              collectFields(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n  return fields;\n}\n\nfunction hoistFieldNodes({\n  fieldNode,\n  fieldNames,\n  path = [],\n  delimeter = '__gqltf__',\n  fragments\n}) {\n  const alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;\n  let newFieldNodes = [];\n\n  if (path.length) {\n    const remainingPathSegments = path.slice();\n    const initialPathSegment = remainingPathSegments.shift();\n    collectFields(fieldNode.selectionSet, fragments).forEach(possibleFieldNode => {\n      if (possibleFieldNode.name.value === initialPathSegment) {\n        newFieldNodes = newFieldNodes.concat(hoistFieldNodes({\n          fieldNode: preAliasFieldNode(possibleFieldNode, `${alias}${delimeter}`),\n          fieldNames,\n          path: remainingPathSegments,\n          delimeter,\n          fragments\n        }));\n      }\n    });\n  } else {\n    collectFields(fieldNode.selectionSet, fragments).forEach(possibleFieldNode => {\n      if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {\n        newFieldNodes.push(preAliasFieldNode(possibleFieldNode, `${alias}${delimeter}`));\n      }\n    });\n  }\n\n  return newFieldNodes;\n}\n\nfunction concatInlineFragments(type, fragments) {\n  const fragmentSelections = fragments.reduce((selections, fragment) => selections.concat(fragment.selectionSet.selections), []);\n  const deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);\n  return {\n    kind: Kind.INLINE_FRAGMENT,\n    typeCondition: {\n      kind: Kind.NAMED_TYPE,\n      name: {\n        kind: Kind.NAME,\n        value: type\n      }\n    },\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: deduplicatedFragmentSelection\n    }\n  };\n}\n\nfunction deduplicateSelection(nodes) {\n  const selectionMap = nodes.reduce((map, node) => {\n    switch (node.kind) {\n      case 'Field':\n        {\n          if (node.alias != null) {\n            if (node.alias.value in map) {\n              return map;\n            }\n\n            return { ...map,\n              [node.alias.value]: node\n            };\n          }\n\n          if (node.name.value in map) {\n            return map;\n          }\n\n          return { ...map,\n            [node.name.value]: node\n          };\n        }\n\n      case 'FragmentSpread':\n        {\n          if (node.name.value in map) {\n            return map;\n          }\n\n          return { ...map,\n            [node.name.value]: node\n          };\n        }\n\n      case 'InlineFragment':\n        {\n          if (map.__fragment != null) {\n            const fragment = map.__fragment;\n            return { ...map,\n              __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node])\n            };\n          }\n\n          return { ...map,\n            __fragment: node\n          };\n        }\n\n      default:\n        {\n          return map;\n        }\n    }\n  }, Object.create(null));\n  const selection = Object.keys(selectionMap).reduce((selectionList, node) => selectionList.concat(selectionMap[node]), []);\n  return selection;\n}\n\nfunction parseFragmentToInlineFragment(definitions) {\n  if (definitions.trim().startsWith('fragment')) {\n    const document = parse(definitions);\n\n    for (const definition of document.definitions) {\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: definition.typeCondition,\n          selectionSet: definition.selectionSet\n        };\n      }\n    }\n  }\n\n  const query = parse(`{${definitions}}`).definitions[0];\n\n  for (const selection of query.selectionSet.selections) {\n    if (selection.kind === Kind.INLINE_FRAGMENT) {\n      return selection;\n    }\n  }\n\n  throw new Error('Could not parse fragment');\n}\n\nfunction parseSelectionSet(selectionSet) {\n  const query = parse(selectionSet).definitions[0];\n  return query.selectionSet;\n}\n\nfunction typesContainSelectionSet(types, selectionSet) {\n  const fieldMaps = types.map(type => type.getFields());\n\n  for (const selection of selectionSet.selections) {\n    if (selection.kind === Kind.FIELD) {\n      const fields = fieldMaps.map(fieldMap => fieldMap[selection.name.value]).filter(field => field != null);\n\n      if (!fields.length) {\n        return false;\n      }\n\n      if (selection.selectionSet != null) {\n        return typesContainSelectionSet(fields.map(field => getNamedType(field.type)), selection.selectionSet);\n      }\n    } else if (selection.kind === Kind.INLINE_FRAGMENT && selection.typeCondition.name.value === types[0].name) {\n      return typesContainSelectionSet(types, selection.selectionSet);\n    }\n  }\n\n  return true;\n}\n\nfunction typeContainsSelectionSet(type, selectionSet) {\n  const fields = type.getFields();\n\n  for (const selection of selectionSet.selections) {\n    if (selection.kind === Kind.FIELD) {\n      const field = fields[selection.name.value];\n\n      if (field == null) {\n        return false;\n      }\n\n      if (selection.selectionSet != null) {\n        return typeContainsSelectionSet(getNamedType(field.type), selection.selectionSet);\n      }\n    } else if (selection.kind === Kind.INLINE_FRAGMENT && selection.typeCondition.name.value === type.name) {\n      return typeContainsSelectionSet(type, selection.selectionSet);\n    }\n  }\n\n  return true;\n}\n/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\n\n\nfunction getResponseKeyFromInfo(info) {\n  return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;\n}\n\nfunction applySchemaTransforms(originalSchema, transforms) {\n  return transforms.reduce((schema, transform) => transform.transformSchema != null ? transform.transformSchema(cloneSchema(schema)) : schema, originalSchema);\n}\n\nfunction applyRequestTransforms(originalRequest, transforms) {\n  return transforms.reduce((request, transform) => transform.transformRequest != null ? transform.transformRequest(request) : request, originalRequest);\n}\n\nfunction applyResultTransforms(originalResult, transforms) {\n  return transforms.reduceRight((result, transform) => transform.transformResult != null ? transform.transformResult(result) : result, originalResult);\n}\n\nfunction appendObjectFields(schema, typeName, additionalFields) {\n  if (schema.getType(typeName) == null) {\n    return addTypes(schema, [new GraphQLObjectType({\n      name: typeName,\n      fields: additionalFields\n    })]);\n  }\n\n  return mapSchema(schema, {\n    [MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n        Object.keys(originalFieldConfigMap).forEach(fieldName => {\n          newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];\n        });\n        Object.keys(additionalFields).forEach(fieldName => {\n          newFieldConfigMap[fieldName] = additionalFields[fieldName];\n        });\n        return correctASTNodes(new GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n}\n\nfunction removeObjectFields(schema, typeName, testFn) {\n  const removedFields = {};\n  const newSchema = mapSchema(schema, {\n    [MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n        Object.keys(originalFieldConfigMap).forEach(fieldName => {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            removedFields[fieldName] = originalFieldConfig;\n          } else {\n            newFieldConfigMap[fieldName] = originalFieldConfig;\n          }\n        });\n        return correctASTNodes(new GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n  return [newSchema, removedFields];\n}\n\nfunction selectObjectFields(schema, typeName, testFn) {\n  const selectedFields = {};\n  mapSchema(schema, {\n    [MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        Object.keys(originalFieldConfigMap).forEach(fieldName => {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            selectedFields[fieldName] = originalFieldConfig;\n          }\n        });\n      }\n\n      return undefined;\n    }\n  });\n  return selectedFields;\n}\n\nfunction modifyObjectFields(schema, typeName, testFn, newFields) {\n  const removedFields = {};\n  const newSchema = mapSchema(schema, {\n    [MapperKind.OBJECT_TYPE]: type => {\n      if (type.name === typeName) {\n        const config = type.toConfig();\n        const originalFieldConfigMap = config.fields;\n        const newFieldConfigMap = {};\n        Object.keys(originalFieldConfigMap).forEach(fieldName => {\n          const originalFieldConfig = originalFieldConfigMap[fieldName];\n\n          if (testFn(fieldName, originalFieldConfig)) {\n            removedFields[fieldName] = originalFieldConfig;\n          } else {\n            newFieldConfigMap[fieldName] = originalFieldConfig;\n          }\n        });\n        Object.keys(newFields).forEach(fieldName => {\n          const fieldConfig = newFields[fieldName];\n          newFieldConfigMap[fieldName] = fieldConfig;\n        });\n        return correctASTNodes(new GraphQLObjectType({ ...config,\n          fields: newFieldConfigMap\n        }));\n      }\n    }\n  });\n  return [newSchema, removedFields];\n}\n\nfunction renameType(type, newTypeName) {\n  if (isObjectType(type)) {\n    return new GraphQLObjectType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (isInterfaceType(type)) {\n    return new GraphQLInterfaceType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (isUnionType(type)) {\n    return new GraphQLUnionType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (isInputObjectType(type)) {\n    return new GraphQLInputObjectType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (isEnumType(type)) {\n    return new GraphQLEnumType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  } else if (isScalarType(type)) {\n    return new GraphQLScalarType({ ...type.toConfig(),\n      name: newTypeName,\n      astNode: type.astNode == null ? type.astNode : { ...type.astNode,\n        name: { ...type.astNode.name,\n          value: newTypeName\n        }\n      },\n      extensionASTNodes: type.extensionASTNodes == null ? type.extensionASTNodes : type.extensionASTNodes.map(node => ({ ...node,\n        name: { ...node.name,\n          value: newTypeName\n        }\n      }))\n    });\n  }\n\n  throw new Error(`Unknown type ${type}.`);\n}\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field which\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * Object type returned by that field.\n *\n * @internal\n */\n\n\nfunction collectFields$1(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (const selection of selectionSet.selections) {\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          if (!shouldIncludeNode(exeContext, selection)) {\n            continue;\n          }\n\n          const name = getFieldEntryKey(selection);\n\n          if (!(name in fields)) {\n            fields[name] = [];\n          }\n\n          fields[name].push(selection);\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\n            continue;\n          }\n\n          collectFields$1(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        {\n          const fragName = selection.name.value;\n\n          if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {\n            continue;\n          }\n\n          visitedFragmentNames[fragName] = true;\n          const fragment = exeContext.fragments[fragName];\n\n          if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\n            continue;\n          }\n\n          collectFields$1(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n\n  return fields;\n}\n/**\n * Determines if a field should be included based on the @include and @skip\n * directives, where @skip has higher precedence than @include.\n */\n\n\nfunction shouldIncludeNode(exeContext, node) {\n  const skip = getDirectiveValues$1(GraphQLSkipDirective, node, exeContext.variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n    return false;\n  }\n\n  const include = getDirectiveValues$1(GraphQLIncludeDirective, node, exeContext.variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\n\n\nfunction doesFragmentConditionMatch(exeContext, fragment, type) {\n  const typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  const conditionalType = typeFromAST(exeContext.schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return exeContext.schema.isPossibleType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\n\n\nfunction getFieldEntryKey(node) {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return node.alias ? node.alias.value : node.name.value;\n}\n/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\n\n\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n  let $return;\n  let abruptClose;\n\n  if (typeof iterator.return === 'function') {\n    $return = iterator.return;\n\n    abruptClose = error => {\n      const rethrow = () => Promise.reject(error);\n\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result) {\n    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  let mapReject;\n\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    const reject = rejectCallback;\n\n    mapReject = error => asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n  }\n\n  return {\n    next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n\n    return() {\n      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n\n    throw(error) {\n      if (typeof iterator.throw === 'function') {\n        return iterator.throw(error).then(mapResult, mapReject);\n      }\n\n      return Promise.reject(error).catch(abruptClose);\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nfunction asyncMapValue(value, callback) {\n  return new Promise(resolve => resolve(callback(value)));\n}\n\nfunction iteratorResult(value) {\n  return {\n    value,\n    done: false\n  };\n}\n\nfunction astFromType(type) {\n  if (isNonNullType(type)) {\n    const innerType = astFromType(type.ofType);\n\n    if (innerType.kind === Kind.NON_NULL_TYPE) {\n      throw new Error(`Invalid type node ${JSON.stringify(type)}. Inner type of non-null type cannot be a non-null type.`);\n    }\n\n    return {\n      kind: Kind.NON_NULL_TYPE,\n      type: innerType\n    };\n  } else if (isListType(type)) {\n    return {\n      kind: Kind.LIST_TYPE,\n      type: astFromType(type.ofType)\n    };\n  }\n\n  return {\n    kind: Kind.NAMED_TYPE,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    }\n  };\n}\n\nfunction updateArgument(argName, argType, argumentNodes, variableDefinitionsMap, variableValues, newArg) {\n  let varName;\n  let numGeneratedVariables = 0;\n\n  do {\n    varName = `_v${(numGeneratedVariables++).toString()}_${argName}`;\n  } while (varName in variableDefinitionsMap);\n\n  argumentNodes[argName] = {\n    kind: Kind.ARGUMENT,\n    name: {\n      kind: Kind.NAME,\n      value: argName\n    },\n    value: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName\n      }\n    }\n  };\n  variableDefinitionsMap[varName] = {\n    kind: Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName\n      }\n    },\n    type: astFromType(argType)\n  };\n\n  if (newArg === undefined) {\n    delete variableValues[varName];\n  } else {\n    variableValues[varName] = newArg;\n  }\n}\n\nfunction implementsAbstractType(schema, typeA, typeB) {\n  if (typeA === typeB) {\n    return true;\n  } else if (isCompositeType(typeA) && isCompositeType(typeB)) {\n    return doTypesOverlap(schema, typeA, typeB);\n  }\n\n  return false;\n}\n\nconst ERROR_SYMBOL = Symbol('subschemaErrors');\n\nfunction relocatedError(originalError, path) {\n  return new GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);\n}\n\nfunction slicedError(originalError) {\n  return relocatedError(originalError, originalError.path != null ? originalError.path.slice(1) : undefined);\n}\n\nfunction getErrorsByPathSegment(errors) {\n  const record = Object.create(null);\n  errors.forEach(error => {\n    if (!error.path || error.path.length < 2) {\n      return;\n    }\n\n    const pathSegment = error.path[1];\n    const current = pathSegment in record ? record[pathSegment] : [];\n    current.push(slicedError(error));\n    record[pathSegment] = current;\n  });\n  return record;\n}\n\nfunction setErrors(result, errors) {\n  result[ERROR_SYMBOL] = errors;\n}\n\nfunction getErrors(result, pathSegment) {\n  const errors = result != null ? result[ERROR_SYMBOL] : result;\n\n  if (!Array.isArray(errors)) {\n    return null;\n  }\n\n  const fieldErrors = [];\n\n  for (const error of errors) {\n    if (!error.path || error.path[0] === pathSegment) {\n      fieldErrors.push(error);\n    }\n  }\n\n  return fieldErrors;\n}\n\nfunction inputFieldToFieldConfig(field) {\n  return {\n    description: field.description,\n    type: field.type,\n    defaultValue: field.defaultValue,\n    extensions: field.extensions,\n    astNode: field.astNode\n  };\n}\n\nfunction fieldToFieldConfig(field) {\n  return {\n    description: field.description,\n    type: field.type,\n    args: argsToFieldConfigArgumentMap(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode\n  };\n}\n\nfunction argsToFieldConfigArgumentMap(args) {\n  const newArguments = {};\n  args.forEach(arg => {\n    newArguments[arg.name] = argumentToArgumentConfig(arg);\n  });\n  return newArguments;\n}\n\nfunction argumentToArgumentConfig(arg) {\n  return {\n    description: arg.description,\n    type: arg.type,\n    defaultValue: arg.defaultValue,\n    extensions: arg.extensions,\n    astNode: arg.astNode\n  };\n}\n\nfunction observableToAsyncIterable(observable) {\n  const pullQueue = [];\n  const pushQueue = [];\n  let listening = true;\n\n  const pushValue = value => {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({\n        value,\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value\n      });\n    }\n  };\n\n  const pushError = error => {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value: {\n          errors: [error]\n        }\n      });\n    }\n  };\n\n  const pullValue = () => new Promise(resolve => {\n    if (pushQueue.length !== 0) {\n      const element = pushQueue.shift(); // either {value: {errors: [...]}} or {value: ...}\n\n      resolve({ ...element,\n        done: false\n      });\n    } else {\n      pullQueue.push(resolve);\n    }\n  });\n\n  const subscription = observable.subscribe({\n    next(value) {\n      pushValue(value);\n    },\n\n    error(err) {\n      pushError(err);\n    }\n\n  });\n\n  const emptyQueue = () => {\n    if (listening) {\n      listening = false;\n      subscription.unsubscribe();\n      pullQueue.forEach(resolve => resolve({\n        value: undefined,\n        done: true\n      }));\n      pullQueue.length = 0;\n      pushQueue.length = 0;\n    }\n  };\n\n  return {\n    next() {\n      return listening ? pullValue() : this.return();\n    },\n\n    return() {\n      emptyQueue();\n      return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n\n    throw(error) {\n      emptyQueue();\n      return Promise.reject(error);\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n}\n\nfunction visitData(data, enter, leave) {\n  if (Array.isArray(data)) {\n    return data.map(value => visitData(value, enter, leave));\n  } else if (typeof data === 'object') {\n    const newData = enter != null ? enter(data) : data;\n\n    if (newData != null) {\n      Object.keys(newData).forEach(key => {\n        const value = newData[key];\n        newData[key] = visitData(value, enter, leave);\n      });\n    }\n\n    return leave != null ? leave(newData) : newData;\n  }\n\n  return data;\n}\n\nfunction visitErrors(errors, visitor) {\n  return errors.map(error => visitor(error));\n}\n\nfunction visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n  const partialExecutionContext = {\n    schema,\n    fragments: request.document.definitions.reduce((acc, def) => {\n      if (def.kind === Kind.FRAGMENT_DEFINITION) {\n        acc[def.name.value] = def;\n      }\n\n      return acc;\n    }, {}),\n    variableValues: request.variables\n  };\n  const errorInfo = {\n    segmentInfoMap: new Map(),\n    unpathedErrors: []\n  };\n  const data = result.data;\n  const errors = result.errors;\n  const visitingErrors = errors != null && errorVisitorMap != null;\n\n  if (data != null) {\n    result.data = visitRoot(data, getOperationAST(request.document, undefined), partialExecutionContext, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n  }\n\n  if (visitingErrors) {\n    result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n  }\n\n  return result;\n}\n\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n  return errors.map(error => {\n    const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n\n    if (pathSegmentsInfo == null) {\n      return error;\n    }\n\n    return pathSegmentsInfo.reduceRight((acc, segmentInfo) => {\n      const typeName = segmentInfo.type.name;\n      const typeVisitorMap = errorVisitorMap[typeName];\n\n      if (typeVisitorMap == null) {\n        return acc;\n      }\n\n      const errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n      return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n    }, error);\n  });\n}\n\nfunction visitRoot(root, operation, exeContext, resultVisitorMap, errors, errorInfo) {\n  const operationRootType = getOperationRootType(exeContext.schema, operation);\n  const collectedFields = collectFields$1(exeContext, operationRootType, operation.selectionSet, Object.create(null), Object.create(null));\n  return visitObjectValue(root, operationRootType, collectedFields, exeContext, resultVisitorMap, 0, errors, errorInfo);\n}\n\nfunction visitObjectValue(object, type, fieldNodeMap, exeContext, resultVisitorMap, pathIndex, errors, errorInfo) {\n  const fieldMap = type.getFields();\n  const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n  const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n  const newObject = enterObject != null ? enterObject(object) : object;\n  let sortedErrors;\n  let errorMap;\n\n  if (errors != null) {\n    sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n    errorMap = sortedErrors.errorMap;\n    errorInfo.unpathedErrors = errorInfo.unpathedErrors.concat(sortedErrors.unpathedErrors);\n  }\n\n  Object.keys(fieldNodeMap).forEach(responseKey => {\n    const subFieldNodes = fieldNodeMap[responseKey];\n    const fieldName = subFieldNodes[0].name.value;\n    const fieldType = fieldMap[fieldName].type;\n    const newPathIndex = pathIndex + 1;\n    let fieldErrors;\n\n    if (errors != null) {\n      fieldErrors = errorMap[responseKey];\n\n      if (fieldErrors != null) {\n        delete errorMap[responseKey];\n      }\n\n      addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n    }\n\n    const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, exeContext, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n    updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n  });\n  const oldTypename = newObject.__typename;\n\n  if (oldTypename != null) {\n    updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n  }\n\n  if (errors != null) {\n    Object.keys(errorMap).forEach(unknownResponseKey => {\n      errorInfo.unpathedErrors = errorInfo.unpathedErrors.concat(errorMap[unknownResponseKey]);\n    });\n  }\n\n  const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n  return leaveObject != null ? leaveObject(newObject) : newObject;\n}\n\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n  if (typeVisitorMap == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n\n  const fieldVisitor = typeVisitorMap[fieldName];\n\n  if (fieldVisitor == null) {\n    object[responseKey] = newValue;\n    return;\n  }\n\n  const visitedValue = fieldVisitor(newValue);\n\n  if (visitedValue === undefined) {\n    delete object[responseKey];\n    return;\n  }\n\n  object[responseKey] = visitedValue;\n}\n\nfunction visitListValue(list, returnType, fieldNodes, exeContext, resultVisitorMap, pathIndex, errors, errorInfo) {\n  return list.map(listMember => visitFieldValue(listMember, returnType, fieldNodes, exeContext, resultVisitorMap, pathIndex + 1, errors, errorInfo));\n}\n\nfunction visitFieldValue(value, returnType, fieldNodes, exeContext, resultVisitorMap, pathIndex, errors = [], errorInfo) {\n  if (value == null) {\n    return value;\n  }\n\n  const nullableType = getNullableType(returnType);\n\n  if (isListType(nullableType)) {\n    return visitListValue(value, nullableType.ofType, fieldNodes, exeContext, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if (isAbstractType(nullableType)) {\n    const finalType = exeContext.schema.getType(value.__typename);\n    const collectedFields = collectSubFields(exeContext, finalType, fieldNodes);\n    return visitObjectValue(value, finalType, collectedFields, exeContext, resultVisitorMap, pathIndex, errors, errorInfo);\n  } else if (isObjectType(nullableType)) {\n    const collectedFields = collectSubFields(exeContext, nullableType, fieldNodes);\n    return visitObjectValue(value, nullableType, collectedFields, exeContext, resultVisitorMap, pathIndex, errors, errorInfo);\n  }\n\n  const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n\n  if (typeVisitorMap == null) {\n    return value;\n  }\n\n  const visitedValue = typeVisitorMap(value);\n  return visitedValue === undefined ? value : visitedValue;\n}\n\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n  const errorMap = Object.create(null);\n  const unpathedErrors = [];\n  errors.forEach(error => {\n    var _a;\n\n    const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n\n    if (pathSegment == null) {\n      unpathedErrors.push(error);\n      return;\n    }\n\n    if (pathSegment in errorMap) {\n      errorMap[pathSegment].push(error);\n    } else {\n      errorMap[pathSegment] = [error];\n    }\n  });\n  return {\n    errorMap,\n    unpathedErrors\n  };\n}\n\nfunction addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {\n  errors.forEach(error => {\n    const segmentInfo = {\n      type,\n      fieldName,\n      pathIndex\n    };\n    const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n\n    if (pathSegmentsInfo == null) {\n      errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n    } else {\n      pathSegmentsInfo.push(segmentInfo);\n    }\n  });\n}\n\nfunction collectSubFields(exeContext, type, fieldNodes) {\n  let subFieldNodes = Object.create(null);\n  const visitedFragmentNames = Object.create(null);\n  fieldNodes.forEach(fieldNode => {\n    subFieldNodes = collectFields$1(exeContext, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n  });\n  return subFieldNodes;\n}\n\nfunction valueMatchesCriteria(value, criteria) {\n  if (value == null) {\n    return value === criteria;\n  } else if (Array.isArray(value)) {\n    return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));\n  } else if (typeof value === 'object') {\n    return typeof criteria === 'object' && criteria && Object.keys(criteria).every(propertyName => valueMatchesCriteria(value[propertyName], criteria[propertyName]));\n  } else if (criteria instanceof RegExp) {\n    return criteria.test(value);\n  }\n\n  return value === criteria;\n}\n\nexport { ERROR_SYMBOL, MapperKind, SchemaDirectiveVisitor, SchemaVisitor, VisitSchemaKind, addTypes, appendObjectFields, applyRequestTransforms, applyResultTransforms, applySchemaTransforms, argsToFieldConfigArgumentMap, argumentToArgumentConfig, asArray, buildOperationNodeForField, checkValidationErrors, cloneDirective, cloneSchema, cloneType, collectFields$1 as collectFields, compareNodes, compareStrings, concatInlineFragments, correctASTNodes, createNamedStub, createSchemaDefinition, createStub, debugLog, fieldToFieldConfig, filterSchema, fixSchemaAst, fixWindowsPath, flattenArray, forEachDefaultValue, forEachField, getArgumentValues, getBuiltInForStub, getDirectives, getErrors, getErrorsByPathSegment, getFieldsWithDirectives, getImplementingTypes, getLeadingCommentBlock, getResolversFromSchema, getResponseKeyFromInfo, getUserTypesFromSchema, healSchema, healTypes, hoistFieldNodes, implementsAbstractType, inputFieldToFieldConfig, isDescribable, isDocumentString, isEqual, isNamedStub, isNotEqual, isValidPath, mapAsyncIterator, mapSchema, mergeDeep, modifyObjectFields, nodeToString, observableToAsyncIterable, parseFragmentToInlineFragment, parseGraphQLJSON, parseGraphQLSDL, parseInputValue, parseInputValueLiteral, parseSelectionSet, preAliasFieldNode, printSchemaWithDirectives, pruneSchema, relocatedError, removeObjectFields, renameFieldNode, renameType, rewireTypes, selectObjectFields, serializeInputValue, setErrors, slicedError, transformCommentsToDescriptions, transformInputValue, typeContainsSelectionSet, typesContainSelectionSet, updateArgument, validateGraphQlDocuments, valueMatchesCriteria, visitData, visitErrors, visitResult, visitSchema, wrapFieldNode };","map":{"version":3,"sources":["../../../dist/utils/src/helpers.js","../../../dist/utils/src/debug-log.js","../../../dist/utils/src/fix-windows-path.js","../../../dist/utils/src/flatten-array.js","../../../dist/utils/src/inspect.js","../../../dist/utils/src/getArgumentValues.js","../../../dist/utils/src/get-directives.js","../../../dist/utils/src/get-fields-with-directives.js","../../../dist/utils/src/get-implementing-types.js","../../../dist/utils/src/create-schema-definition.js","../../../dist/utils/src/print-schema-with-directives.js","../../../dist/utils/src/validate-documents.js","../../../dist/utils/src/fix-schema-ast.js","../../../node_modules/graphql/language/blockString.mjs","../../../dist/utils/src/parse-graphql-sdl.js","../../../dist/utils/src/parse-graphql-json.js","../../../dist/utils/src/get-user-types-from-schema.js","../../../dist/utils/src/build-operation-for-field.js","../../../dist/utils/src/Interfaces.js","../../../dist/utils/src/stub.js","../../../dist/utils/src/rewire.js","../../../dist/utils/src/transformInputValue.js","../../../dist/utils/src/mapSchema.js","../../../dist/utils/src/filterSchema.js","../../../dist/utils/src/clone.js","../../../dist/utils/src/heal.js","../../../dist/utils/src/SchemaVisitor.js","../../../dist/utils/src/visitSchema.js","../../../dist/utils/src/SchemaDirectiveVisitor.js","../../../dist/utils/src/getResolversFromSchema.js","../../../dist/utils/src/forEachField.js","../../../dist/utils/src/forEachDefaultValue.js","../../../dist/utils/src/addTypes.js","../../../dist/utils/src/prune.js","../../../dist/utils/src/mergeDeep.js","../../../dist/utils/src/fieldNodes.js","../../../dist/utils/src/fragments.js","../../../dist/utils/src/selectionSets.js","../../../dist/utils/src/getResponseKeyFromInfo.js","../../../dist/utils/src/transforms.js","../../../dist/utils/src/fields.js","../../../dist/utils/src/renameType.js","../../../dist/utils/src/collectFields.js","../../../dist/utils/src/mapAsyncIterator.js","../../../dist/utils/src/astFromType.js","../../../dist/utils/src/updateArgument.js","../../../dist/utils/src/implementsAbstractType.js","../../../dist/utils/src/errors.js","../../../dist/utils/src/toConfig.js","../../../dist/utils/src/observableToAsyncIterable.js","../../../dist/utils/src/visitResult.js","../../../dist/utils/src/valueMatchesCriteria.js"],"names":["GraphQLSource","pruneTypes","getTypeSpecifiers","collectFields","getDirectiveValues"],"mappings":"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","sourcesContent":["import { parse } from 'graphql';\nexport const asArray = (fns) => (Array.isArray(fns) ? fns : fns ? [fns] : []);\nexport function isEqual(a, b) {\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let index = 0; index < a.length; index++) {\n            if (a[index] !== b[index]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return a === b || (!a && !b);\n}\nexport function isNotEqual(a, b) {\n    return !isEqual(a, b);\n}\nexport function isDocumentString(str) {\n    // XXX: is-valid-path or is-glob treat SDL as a valid path\n    // (`scalar Date` for example)\n    // this why checking the extension is fast enough\n    // and prevent from parsing the string in order to find out\n    // if the string is a SDL\n    if (/\\.[a-z0-9]+$/i.test(str)) {\n        return false;\n    }\n    try {\n        parse(str);\n        return true;\n    }\n    catch (e) { }\n    return false;\n}\nconst invalidPathRegex = /[‘“!$%&^<=>`]/;\nexport function isValidPath(str) {\n    return typeof str === 'string' && !invalidPathRegex.test(str);\n}\nexport function compareStrings(a, b) {\n    if (a.toString() < b.toString()) {\n        return -1;\n    }\n    if (a.toString() > b.toString()) {\n        return 1;\n    }\n    return 0;\n}\nexport function nodeToString(a) {\n    if ('alias' in a) {\n        return a.alias.value;\n    }\n    if ('name' in a) {\n        return a.name.value;\n    }\n    return a.kind;\n}\nexport function compareNodes(a, b, customFn) {\n    const aStr = nodeToString(a);\n    const bStr = nodeToString(b);\n    if (typeof customFn === 'function') {\n        return customFn(aStr, bStr);\n    }\n    return compareStrings(aStr, bStr);\n}\n//# sourceMappingURL=helpers.js.map","export function debugLog(...args) {\n    if (process && process.env && process.env.DEBUG && !process.env.GQL_tools_NODEBUG) {\n        // tslint:disable-next-line: no-console\n        console.log(...args);\n    }\n}\n//# sourceMappingURL=debug-log.js.map","export const fixWindowsPath = (path) => path.replace(/\\\\/g, '/');\n//# sourceMappingURL=fix-windows-path.js.map","export const flattenArray = (arr) => arr.reduce((acc, next) => acc.concat(Array.isArray(next) ? flattenArray(next) : next), []);\n//# sourceMappingURL=flatten-array.js.map","const MAX_ARRAY_LENGTH = 10;\nconst MAX_RECURSIVE_DEPTH = 2;\n/**\n * Used to print values in error messages.\n */\nexport function inspect(value) {\n    return formatValue(value, []);\n}\nfunction formatValue(value, seenValues) {\n    switch (typeof value) {\n        case 'string':\n            return JSON.stringify(value);\n        case 'function':\n            return value.name ? `[function ${value.name}]` : '[function]';\n        case 'object':\n            if (value === null) {\n                return 'null';\n            }\n            return formatObjectValue(value, seenValues);\n        default:\n            return String(value);\n    }\n}\nfunction formatObjectValue(value, previouslySeenValues) {\n    if (previouslySeenValues.indexOf(value) !== -1) {\n        return '[Circular]';\n    }\n    const seenValues = [...previouslySeenValues, value];\n    const customInspectFn = getCustomFn(value);\n    if (customInspectFn !== undefined) {\n        const customValue = customInspectFn.call(value);\n        // check for infinite recursion\n        if (customValue !== value) {\n            return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n        }\n    }\n    else if (Array.isArray(value)) {\n        return formatArray(value, seenValues);\n    }\n    return formatObject(value, seenValues);\n}\nfunction formatObject(object, seenValues) {\n    const keys = Object.keys(object);\n    if (keys.length === 0) {\n        return '{}';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[' + getObjectTag(object) + ']';\n    }\n    const properties = keys.map(key => {\n        const value = formatValue(object[key], seenValues);\n        return key + ': ' + value;\n    });\n    return '{ ' + properties.join(', ') + ' }';\n}\nfunction formatArray(array, seenValues) {\n    if (array.length === 0) {\n        return '[]';\n    }\n    if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n        return '[Array]';\n    }\n    const len = Math.min(MAX_ARRAY_LENGTH, array.length);\n    const remaining = array.length - len;\n    const items = [];\n    for (let i = 0; i < len; ++i) {\n        items.push(formatValue(array[i], seenValues));\n    }\n    if (remaining === 1) {\n        items.push('... 1 more item');\n    }\n    else if (remaining > 1) {\n        items.push(`... ${remaining.toString(10)} more items`);\n    }\n    return '[' + items.join(', ') + ']';\n}\nfunction getCustomFn(obj) {\n    if (typeof obj.inspect === 'function') {\n        return obj.inspect;\n    }\n}\nfunction getObjectTag(obj) {\n    const tag = Object.prototype.toString\n        .call(obj)\n        .replace(/^\\[object /, '')\n        .replace(/]$/, '');\n    if (tag === 'Object' && typeof obj.constructor === 'function') {\n        const name = obj.constructor.name;\n        if (typeof name === 'string' && name !== '') {\n            return name;\n        }\n    }\n    return tag;\n}\n//# sourceMappingURL=inspect.js.map","import { valueFromAST, isNonNullType, GraphQLError, Kind, print, } from 'graphql';\nimport { inspect } from './inspect';\n/**\n * Prepares an object map of argument values given a list of argument\n * definitions and list of argument AST nodes.\n *\n * Note: The returned value is a plain Object with a prototype, since it is\n * exposed to user code. Care should be taken to not pull values from the\n * Object prototype.\n */\nexport function getArgumentValues(def, node, variableValues = {}) {\n    var _a;\n    const variableMap = Object.entries(variableValues).reduce((prev, [key, value]) => ({\n        ...prev,\n        [key]: value,\n    }), {});\n    const coercedValues = {};\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    const argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\n    const argNodeMap = argumentNodes.reduce((prev, arg) => ({\n        ...prev,\n        [arg.name.value]: arg,\n    }), {});\n    for (const argDef of def.args) {\n        const name = argDef.name;\n        const argType = argDef.type;\n        const argumentNode = argNodeMap[name];\n        if (!argumentNode) {\n            if (argDef.defaultValue !== undefined) {\n                coercedValues[name] = argDef.defaultValue;\n            }\n            else if (isNonNullType(argType)) {\n                throw new GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` + 'was not provided.', node);\n            }\n            continue;\n        }\n        const valueNode = argumentNode.value;\n        let isNull = valueNode.kind === Kind.NULL;\n        if (valueNode.kind === Kind.VARIABLE) {\n            const variableName = valueNode.name.value;\n            if (variableValues == null || !(variableName in variableMap)) {\n                if (argDef.defaultValue !== undefined) {\n                    coercedValues[name] = argDef.defaultValue;\n                }\n                else if (isNonNullType(argType)) {\n                    throw new GraphQLError(`Argument \"${name}\" of required type \"${inspect(argType)}\" ` +\n                        `was provided the variable \"$${variableName}\" which was not provided a runtime value.`, valueNode);\n                }\n                continue;\n            }\n            isNull = variableValues[variableName] == null;\n        }\n        if (isNull && isNonNullType(argType)) {\n            throw new GraphQLError(`Argument \"${name}\" of non-null type \"${inspect(argType)}\" ` + 'must not be null.', valueNode);\n        }\n        const coercedValue = valueFromAST(valueNode, argType, variableValues);\n        if (coercedValue === undefined) {\n            // Note: ValuesOfCorrectTypeRule validation should catch this before\n            // execution. This is a runtime check to ensure execution does not\n            // continue with an invalid argument value.\n            throw new GraphQLError(`Argument \"${name}\" has invalid value ${print(valueNode)}.`, valueNode);\n        }\n        coercedValues[name] = coercedValue;\n    }\n    return coercedValues;\n}\n//# sourceMappingURL=getArgumentValues.js.map","import { getArgumentValues } from './getArgumentValues';\nexport function getDirectives(schema, node) {\n    const schemaDirectives = schema && schema.getDirectives ? schema.getDirectives() : [];\n    const schemaDirectiveMap = schemaDirectives.reduce((schemaDirectiveMap, schemaDirective) => {\n        schemaDirectiveMap[schemaDirective.name] = schemaDirective;\n        return schemaDirectiveMap;\n    }, {});\n    let astNodes = [];\n    if (node.astNode) {\n        astNodes.push(node.astNode);\n    }\n    if ('extensionASTNodes' in node && node.extensionASTNodes) {\n        astNodes = [...astNodes, ...node.extensionASTNodes];\n    }\n    const result = {};\n    astNodes.forEach(astNode => {\n        if (astNode.directives) {\n            astNode.directives.forEach(directive => {\n                const schemaDirective = schemaDirectiveMap[directive.name.value];\n                if (schemaDirective) {\n                    const directiveValue = getDirectiveValues(schemaDirective, astNode);\n                    if (schemaDirective.isRepeatable) {\n                        if (result[schemaDirective.name]) {\n                            result[schemaDirective.name] = result[schemaDirective.name].concat([directiveValue]);\n                        }\n                        else {\n                            result[schemaDirective.name] = [directiveValue];\n                        }\n                    }\n                    else {\n                        result[schemaDirective.name] = directiveValue;\n                    }\n                }\n            });\n        }\n    });\n    return result;\n}\n// graphql-js getDirectiveValues does not handle repeatable directives\nfunction getDirectiveValues(directiveDef, node) {\n    if (node.directives) {\n        if (directiveDef.isRepeatable) {\n            const directiveNodes = node.directives.filter(directive => directive.name.value === directiveDef.name);\n            return directiveNodes.map(directiveNode => getArgumentValues(directiveDef, directiveNode));\n        }\n        const directiveNode = node.directives.find(directive => directive.name.value === directiveDef.name);\n        return getArgumentValues(directiveDef, directiveNode);\n    }\n}\n//# sourceMappingURL=get-directives.js.map","import { Kind, } from 'graphql';\nfunction parseDirectiveValue(value) {\n    switch (value.kind) {\n        case Kind.INT:\n            return parseInt(value.value);\n        case Kind.FLOAT:\n            return parseFloat(value.value);\n        case Kind.BOOLEAN:\n            return Boolean(value.value);\n        case Kind.STRING:\n        case Kind.ENUM:\n            return value.value;\n        case Kind.LIST:\n            return value.values.map(v => parseDirectiveValue(v));\n        case Kind.OBJECT:\n            return value.fields.reduce((prev, v) => ({ ...prev, [v.name.value]: parseDirectiveValue(v.value) }), {});\n        case Kind.NULL:\n            return null;\n        default:\n            return null;\n    }\n}\nexport function getFieldsWithDirectives(documentNode, options = {}) {\n    const result = {};\n    let selected = ['ObjectTypeDefinition', 'ObjectTypeExtension'];\n    if (options.includeInputTypes) {\n        selected = [...selected, 'InputObjectTypeDefinition', 'InputObjectTypeExtension'];\n    }\n    const allTypes = documentNode.definitions.filter(obj => selected.includes(obj.kind));\n    for (const type of allTypes) {\n        const typeName = type.name.value;\n        for (const field of type.fields) {\n            if (field.directives && field.directives.length > 0) {\n                const fieldName = field.name.value;\n                const key = `${typeName}.${fieldName}`;\n                const directives = field.directives.map(d => ({\n                    name: d.name.value,\n                    args: (d.arguments || []).reduce((prev, arg) => ({ ...prev, [arg.name.value]: parseDirectiveValue(arg.value) }), {}),\n                }));\n                result[key] = directives;\n            }\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=get-fields-with-directives.js.map","import { isObjectType } from 'graphql';\nexport function getImplementingTypes(interfaceName, schema) {\n    const allTypesMap = schema.getTypeMap();\n    const result = [];\n    for (const graphqlTypeName in allTypesMap) {\n        const graphqlType = allTypesMap[graphqlTypeName];\n        if (isObjectType(graphqlType)) {\n            const allInterfaces = graphqlType.getInterfaces();\n            if (allInterfaces.find(int => int.name === interfaceName)) {\n                result.push(graphqlType.name);\n            }\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=get-implementing-types.js.map","export function createSchemaDefinition(def, config) {\n    const schemaRoot = {};\n    if (def.query) {\n        schemaRoot.query = def.query.toString();\n    }\n    if (def.mutation) {\n        schemaRoot.mutation = def.mutation.toString();\n    }\n    if (def.subscription) {\n        schemaRoot.subscription = def.subscription.toString();\n    }\n    const fields = Object.keys(schemaRoot)\n        .map(rootType => (schemaRoot[rootType] ? `${rootType}: ${schemaRoot[rootType]}` : null))\n        .filter(a => a);\n    if (fields.length) {\n        return `schema { ${fields.join('\\n')} }`;\n    }\n    if (config && config.force) {\n        return ` schema { query: Query } `;\n    }\n    return undefined;\n}\n//# sourceMappingURL=create-schema-definition.js.map","import { print, printType, Kind, isSpecifiedScalarType, isIntrospectionType, isScalarType, parse, } from 'graphql';\nimport { createSchemaDefinition } from './create-schema-definition';\nexport function printSchemaWithDirectives(schema, _options = {}) {\n    var _a;\n    const typesMap = schema.getTypeMap();\n    const result = [getSchemaDefinition(schema)];\n    for (const typeName in typesMap) {\n        const type = typesMap[typeName];\n        const isPredefinedScalar = isScalarType(type) && isSpecifiedScalarType(type);\n        const isIntrospection = isIntrospectionType(type);\n        if (isPredefinedScalar || isIntrospection) {\n            continue;\n        }\n        // KAMIL: we might want to turn on descriptions in future\n        result.push(print((_a = correctType(typeName, typesMap)) === null || _a === void 0 ? void 0 : _a.astNode));\n    }\n    const directives = schema.getDirectives();\n    for (const directive of directives) {\n        if (directive.astNode) {\n            result.push(print(directive.astNode));\n        }\n    }\n    return result.join('\\n');\n}\nfunction extendDefinition(type) {\n    switch (type.astNode.kind) {\n        case Kind.OBJECT_TYPE_DEFINITION:\n            return {\n                ...type.astNode,\n                fields: type.astNode.fields.concat(type.extensionASTNodes.reduce((fields, node) => fields.concat(node.fields), [])),\n            };\n        case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n            return {\n                ...type.astNode,\n                fields: type.astNode.fields.concat(type.extensionASTNodes.reduce((fields, node) => fields.concat(node.fields), [])),\n            };\n        default:\n            return type.astNode;\n    }\n}\nfunction correctType(typeName, typesMap) {\n    var _a;\n    const type = typesMap[typeName];\n    type.name = typeName.toString();\n    if (type.astNode && type.extensionASTNodes) {\n        type.astNode = type.extensionASTNodes ? extendDefinition(type) : type.astNode;\n    }\n    const doc = parse(printType(type));\n    const fixedAstNode = doc.definitions[0];\n    const originalAstNode = type === null || type === void 0 ? void 0 : type.astNode;\n    if (originalAstNode) {\n        fixedAstNode.directives = originalAstNode === null || originalAstNode === void 0 ? void 0 : originalAstNode.directives;\n        if (fixedAstNode && 'fields' in fixedAstNode && originalAstNode && 'fields' in originalAstNode) {\n            for (const fieldDefinitionNode of fixedAstNode.fields) {\n                const originalFieldDefinitionNode = originalAstNode.fields.find(field => field.name.value === fieldDefinitionNode.name.value);\n                fieldDefinitionNode.directives = originalFieldDefinitionNode === null || originalFieldDefinitionNode === void 0 ? void 0 : originalFieldDefinitionNode.directives;\n                if (fieldDefinitionNode &&\n                    'arguments' in fieldDefinitionNode &&\n                    originalFieldDefinitionNode &&\n                    'arguments' in originalFieldDefinitionNode) {\n                    for (const argument of fieldDefinitionNode.arguments) {\n                        const originalArgumentNode = (_a = originalFieldDefinitionNode.arguments) === null || _a === void 0 ? void 0 : _a.find(arg => arg.name.value === argument.name.value);\n                        argument.directives = originalArgumentNode.directives;\n                    }\n                }\n            }\n        }\n        else if (fixedAstNode && 'values' in fixedAstNode && originalAstNode && 'values' in originalAstNode) {\n            for (const valueDefinitionNode of fixedAstNode.values) {\n                const originalValueDefinitionNode = originalAstNode.values.find(valueNode => valueNode.name.value === valueDefinitionNode.name.value);\n                valueDefinitionNode.directives = originalValueDefinitionNode === null || originalValueDefinitionNode === void 0 ? void 0 : originalValueDefinitionNode.directives;\n            }\n        }\n    }\n    type.astNode = fixedAstNode;\n    return type;\n}\nfunction getSchemaDefinition(schema) {\n    if (!Object.getOwnPropertyDescriptor(schema, 'astNode').get && schema.astNode) {\n        return print(schema.astNode);\n    }\n    else {\n        return createSchemaDefinition({\n            query: schema.getQueryType(),\n            mutation: schema.getMutationType(),\n            subscription: schema.getSubscriptionType(),\n        });\n    }\n}\n//# sourceMappingURL=print-schema-with-directives.js.map","import { Kind, validate, specifiedRules, } from 'graphql';\nimport AggregateError from '@ardatan/aggregate-error';\nexport async function validateGraphQlDocuments(schema, documentFiles, effectiveRules) {\n    effectiveRules = effectiveRules || createDefaultRules();\n    const allFragments = [];\n    documentFiles.forEach(documentFile => {\n        if (documentFile.document) {\n            for (const definitionNode of documentFile.document.definitions) {\n                if (definitionNode.kind === Kind.FRAGMENT_DEFINITION) {\n                    allFragments.push(definitionNode);\n                }\n            }\n        }\n    });\n    const allErrors = [];\n    await Promise.all(documentFiles.map(async (documentFile) => {\n        const documentToValidate = {\n            kind: Kind.DOCUMENT,\n            definitions: [...allFragments, ...documentFile.document.definitions].filter((definition, index, list) => {\n                if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n                    const firstIndex = list.findIndex(def => def.kind === Kind.FRAGMENT_DEFINITION && def.name.value === definition.name.value);\n                    const isDuplicated = firstIndex !== index;\n                    if (isDuplicated) {\n                        return false;\n                    }\n                }\n                return true;\n            }),\n        };\n        const errors = validate(schema, documentToValidate, effectiveRules);\n        if (errors.length > 0) {\n            allErrors.push({\n                filePath: documentFile.location,\n                errors,\n            });\n        }\n    }));\n    return allErrors;\n}\nexport function checkValidationErrors(loadDocumentErrors) {\n    if (loadDocumentErrors.length > 0) {\n        const errors = [];\n        for (const loadDocumentError of loadDocumentErrors) {\n            for (const graphQLError of loadDocumentError.errors) {\n                const error = new Error();\n                error.name = 'GraphQLDocumentError';\n                error.message = `${error.name}: ${graphQLError.message}`;\n                error.stack = error.message;\n                graphQLError.locations.forEach(location => (error.stack += `\\n    at ${loadDocumentError.filePath}:${location.line}:${location.column}`));\n                errors.push(error);\n            }\n        }\n        throw new AggregateError(errors);\n    }\n}\nfunction createDefaultRules() {\n    const ignored = ['NoUnusedFragmentsRule', 'NoUnusedVariablesRule', 'KnownDirectivesRule'];\n    // GraphQL v14 has no Rule suffix in function names\n    // Adding `*Rule` makes validation backwards compatible\n    ignored.forEach(rule => {\n        ignored.push(rule.replace(/Rule$/, ''));\n    });\n    return specifiedRules.filter((f) => !ignored.includes(f.name));\n}\n//# sourceMappingURL=validate-documents.js.map","import { buildSchema } from 'graphql';\nimport { printSchemaWithDirectives } from './print-schema-with-directives';\nfunction buildFixedSchema(schema, options) {\n    return buildSchema(printSchemaWithDirectives(schema, options), {\n        noLocation: true,\n        ...(options || {}),\n    });\n}\nexport function fixSchemaAst(schema, options) {\n    let schemaWithValidAst;\n    if (!schema.astNode) {\n        Object.defineProperty(schema, 'astNode', {\n            get() {\n                if (!schemaWithValidAst) {\n                    schemaWithValidAst = buildFixedSchema(schema, options);\n                }\n                return schemaWithValidAst.astNode;\n            },\n        });\n    }\n    if (!schema.extensionASTNodes) {\n        Object.defineProperty(schema, 'extensionASTNodes', {\n            get() {\n                if (!schemaWithValidAst) {\n                    schemaWithValidAst = buildFixedSchema(schema, options);\n                }\n                return schemaWithValidAst.extensionASTNodes;\n            },\n        });\n    }\n    return schema;\n}\n//# sourceMappingURL=fix-schema-ast.js.map","/**\n * Produces the value of a block string from its parsed raw value, similar to\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\n *\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\n *\n * @internal\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\n * @internal\n */\n\nexport function getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n/**\n * Print a block string in the indented block form by adding a leading and\n * trailing blank line. However, if a block string starts with whitespace and is\n * a single-line, adding a leading blank line would strip that whitespace.\n *\n * @internal\n */\n\n\nexport function printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var hasTrailingSlash = value[value.length - 1] === '\\\\';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}\n","import { Kind, TokenKind, parse, Source as GraphQLSource, visit, isTypeSystemDefinitionNode, print, } from 'graphql';\nimport { dedentBlockStringValue } from 'graphql/language/blockString';\nexport function parseGraphQLSDL(location, rawSDL, options = {}) {\n    let document;\n    const sdl = rawSDL;\n    let sdlModified = false;\n    try {\n        if (options.commentDescriptions && sdl.includes('#')) {\n            sdlModified = true;\n            document = transformCommentsToDescriptions(rawSDL, options);\n            // If noLocation=true, we need to make sure to print and parse it again, to remove locations,\n            // since `transformCommentsToDescriptions` must have locations set in order to transform the comments\n            // into descriptions.\n            if (options.noLocation) {\n                document = parse(print(document), options);\n            }\n        }\n        else {\n            document = parse(new GraphQLSource(sdl, location), options);\n        }\n    }\n    catch (e) {\n        if (e.message.includes('EOF')) {\n            document = {\n                kind: Kind.DOCUMENT,\n                definitions: [],\n            };\n        }\n        else {\n            throw e;\n        }\n    }\n    return {\n        location,\n        document,\n        rawSDL: sdlModified ? print(document) : sdl,\n    };\n}\nexport function getLeadingCommentBlock(node) {\n    const loc = node.loc;\n    if (!loc) {\n        return;\n    }\n    const comments = [];\n    let token = loc.startToken.prev;\n    while (token != null &&\n        token.kind === TokenKind.COMMENT &&\n        token.next &&\n        token.prev &&\n        token.line + 1 === token.next.line &&\n        token.line !== token.prev.line) {\n        const value = String(token.value);\n        comments.push(value);\n        token = token.prev;\n    }\n    return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\nexport function transformCommentsToDescriptions(sourceSdl, options = {}) {\n    const parsedDoc = parse(sourceSdl, {\n        ...options,\n        noLocation: false,\n    });\n    const modifiedDoc = visit(parsedDoc, {\n        leave: (node) => {\n            if (isDescribable(node)) {\n                const rawValue = getLeadingCommentBlock(node);\n                if (rawValue !== undefined) {\n                    const commentsBlock = dedentBlockStringValue('\\n' + rawValue);\n                    const isBlock = commentsBlock.includes('\\n');\n                    if (!node.description) {\n                        return {\n                            ...node,\n                            description: {\n                                kind: Kind.STRING,\n                                value: commentsBlock,\n                                block: isBlock,\n                            },\n                        };\n                    }\n                    else {\n                        return {\n                            ...node,\n                            description: {\n                                ...node.description,\n                                value: node.description.value + '\\n' + commentsBlock,\n                                block: true,\n                            },\n                        };\n                    }\n                }\n            }\n        },\n    });\n    return modifiedDoc;\n}\nexport function isDescribable(node) {\n    return (isTypeSystemDefinitionNode(node) ||\n        node.kind === Kind.FIELD_DEFINITION ||\n        node.kind === Kind.INPUT_VALUE_DEFINITION ||\n        node.kind === Kind.ENUM_VALUE_DEFINITION);\n}\n//# sourceMappingURL=parse-graphql-sdl.js.map","import { buildClientSchema } from 'graphql';\nimport { printSchemaWithDirectives } from './print-schema-with-directives';\nimport { parseGraphQLSDL } from './parse-graphql-sdl';\nfunction stripBOM(content) {\n    content = content.toString();\n    // Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n    // because the buffer-to-string conversion in `fs.readFileSync()`\n    // translates it to FEFF, the UTF-16 BOM.\n    if (content.charCodeAt(0) === 0xfeff) {\n        content = content.slice(1);\n    }\n    return content;\n}\nfunction parseBOM(content) {\n    return JSON.parse(stripBOM(content));\n}\nexport function parseGraphQLJSON(location, jsonContent, options) {\n    let parsedJson = parseBOM(jsonContent);\n    if (parsedJson.data) {\n        parsedJson = parsedJson.data;\n    }\n    if (parsedJson.kind === 'Document') {\n        const document = parsedJson;\n        return {\n            location,\n            document,\n        };\n    }\n    else if (parsedJson.__schema) {\n        const schema = buildClientSchema(parsedJson, options);\n        const rawSDL = printSchemaWithDirectives(schema, options);\n        return {\n            location,\n            document: parseGraphQLSDL(location, rawSDL, options).document,\n            rawSDL,\n            schema,\n        };\n    }\n    throw new Error(`Not valid JSON content`);\n}\n//# sourceMappingURL=parse-graphql-json.js.map","import { isObjectType } from 'graphql';\n/**\n * Get all GraphQL types from schema without:\n *\n * - Query, Mutation, Subscription objects\n * - Internal scalars added by parser\n *\n * @param schema\n */\nexport function getUserTypesFromSchema(schema) {\n    const allTypesMap = schema.getTypeMap();\n    // tslint:disable-next-line: no-unnecessary-local-variable\n    const modelTypes = Object.values(allTypesMap).filter((graphqlType) => {\n        if (isObjectType(graphqlType)) {\n            // Filter out private types\n            if (graphqlType.name.startsWith('__')) {\n                return false;\n            }\n            if (schema.getMutationType() && graphqlType.name === schema.getMutationType().name) {\n                return false;\n            }\n            if (schema.getQueryType() && graphqlType.name === schema.getQueryType().name) {\n                return false;\n            }\n            if (schema.getSubscriptionType() && graphqlType.name === schema.getSubscriptionType().name) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    });\n    return modelTypes;\n}\n//# sourceMappingURL=get-user-types-from-schema.js.map","import { isObjectType, getNamedType, isUnionType, isNonNullType, isScalarType, isListType, isInterfaceType, isEnumType, Kind, } from 'graphql';\nimport { camelCase } from 'camel-case';\nlet operationVariables = [];\nlet fieldTypeMap = new Map();\nfunction addOperationVariable(variable) {\n    operationVariables.push(variable);\n}\nfunction resetOperationVariables() {\n    operationVariables = [];\n}\nfunction resetFieldMap() {\n    fieldTypeMap = new Map();\n}\nfunction buildOperationName(name) {\n    return camelCase(name);\n}\nexport function buildOperationNodeForField({ schema, kind, field, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields = true, }) {\n    resetOperationVariables();\n    resetFieldMap();\n    const operationNode = buildOperationAndCollectVariables({\n        schema,\n        fieldName: field,\n        kind,\n        models: models || [],\n        ignore: ignore || [],\n        depthLimit: depthLimit || Infinity,\n        circularReferenceDepth: circularReferenceDepth || 1,\n        argNames,\n        selectedFields,\n    });\n    // attach variables\n    operationNode.variableDefinitions = [...operationVariables];\n    resetOperationVariables();\n    resetFieldMap();\n    return operationNode;\n}\nfunction buildOperationAndCollectVariables({ schema, fieldName, kind, models, ignore, depthLimit, circularReferenceDepth, argNames, selectedFields, }) {\n    const typeMap = {\n        query: schema.getQueryType(),\n        mutation: schema.getMutationType(),\n        subscription: schema.getSubscriptionType(),\n    };\n    const type = typeMap[kind];\n    const field = type.getFields()[fieldName];\n    const operationName = buildOperationName(`${fieldName}_${kind}`);\n    if (field.args) {\n        field.args.forEach(arg => {\n            const argName = arg.name;\n            if (!argNames || argNames.includes(argName)) {\n                addOperationVariable(resolveVariable(arg, argName));\n            }\n        });\n    }\n    return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: kind,\n        name: {\n            kind: 'Name',\n            value: operationName,\n        },\n        variableDefinitions: [],\n        selectionSet: {\n            kind: Kind.SELECTION_SET,\n            selections: [\n                resolveField({\n                    type,\n                    field,\n                    models,\n                    firstCall: true,\n                    path: [],\n                    ancestors: [],\n                    ignore,\n                    depthLimit,\n                    circularReferenceDepth,\n                    schema,\n                    depth: 0,\n                    argNames,\n                    selectedFields,\n                }),\n            ],\n        },\n    };\n}\nfunction resolveSelectionSet({ parent, type, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, }) {\n    if (typeof selectedFields === 'boolean' && depth > depthLimit) {\n        return;\n    }\n    if (isUnionType(type)) {\n        const types = type.getTypes();\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (isInterfaceType(type)) {\n        const types = Object.values(schema.getTypeMap()).filter((t) => isObjectType(t) && t.getInterfaces().includes(type));\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: types\n                .filter(t => !hasCircularRef([...ancestors, t], {\n                depth: circularReferenceDepth,\n            }))\n                .map(t => {\n                return {\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                        kind: Kind.NAMED_TYPE,\n                        name: {\n                            kind: Kind.NAME,\n                            value: t.name,\n                        },\n                    },\n                    selectionSet: resolveSelectionSet({\n                        parent: type,\n                        type: t,\n                        models,\n                        path,\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields,\n                    }),\n                };\n            })\n                .filter(fragmentNode => { var _a, _b; return ((_b = (_a = fragmentNode === null || fragmentNode === void 0 ? void 0 : fragmentNode.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length) > 0; }),\n        };\n    }\n    if (isObjectType(type)) {\n        const isIgnored = ignore.includes(type.name) || ignore.includes(`${parent.name}.${path[path.length - 1]}`);\n        const isModel = models.includes(type.name);\n        if (!firstCall && isModel && !isIgnored) {\n            return {\n                kind: Kind.SELECTION_SET,\n                selections: [\n                    {\n                        kind: Kind.FIELD,\n                        name: {\n                            kind: Kind.NAME,\n                            value: 'id',\n                        },\n                    },\n                ],\n            };\n        }\n        const fields = type.getFields();\n        return {\n            kind: Kind.SELECTION_SET,\n            selections: Object.keys(fields)\n                .filter(fieldName => {\n                return !hasCircularRef([...ancestors, getNamedType(fields[fieldName].type)], {\n                    depth: circularReferenceDepth,\n                });\n            })\n                .map(fieldName => {\n                const selectedSubFields = typeof selectedFields === 'object' ? selectedFields[fieldName] : true;\n                if (selectedSubFields) {\n                    return resolveField({\n                        type: type,\n                        field: fields[fieldName],\n                        models,\n                        path: [...path, fieldName],\n                        ancestors,\n                        ignore,\n                        depthLimit,\n                        circularReferenceDepth,\n                        schema,\n                        depth,\n                        argNames,\n                        selectedFields: selectedSubFields,\n                    });\n                }\n            })\n                .filter(f => {\n                var _a, _b;\n                if (f) {\n                    if ('selectionSet' in f) {\n                        return (_b = (_a = f.selectionSet) === null || _a === void 0 ? void 0 : _a.selections) === null || _b === void 0 ? void 0 : _b.length;\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                return false;\n            }),\n        };\n    }\n}\nfunction resolveVariable(arg, name) {\n    function resolveVariableType(type) {\n        if (isListType(type)) {\n            return {\n                kind: Kind.LIST_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        if (isNonNullType(type)) {\n            return {\n                kind: Kind.NON_NULL_TYPE,\n                type: resolveVariableType(type.ofType),\n            };\n        }\n        return {\n            kind: Kind.NAMED_TYPE,\n            name: {\n                kind: Kind.NAME,\n                value: type.name,\n            },\n        };\n    }\n    return {\n        kind: Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: Kind.VARIABLE,\n            name: {\n                kind: Kind.NAME,\n                value: name || arg.name,\n            },\n        },\n        type: resolveVariableType(arg.type),\n    };\n}\nfunction getArgumentName(name, path) {\n    return camelCase([...path, name].join('_'));\n}\nfunction resolveField({ type, field, models, firstCall, path, ancestors, ignore, depthLimit, circularReferenceDepth, schema, depth, argNames, selectedFields, }) {\n    const namedType = getNamedType(field.type);\n    let args = [];\n    let removeField = false;\n    if (field.args && field.args.length) {\n        args = field.args\n            .map(arg => {\n            const argumentName = getArgumentName(arg.name, path);\n            if (argNames && !argNames.includes(argumentName)) {\n                if (isNonNullType(arg.type)) {\n                    removeField = true;\n                }\n                return null;\n            }\n            if (!firstCall) {\n                addOperationVariable(resolveVariable(arg, argumentName));\n            }\n            return {\n                kind: Kind.ARGUMENT,\n                name: {\n                    kind: Kind.NAME,\n                    value: arg.name,\n                },\n                value: {\n                    kind: Kind.VARIABLE,\n                    name: {\n                        kind: Kind.NAME,\n                        value: getArgumentName(arg.name, path),\n                    },\n                },\n            };\n        })\n            .filter(Boolean);\n    }\n    if (removeField) {\n        return null;\n    }\n    const fieldPath = [...path, field.name];\n    const fieldPathStr = fieldPath.join('.');\n    let fieldName = field.name;\n    if (fieldTypeMap.has(fieldPathStr) && fieldTypeMap.get(fieldPathStr) !== field.type.toString()) {\n        fieldName += field.type.toString().replace('!', 'NonNull');\n    }\n    fieldTypeMap.set(fieldPathStr, field.type.toString());\n    if (!isScalarType(namedType) && !isEnumType(namedType)) {\n        return {\n            kind: Kind.FIELD,\n            name: {\n                kind: Kind.NAME,\n                value: field.name,\n            },\n            ...(fieldName !== field.name && { alias: { kind: Kind.NAME, value: fieldName } }),\n            selectionSet: resolveSelectionSet({\n                parent: type,\n                type: namedType,\n                models,\n                firstCall,\n                path: fieldPath,\n                ancestors: [...ancestors, type],\n                ignore,\n                depthLimit,\n                circularReferenceDepth,\n                schema,\n                depth: depth + 1,\n                argNames,\n                selectedFields,\n            }) || undefined,\n            arguments: args,\n        };\n    }\n    return {\n        kind: Kind.FIELD,\n        name: {\n            kind: Kind.NAME,\n            value: field.name,\n        },\n        ...(fieldName !== field.name && { alias: { kind: Kind.NAME, value: fieldName } }),\n        arguments: args,\n    };\n}\nfunction hasCircularRef(types, config = {\n    depth: 1,\n}) {\n    const type = types[types.length - 1];\n    if (isScalarType(type)) {\n        return false;\n    }\n    const size = types.filter(t => t.name === type.name).length;\n    return size > config.depth;\n}\n//# sourceMappingURL=build-operation-for-field.js.map","export var VisitSchemaKind;\n(function (VisitSchemaKind) {\n    VisitSchemaKind[\"TYPE\"] = \"VisitSchemaKind.TYPE\";\n    VisitSchemaKind[\"SCALAR_TYPE\"] = \"VisitSchemaKind.SCALAR_TYPE\";\n    VisitSchemaKind[\"ENUM_TYPE\"] = \"VisitSchemaKind.ENUM_TYPE\";\n    VisitSchemaKind[\"COMPOSITE_TYPE\"] = \"VisitSchemaKind.COMPOSITE_TYPE\";\n    VisitSchemaKind[\"OBJECT_TYPE\"] = \"VisitSchemaKind.OBJECT_TYPE\";\n    VisitSchemaKind[\"INPUT_OBJECT_TYPE\"] = \"VisitSchemaKind.INPUT_OBJECT_TYPE\";\n    VisitSchemaKind[\"ABSTRACT_TYPE\"] = \"VisitSchemaKind.ABSTRACT_TYPE\";\n    VisitSchemaKind[\"UNION_TYPE\"] = \"VisitSchemaKind.UNION_TYPE\";\n    VisitSchemaKind[\"INTERFACE_TYPE\"] = \"VisitSchemaKind.INTERFACE_TYPE\";\n    VisitSchemaKind[\"ROOT_OBJECT\"] = \"VisitSchemaKind.ROOT_OBJECT\";\n    VisitSchemaKind[\"QUERY\"] = \"VisitSchemaKind.QUERY\";\n    VisitSchemaKind[\"MUTATION\"] = \"VisitSchemaKind.MUTATION\";\n    VisitSchemaKind[\"SUBSCRIPTION\"] = \"VisitSchemaKind.SUBSCRIPTION\";\n})(VisitSchemaKind || (VisitSchemaKind = {}));\nexport var MapperKind;\n(function (MapperKind) {\n    MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n    MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n    MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n    MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n    MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n    MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n    MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n    MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n    MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n    MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n    MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n    MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n    MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n    MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n    MapperKind[\"FIELD\"] = \"MapperKind.FIELD\";\n    MapperKind[\"COMPOSITE_FIELD\"] = \"MapperKind.COMPOSITE_FIELD\";\n    MapperKind[\"OBJECT_FIELD\"] = \"MapperKind.OBJECT_FIELD\";\n    MapperKind[\"ROOT_FIELD\"] = \"MapperKind.ROOT_FIELD\";\n    MapperKind[\"QUERY_ROOT_FIELD\"] = \"MapperKind.QUERY_ROOT_FIELD\";\n    MapperKind[\"MUTATION_ROOT_FIELD\"] = \"MapperKind.MUTATION_ROOT_FIELD\";\n    MapperKind[\"SUBSCRIPTION_ROOT_FIELD\"] = \"MapperKind.SUBSCRIPTION_ROOT_FIELD\";\n    MapperKind[\"INTERFACE_FIELD\"] = \"MapperKind.INTERFACE_FIELD\";\n    MapperKind[\"INPUT_OBJECT_FIELD\"] = \"MapperKind.INPUT_OBJECT_FIELD\";\n    MapperKind[\"ARGUMENT\"] = \"MapperKind.ARGUMENT\";\n    MapperKind[\"ENUM_VALUE\"] = \"MapperKind.ENUM_VALUE\";\n})(MapperKind || (MapperKind = {}));\n//# sourceMappingURL=Interfaces.js.map","import { GraphQLObjectType, GraphQLInterfaceType, GraphQLInputObjectType, GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID, isObjectType, isInterfaceType, isInputObjectType, Kind, GraphQLList, GraphQLNonNull, } from 'graphql';\nexport function createNamedStub(name, type) {\n    let constructor;\n    if (type === 'object') {\n        constructor = GraphQLObjectType;\n    }\n    else if (type === 'interface') {\n        constructor = GraphQLInterfaceType;\n    }\n    else {\n        constructor = GraphQLInputObjectType;\n    }\n    return new constructor({\n        name,\n        fields: {\n            __fake: {\n                type: GraphQLString,\n            },\n        },\n    });\n}\nexport function createStub(node, type) {\n    switch (node.kind) {\n        case Kind.LIST_TYPE:\n            return new GraphQLList(createStub(node.type, type));\n        case Kind.NON_NULL_TYPE:\n            return new GraphQLNonNull(createStub(node.type, type));\n        default:\n            if (type === 'output') {\n                return createNamedStub(node.name.value, 'object');\n            }\n            return createNamedStub(node.name.value, 'input');\n    }\n}\nexport function isNamedStub(type) {\n    if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n        const fields = type.getFields();\n        const fieldNames = Object.keys(fields);\n        return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';\n    }\n    return false;\n}\nexport function getBuiltInForStub(type) {\n    switch (type.name) {\n        case GraphQLInt.name:\n            return GraphQLInt;\n        case GraphQLFloat.name:\n            return GraphQLFloat;\n        case GraphQLString.name:\n            return GraphQLString;\n        case GraphQLBoolean.name:\n            return GraphQLBoolean;\n        case GraphQLID.name:\n            return GraphQLID;\n        default:\n            return type;\n    }\n}\n//# sourceMappingURL=stub.js.map","import { GraphQLDirective, GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLObjectType, GraphQLNonNull, GraphQLScalarType, GraphQLUnionType, isInterfaceType, isEnumType, isInputObjectType, isListType, isNamedType, isNonNullType, isObjectType, isScalarType, isUnionType, isSpecifiedScalarType, isSpecifiedDirective, } from 'graphql';\nimport { getBuiltInForStub, isNamedStub } from './stub';\nexport function rewireTypes(originalTypeMap, directives, options = {\n    skipPruning: false,\n}) {\n    const referenceTypeMap = Object.create(null);\n    Object.keys(originalTypeMap).forEach(typeName => {\n        referenceTypeMap[typeName] = originalTypeMap[typeName];\n    });\n    const newTypeMap = Object.create(null);\n    Object.keys(referenceTypeMap).forEach(typeName => {\n        const namedType = referenceTypeMap[typeName];\n        if (namedType == null || typeName.startsWith('__')) {\n            return;\n        }\n        const newName = namedType.name;\n        if (newName.startsWith('__')) {\n            return;\n        }\n        if (newTypeMap[newName] != null) {\n            throw new Error(`Duplicate schema type name ${newName}`);\n        }\n        newTypeMap[newName] = namedType;\n    });\n    Object.keys(newTypeMap).forEach(typeName => {\n        newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n    });\n    const newDirectives = directives.map(directive => rewireDirective(directive));\n    // TODO:\n    // consider removing the default level of pruning in v7,\n    // see comments below on the pruneTypes function.\n    return options.skipPruning\n        ? {\n            typeMap: newTypeMap,\n            directives: newDirectives,\n        }\n        : pruneTypes(newTypeMap, newDirectives);\n    function rewireDirective(directive) {\n        if (isSpecifiedDirective(directive)) {\n            return directive;\n        }\n        const directiveConfig = directive.toConfig();\n        directiveConfig.args = rewireArgs(directiveConfig.args);\n        return new GraphQLDirective(directiveConfig);\n    }\n    function rewireArgs(args) {\n        const rewiredArgs = {};\n        Object.keys(args).forEach(argName => {\n            const arg = args[argName];\n            const rewiredArgType = rewireType(arg.type);\n            if (rewiredArgType != null) {\n                arg.type = rewiredArgType;\n                rewiredArgs[argName] = arg;\n            }\n        });\n        return rewiredArgs;\n    }\n    function rewireNamedType(type) {\n        if (isObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n                interfaces: () => rewireNamedTypes(config.interfaces),\n            };\n            return new GraphQLObjectType(newConfig);\n        }\n        else if (isInterfaceType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireFields(config.fields),\n            };\n            if ('interfaces' in newConfig) {\n                newConfig.interfaces = () => rewireNamedTypes(config.interfaces);\n            }\n            return new GraphQLInterfaceType(newConfig);\n        }\n        else if (isUnionType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                types: () => rewireNamedTypes(config.types),\n            };\n            return new GraphQLUnionType(newConfig);\n        }\n        else if (isInputObjectType(type)) {\n            const config = type.toConfig();\n            const newConfig = {\n                ...config,\n                fields: () => rewireInputFields(config.fields),\n            };\n            return new GraphQLInputObjectType(newConfig);\n        }\n        else if (isEnumType(type)) {\n            const enumConfig = type.toConfig();\n            return new GraphQLEnumType(enumConfig);\n        }\n        else if (isScalarType(type)) {\n            if (isSpecifiedScalarType(type)) {\n                return type;\n            }\n            const scalarConfig = type.toConfig();\n            return new GraphQLScalarType(scalarConfig);\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function rewireFields(fields) {\n        const rewiredFields = {};\n        Object.keys(fields).forEach(fieldName => {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                field.args = rewireArgs(field.args);\n                rewiredFields[fieldName] = field;\n            }\n        });\n        return rewiredFields;\n    }\n    function rewireInputFields(fields) {\n        const rewiredFields = {};\n        Object.keys(fields).forEach(fieldName => {\n            const field = fields[fieldName];\n            const rewiredFieldType = rewireType(field.type);\n            if (rewiredFieldType != null) {\n                field.type = rewiredFieldType;\n                rewiredFields[fieldName] = field;\n            }\n        });\n        return rewiredFields;\n    }\n    function rewireNamedTypes(namedTypes) {\n        const rewiredTypes = [];\n        namedTypes.forEach(namedType => {\n            const rewiredType = rewireType(namedType);\n            if (rewiredType != null) {\n                rewiredTypes.push(rewiredType);\n            }\n        });\n        return rewiredTypes;\n    }\n    function rewireType(type) {\n        if (isListType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLList(rewiredType) : null;\n        }\n        else if (isNonNullType(type)) {\n            const rewiredType = rewireType(type.ofType);\n            return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;\n        }\n        else if (isNamedType(type)) {\n            let rewiredType = referenceTypeMap[type.name];\n            if (rewiredType === undefined) {\n                rewiredType = isNamedStub(type) ? getBuiltInForStub(type) : rewireNamedType(type);\n                newTypeMap[rewiredType.name] = referenceTypeMap[type.name] = rewiredType;\n            }\n            return rewiredType != null ? newTypeMap[rewiredType.name] : null;\n        }\n        return null;\n    }\n}\n// TODO:\n// consider removing the default level of pruning in v7\n//\n// Pruning during mapSchema limits the ability to create an unpruned schema, which may be of use\n// to some library users. pruning is now recommended via the dedicated pruneSchema function\n// which does not force pruning on library users and gives granular control in terms of pruning\n// types.\nfunction pruneTypes(typeMap, directives) {\n    const newTypeMap = {};\n    const implementedInterfaces = {};\n    Object.keys(typeMap).forEach(typeName => {\n        const namedType = typeMap[typeName];\n        if ('getInterfaces' in namedType) {\n            namedType.getInterfaces().forEach(iface => {\n                implementedInterfaces[iface.name] = true;\n            });\n        }\n    });\n    let prunedTypeMap = false;\n    const typeNames = Object.keys(typeMap);\n    for (let i = 0; i < typeNames.length; i++) {\n        const typeName = typeNames[i];\n        const type = typeMap[typeName];\n        if (isObjectType(type) || isInputObjectType(type)) {\n            // prune types with no fields\n            if (Object.keys(type.getFields()).length) {\n                newTypeMap[typeName] = type;\n            }\n            else {\n                prunedTypeMap = true;\n            }\n        }\n        else if (isUnionType(type)) {\n            // prune unions without underlying types\n            if (type.getTypes().length) {\n                newTypeMap[typeName] = type;\n            }\n            else {\n                prunedTypeMap = true;\n            }\n        }\n        else if (isInterfaceType(type)) {\n            // prune interfaces without fields or without implementations\n            if (Object.keys(type.getFields()).length && implementedInterfaces[type.name]) {\n                newTypeMap[typeName] = type;\n            }\n            else {\n                prunedTypeMap = true;\n            }\n        }\n        else {\n            newTypeMap[typeName] = type;\n        }\n    }\n    // every prune requires another round of healing\n    return prunedTypeMap ? rewireTypes(newTypeMap, directives) : { typeMap, directives };\n}\n//# sourceMappingURL=rewire.js.map","import { getNullableType, isLeafType, isListType, isInputObjectType, } from 'graphql';\nexport function transformInputValue(type, value, transformer) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = getNullableType(type);\n    if (isLeafType(nullableType)) {\n        return transformer(nullableType, value);\n    }\n    else if (isListType(nullableType)) {\n        return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, transformer));\n    }\n    else if (isInputObjectType(nullableType)) {\n        const fields = nullableType.getFields();\n        const newValue = {};\n        Object.keys(value).forEach(key => {\n            newValue[key] = transformInputValue(fields[key].type, value[key], transformer);\n        });\n        return newValue;\n    }\n    // unreachable, no other possible return value\n}\nexport function serializeInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => t.serialize(v));\n}\nexport function parseInputValue(type, value) {\n    return transformInputValue(type, value, (t, v) => t.parseValue(v));\n}\nexport function parseInputValueLiteral(type, value) {\n    return transformInputValue(type, value, (t, v) => t.parseLiteral(v, {}));\n}\n//# sourceMappingURL=transformInputValue.js.map","import { GraphQLObjectType, GraphQLSchema, isInterfaceType, isEnumType, isObjectType, isScalarType, isUnionType, isInputObjectType, GraphQLInputObjectType, GraphQLInterfaceType, isLeafType, isListType, isNonNullType, isNamedType, GraphQLList, GraphQLNonNull, GraphQLEnumType, Kind, } from 'graphql';\nimport { MapperKind, } from './Interfaces';\nimport { rewireTypes } from './rewire';\nimport { serializeInputValue, parseInputValue } from './transformInputValue';\nexport function mapSchema(schema, schemaMapper = {}) {\n    const originalTypeMap = schema.getTypeMap();\n    let newTypeMap = mapDefaultValues(originalTypeMap, schema, serializeInputValue);\n    newTypeMap = mapTypes(newTypeMap, schema, schemaMapper, type => isLeafType(type));\n    newTypeMap = mapEnumValues(newTypeMap, schema, schemaMapper);\n    newTypeMap = mapDefaultValues(newTypeMap, schema, parseInputValue);\n    newTypeMap = mapTypes(newTypeMap, schema, schemaMapper, type => !isLeafType(type));\n    newTypeMap = mapFields(newTypeMap, schema, schemaMapper);\n    newTypeMap = mapArguments(newTypeMap, schema, schemaMapper);\n    const originalDirectives = schema.getDirectives();\n    const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);\n    const queryType = schema.getQueryType();\n    const mutationType = schema.getMutationType();\n    const subscriptionType = schema.getSubscriptionType();\n    const newQueryTypeName = queryType != null ? (newTypeMap[queryType.name] != null ? newTypeMap[queryType.name].name : undefined) : undefined;\n    const newMutationTypeName = mutationType != null\n        ? newTypeMap[mutationType.name] != null\n            ? newTypeMap[mutationType.name].name\n            : undefined\n        : undefined;\n    const newSubscriptionTypeName = subscriptionType != null\n        ? newTypeMap[subscriptionType.name] != null\n            ? newTypeMap[subscriptionType.name].name\n            : undefined\n        : undefined;\n    const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);\n    return new GraphQLSchema({\n        ...schema.toConfig(),\n        query: newQueryTypeName ? typeMap[newQueryTypeName] : undefined,\n        mutation: newMutationTypeName ? typeMap[newMutationTypeName] : undefined,\n        subscription: newSubscriptionTypeName != null ? typeMap[newSubscriptionTypeName] : undefined,\n        types: Object.keys(typeMap).map(typeName => typeMap[typeName]),\n        directives,\n    });\n}\nfunction mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {\n    const newTypeMap = {};\n    Object.keys(originalTypeMap).forEach(typeName => {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (originalType == null || !testFn(originalType)) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            const typeMapper = getTypeMapper(schema, schemaMapper, typeName);\n            if (typeMapper == null) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            const maybeNewType = typeMapper(originalType, schema);\n            if (maybeNewType === undefined) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            newTypeMap[typeName] = maybeNewType;\n        }\n    });\n    return newTypeMap;\n}\nfunction mapEnumValues(originalTypeMap, schema, schemaMapper) {\n    const enumValueMapper = getEnumValueMapper(schemaMapper);\n    if (!enumValueMapper) {\n        return originalTypeMap;\n    }\n    return mapTypes(originalTypeMap, schema, {\n        [MapperKind.ENUM_TYPE]: type => {\n            const config = type.toConfig();\n            const originalEnumValueConfigMap = config.values;\n            const newEnumValueConfigMap = {};\n            Object.keys(originalEnumValueConfigMap).forEach(externalValue => {\n                const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];\n                const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type.name, schema, externalValue);\n                if (mappedEnumValue === undefined) {\n                    newEnumValueConfigMap[externalValue] = originalEnumValueConfig;\n                }\n                else if (Array.isArray(mappedEnumValue)) {\n                    const [newExternalValue, newEnumValueConfig] = mappedEnumValue;\n                    newEnumValueConfigMap[newExternalValue] =\n                        newEnumValueConfig === undefined ? originalEnumValueConfig : newEnumValueConfig;\n                }\n                else if (mappedEnumValue !== null) {\n                    newEnumValueConfigMap[externalValue] = mappedEnumValue;\n                }\n            });\n            return correctASTNodes(new GraphQLEnumType({\n                ...config,\n                values: newEnumValueConfigMap,\n            }));\n        },\n    }, type => isEnumType(type));\n}\nfunction mapDefaultValues(originalTypeMap, schema, fn) {\n    const newTypeMap = mapArguments(originalTypeMap, schema, {\n        [MapperKind.ARGUMENT]: argumentConfig => {\n            if (argumentConfig.defaultValue === undefined) {\n                return argumentConfig;\n            }\n            const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...argumentConfig,\n                    defaultValue: fn(maybeNewType, argumentConfig.defaultValue),\n                };\n            }\n        },\n    });\n    return mapFields(newTypeMap, schema, {\n        [MapperKind.INPUT_OBJECT_FIELD]: inputFieldConfig => {\n            if (inputFieldConfig.defaultValue === undefined) {\n                return inputFieldConfig;\n            }\n            const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);\n            if (maybeNewType != null) {\n                return {\n                    ...inputFieldConfig,\n                    defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue),\n                };\n            }\n        },\n    });\n}\nfunction getNewType(newTypeMap, type) {\n    if (isListType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLList(newType) : null;\n    }\n    else if (isNonNullType(type)) {\n        const newType = getNewType(newTypeMap, type.ofType);\n        return newType != null ? new GraphQLNonNull(newType) : null;\n    }\n    else if (isNamedType(type)) {\n        const newType = newTypeMap[type.name];\n        return newType != null ? newType : null;\n    }\n    return null;\n}\nfunction mapFields(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    Object.keys(originalTypeMap).forEach(typeName => {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);\n            if (fieldMapper == null) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            Object.keys(originalFieldConfigMap).forEach(fieldName => {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);\n                if (mappedField === undefined) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                }\n                else if (Array.isArray(mappedField)) {\n                    const [newFieldName, newFieldConfig] = mappedField;\n                    if (newFieldConfig.astNode != null) {\n                        newFieldConfig.astNode = {\n                            ...newFieldConfig.astNode,\n                            name: {\n                                ...newFieldConfig.astNode.name,\n                                value: newFieldName,\n                            },\n                        };\n                    }\n                    newFieldConfigMap[newFieldName] = newFieldConfig === undefined ? originalFieldConfig : newFieldConfig;\n                }\n                else if (mappedField !== null) {\n                    newFieldConfigMap[fieldName] = mappedField;\n                }\n            });\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n            else {\n                newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        }\n    });\n    return newTypeMap;\n}\nfunction mapArguments(originalTypeMap, schema, schemaMapper) {\n    const newTypeMap = {};\n    Object.keys(originalTypeMap).forEach(typeName => {\n        if (!typeName.startsWith('__')) {\n            const originalType = originalTypeMap[typeName];\n            if (!isObjectType(originalType) && !isInterfaceType(originalType)) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            const argumentMapper = getArgumentMapper(schemaMapper);\n            if (argumentMapper == null) {\n                newTypeMap[typeName] = originalType;\n                return;\n            }\n            const config = originalType.toConfig();\n            const originalFieldConfigMap = config.fields;\n            const newFieldConfigMap = {};\n            Object.keys(originalFieldConfigMap).forEach(fieldName => {\n                const originalFieldConfig = originalFieldConfigMap[fieldName];\n                const originalArgumentConfigMap = originalFieldConfig.args;\n                if (originalArgumentConfigMap == null) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    return;\n                }\n                const argumentNames = Object.keys(originalArgumentConfigMap);\n                if (!argumentNames.length) {\n                    newFieldConfigMap[fieldName] = originalFieldConfig;\n                    return;\n                }\n                const newArgumentConfigMap = {};\n                argumentNames.forEach(argumentName => {\n                    const originalArgumentConfig = originalArgumentConfigMap[argumentName];\n                    const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);\n                    if (mappedArgument === undefined) {\n                        newArgumentConfigMap[argumentName] = originalArgumentConfig;\n                    }\n                    else if (Array.isArray(mappedArgument)) {\n                        const [newArgumentName, newArgumentConfig] = mappedArgument;\n                        newArgumentConfigMap[newArgumentName] = newArgumentConfig;\n                    }\n                    else if (mappedArgument !== null) {\n                        newArgumentConfigMap[argumentName] = mappedArgument;\n                    }\n                });\n                newFieldConfigMap[fieldName] = {\n                    ...originalFieldConfig,\n                    args: newArgumentConfigMap,\n                };\n            });\n            if (isObjectType(originalType)) {\n                newTypeMap[typeName] = new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else if (isInterfaceType(originalType)) {\n                newTypeMap[typeName] = new GraphQLInterfaceType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n            else {\n                newTypeMap[typeName] = new GraphQLInputObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                });\n            }\n        }\n    });\n    return newTypeMap;\n}\nfunction mapDirectives(originalDirectives, schema, schemaMapper) {\n    const directiveMapper = getDirectiveMapper(schemaMapper);\n    if (directiveMapper == null) {\n        return originalDirectives.slice();\n    }\n    const newDirectives = [];\n    originalDirectives.forEach(directive => {\n        const mappedDirective = directiveMapper(directive, schema);\n        if (mappedDirective === undefined) {\n            newDirectives.push(directive);\n        }\n        else if (mappedDirective !== null) {\n            newDirectives.push(mappedDirective);\n        }\n    });\n    return newDirectives;\n}\nfunction getTypeSpecifiers(schema, typeName) {\n    const type = schema.getType(typeName);\n    const specifiers = [MapperKind.TYPE];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n        const query = schema.getQueryType();\n        const mutation = schema.getMutationType();\n        const subscription = schema.getSubscriptionType();\n        if (query != null && typeName === query.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n        }\n        else if (mutation != null && typeName === mutation.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n        }\n        else if (subscription != null && typeName === subscription.name) {\n            specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n        }\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n    }\n    else if (isUnionType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n    }\n    else if (isEnumType(type)) {\n        specifiers.push(MapperKind.ENUM_TYPE);\n    }\n    else if (isScalarType(type)) {\n        specifiers.push(MapperKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getTypeMapper(schema, schemaMapper, typeName) {\n    const specifiers = getTypeSpecifiers(schema, typeName);\n    let typeMapper;\n    const stack = [...specifiers];\n    while (!typeMapper && stack.length > 0) {\n        const next = stack.pop();\n        typeMapper = schemaMapper[next];\n    }\n    return typeMapper != null ? typeMapper : null;\n}\nfunction getFieldSpecifiers(schema, typeName) {\n    const type = schema.getType(typeName);\n    const specifiers = [MapperKind.FIELD];\n    if (isObjectType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);\n        const query = schema.getQueryType();\n        const mutation = schema.getMutationType();\n        const subscription = schema.getSubscriptionType();\n        if (query != null && typeName === query.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);\n        }\n        else if (mutation != null && typeName === mutation.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);\n        }\n        else if (subscription != null && typeName === subscription.name) {\n            specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);\n        }\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);\n    }\n    else if (isInputObjectType(type)) {\n        specifiers.push(MapperKind.INPUT_OBJECT_FIELD);\n    }\n    return specifiers;\n}\nfunction getFieldMapper(schema, schemaMapper, typeName) {\n    const specifiers = getFieldSpecifiers(schema, typeName);\n    let fieldMapper;\n    const stack = [...specifiers];\n    while (!fieldMapper && stack.length > 0) {\n        const next = stack.pop();\n        fieldMapper = schemaMapper[next];\n    }\n    return fieldMapper != null ? fieldMapper : null;\n}\nfunction getArgumentMapper(schemaMapper) {\n    const argumentMapper = schemaMapper[MapperKind.ARGUMENT];\n    return argumentMapper != null ? argumentMapper : null;\n}\nfunction getDirectiveMapper(schemaMapper) {\n    const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n}\nfunction getEnumValueMapper(schemaMapper) {\n    const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];\n    return enumValueMapper != null ? enumValueMapper : null;\n}\nexport function correctASTNodes(type) {\n    if (isObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            Object.values(config.fields).forEach(fieldConfig => {\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            });\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLObjectType(config);\n    }\n    else if (isInterfaceType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            Object.values(config.fields).forEach(fieldConfig => {\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            });\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.INTERFACE_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.INTERFACE_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLInterfaceType(config);\n    }\n    else if (isInputObjectType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const fields = [];\n            Object.values(config.fields).forEach(fieldConfig => {\n                if (fieldConfig.astNode != null) {\n                    fields.push(fieldConfig.astNode);\n                }\n            });\n            config.astNode = {\n                ...config.astNode,\n                kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n                fields,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n                fields: undefined,\n            }));\n        }\n        return new GraphQLInputObjectType(config);\n    }\n    else if (isEnumType(type)) {\n        const config = type.toConfig();\n        if (config.astNode != null) {\n            const values = [];\n            Object.values(config.values).forEach(enumValueConfig => {\n                if (enumValueConfig.astNode != null) {\n                    values.push(enumValueConfig.astNode);\n                }\n            });\n            config.astNode = {\n                ...config.astNode,\n                values,\n            };\n        }\n        if (config.extensionASTNodes != null) {\n            config.extensionASTNodes = config.extensionASTNodes.map(node => ({\n                ...node,\n                values: undefined,\n            }));\n        }\n        return new GraphQLEnumType(config);\n    }\n    else {\n        return type;\n    }\n}\n//# sourceMappingURL=mapSchema.js.map","import { GraphQLObjectType, } from 'graphql';\nimport { MapperKind } from './Interfaces';\nimport { mapSchema } from './mapSchema';\nexport function filterSchema({ schema, rootFieldFilter = () => true, typeFilter = () => true, fieldFilter = () => true, }) {\n    const filteredSchema = mapSchema(schema, {\n        [MapperKind.QUERY]: (type) => filterRootFields(type, 'Query', rootFieldFilter),\n        [MapperKind.MUTATION]: (type) => filterRootFields(type, 'Mutation', rootFieldFilter),\n        [MapperKind.SUBSCRIPTION]: (type) => filterRootFields(type, 'Subscription', rootFieldFilter),\n        [MapperKind.OBJECT_TYPE]: (type) => typeFilter(type.name, type) ? filterObjectFields(type, fieldFilter) : null,\n        [MapperKind.INTERFACE_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n        [MapperKind.UNION_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n        [MapperKind.INPUT_OBJECT_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n        [MapperKind.ENUM_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n        [MapperKind.SCALAR_TYPE]: (type) => (typeFilter(type.name, type) ? undefined : null),\n    });\n    return filteredSchema;\n}\nfunction filterRootFields(type, operation, rootFieldFilter) {\n    const config = type.toConfig();\n    Object.keys(config.fields).forEach(fieldName => {\n        if (!rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n            delete config.fields[fieldName];\n        }\n    });\n    return new GraphQLObjectType(config);\n}\nfunction filterObjectFields(type, fieldFilter) {\n    const config = type.toConfig();\n    Object.keys(config.fields).forEach(fieldName => {\n        if (!fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n            delete config.fields[fieldName];\n        }\n    });\n    return new GraphQLObjectType(config);\n}\n//# sourceMappingURL=filterSchema.js.map","import { GraphQLDirective, GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, isObjectType, isInterfaceType, isUnionType, isInputObjectType, isEnumType, isScalarType, isSpecifiedScalarType, isSpecifiedDirective, } from 'graphql';\nimport { mapSchema } from './mapSchema';\nexport function cloneDirective(directive) {\n    return isSpecifiedDirective(directive) ? directive : new GraphQLDirective(directive.toConfig());\n}\nexport function cloneType(type) {\n    if (isObjectType(type)) {\n        const config = type.toConfig();\n        return new GraphQLObjectType({\n            ...config,\n            interfaces: typeof config.interfaces === 'function' ? config.interfaces : config.interfaces.slice(),\n        });\n    }\n    else if (isInterfaceType(type)) {\n        const config = type.toConfig();\n        const newConfig = {\n            ...config,\n            interfaces: [...((typeof config.interfaces === 'function' ? config.interfaces() : config.interfaces) || [])],\n        };\n        return new GraphQLInterfaceType(newConfig);\n    }\n    else if (isUnionType(type)) {\n        const config = type.toConfig();\n        return new GraphQLUnionType({\n            ...config,\n            types: config.types.slice(),\n        });\n    }\n    else if (isInputObjectType(type)) {\n        return new GraphQLInputObjectType(type.toConfig());\n    }\n    else if (isEnumType(type)) {\n        return new GraphQLEnumType(type.toConfig());\n    }\n    else if (isScalarType(type)) {\n        return isSpecifiedScalarType(type) ? type : new GraphQLScalarType(type.toConfig());\n    }\n    throw new Error(`Invalid type ${type}`);\n}\nexport function cloneSchema(schema) {\n    return mapSchema(schema);\n}\n//# sourceMappingURL=clone.js.map","import { GraphQLList, GraphQLNonNull, isNamedType, isObjectType, isInterfaceType, isUnionType, isInputObjectType, isLeafType, isListType, isNonNullType, } from 'graphql';\n// Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n//\n// healSchema and its callers (visitSchema/visitSchemaDirectives) all modify the schema in place.\n// Therefore, private variables (such as the stored implementation map and the proper root types)\n// are not updated.\n//\n// If this causes issues, the schema could be more aggressively healed as follows:\n//\n// healSchema(schema);\n// const config = schema.toConfig()\n// const healedSchema = new GraphQLSchema({\n//   ...config,\n//   query: schema.getType('<desired new root query type name>'),\n//   mutation: schema.getType('<desired new root mutation type name>'),\n//   subscription: schema.getType('<desired new root subscription type name>'),\n// });\n//\n// One can then also -- if necessary --  assign the correct private variables to the initial schema\n// as follows:\n// Object.assign(schema, healedSchema);\n//\n// These steps are not taken automatically to preserve backwards compatibility with graphql-tools v4.\n// See https://github.com/ardatan/graphql-tools/issues/1462\n//\n// They were briefly taken in v5, but can now be phased out as they were only required when other\n// areas of the codebase were using healSchema and visitSchema more extensively.\n//\nexport function healSchema(schema) {\n    healTypes(schema.getTypeMap(), schema.getDirectives());\n    return schema;\n}\nexport function healTypes(originalTypeMap, directives, config = {\n    skipPruning: false,\n}) {\n    const actualNamedTypeMap = Object.create(null);\n    // If any of the .name properties of the GraphQLNamedType objects in\n    // schema.getTypeMap() have changed, the keys of the type map need to\n    // be updated accordingly.\n    Object.entries(originalTypeMap).forEach(([typeName, namedType]) => {\n        if (namedType == null || typeName.startsWith('__')) {\n            return;\n        }\n        const actualName = namedType.name;\n        if (actualName.startsWith('__')) {\n            return;\n        }\n        if (actualName in actualNamedTypeMap) {\n            throw new Error(`Duplicate schema type name ${actualName}`);\n        }\n        actualNamedTypeMap[actualName] = namedType;\n        // Note: we are deliberately leaving namedType in the schema by its\n        // original name (which might be different from actualName), so that\n        // references by that name can be healed.\n    });\n    // Now add back every named type by its actual name.\n    Object.entries(actualNamedTypeMap).forEach(([typeName, namedType]) => {\n        originalTypeMap[typeName] = namedType;\n    });\n    // Directive declaration argument types can refer to named types.\n    directives.forEach((decl) => {\n        decl.args = decl.args.filter(arg => {\n            arg.type = healType(arg.type);\n            return arg.type !== null;\n        });\n    });\n    Object.entries(originalTypeMap).forEach(([typeName, namedType]) => {\n        // Heal all named types, except for dangling references, kept only to redirect.\n        if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n            if (namedType != null) {\n                healNamedType(namedType);\n            }\n        }\n    });\n    for (const typeName of Object.keys(originalTypeMap)) {\n        if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n            delete originalTypeMap[typeName];\n        }\n    }\n    if (!config.skipPruning) {\n        // TODO:\n        // consider removing the default level of pruning in v7,\n        // see comments below on the pruneTypes function.\n        pruneTypes(originalTypeMap, directives);\n    }\n    function healNamedType(type) {\n        if (isObjectType(type)) {\n            healFields(type);\n            healInterfaces(type);\n            return;\n        }\n        else if (isInterfaceType(type)) {\n            healFields(type);\n            if ('getInterfaces' in type) {\n                healInterfaces(type);\n            }\n            return;\n        }\n        else if (isUnionType(type)) {\n            healUnderlyingTypes(type);\n            return;\n        }\n        else if (isInputObjectType(type)) {\n            healInputFields(type);\n            return;\n        }\n        else if (isLeafType(type)) {\n            return;\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function healFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.args\n                .map(arg => {\n                arg.type = healType(arg.type);\n                return arg.type === null ? null : arg;\n            })\n                .filter(Boolean);\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healInterfaces(type) {\n        if ('getInterfaces' in type) {\n            const interfaces = type.getInterfaces();\n            interfaces.push(...interfaces\n                .splice(0)\n                .map(iface => healType(iface))\n                .filter(Boolean));\n        }\n    }\n    function healInputFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            field.type = healType(field.type);\n            if (field.type === null) {\n                delete fieldMap[key];\n            }\n        }\n    }\n    function healUnderlyingTypes(type) {\n        const types = type.getTypes();\n        types.push(...types\n            .splice(0)\n            .map(t => healType(t))\n            .filter(Boolean));\n    }\n    function healType(type) {\n        // Unwrap the two known wrapper types\n        if (isListType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new GraphQLList(healedType) : null;\n        }\n        else if (isNonNullType(type)) {\n            const healedType = healType(type.ofType);\n            return healedType != null ? new GraphQLNonNull(healedType) : null;\n        }\n        else if (isNamedType(type)) {\n            // If a type annotation on a field or an argument or a union member is\n            // any `GraphQLNamedType` with a `name`, then it must end up identical\n            // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n            // of truth for all named schema types.\n            // Note that new types can still be simply added by adding a field, as\n            // the official type will be undefined, not null.\n            const officialType = originalTypeMap[type.name];\n            if (officialType && type !== officialType) {\n                return officialType;\n            }\n        }\n        return type;\n    }\n}\n// TODO:\n// consider removing the default level of pruning in v7\n//\n// Pruning was introduced into healSchema in v5, so legacy schema directives relying on pruning\n// during healing are likely to be rare. pruning is now recommended via the dedicated pruneSchema\n// function which does not force pruning on library users and gives granular control in terms of\n// pruning types. pruneSchema does recreate the schema -- a parallel version that prunes in place\n// could be considered.\nfunction pruneTypes(typeMap, directives) {\n    const implementedInterfaces = {};\n    Object.values(typeMap).forEach(namedType => {\n        if ('getInterfaces' in namedType) {\n            namedType.getInterfaces().forEach(iface => {\n                implementedInterfaces[iface.name] = true;\n            });\n        }\n    });\n    let prunedTypeMap = false;\n    const typeNames = Object.keys(typeMap);\n    for (let i = 0; i < typeNames.length; i++) {\n        const typeName = typeNames[i];\n        const type = typeMap[typeName];\n        if (isObjectType(type) || isInputObjectType(type)) {\n            // prune types with no fields\n            if (!Object.keys(type.getFields()).length) {\n                typeMap[typeName] = null;\n                prunedTypeMap = true;\n            }\n        }\n        else if (isUnionType(type)) {\n            // prune unions without underlying types\n            if (!type.getTypes().length) {\n                typeMap[typeName] = null;\n                prunedTypeMap = true;\n            }\n        }\n        else if (isInterfaceType(type)) {\n            // prune interfaces without fields or without implementations\n            if (!Object.keys(type.getFields()).length || !(type.name in implementedInterfaces)) {\n                typeMap[typeName] = null;\n                prunedTypeMap = true;\n            }\n        }\n    }\n    // every prune requires another round of healing\n    if (prunedTypeMap) {\n        healTypes(typeMap, directives);\n    }\n}\n//# sourceMappingURL=heal.js.map","// Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\nexport class SchemaVisitor {\n    // Determine if this SchemaVisitor (sub)class implements a particular\n    // visitor method.\n    static implementsVisitorMethod(methodName) {\n        if (!methodName.startsWith('visit')) {\n            return false;\n        }\n        const method = this.prototype[methodName];\n        if (typeof method !== 'function') {\n            return false;\n        }\n        if (this.name === 'SchemaVisitor') {\n            // The SchemaVisitor class implements every visitor method.\n            return true;\n        }\n        const stub = SchemaVisitor.prototype[methodName];\n        if (method === stub) {\n            // If this.prototype[methodName] was just inherited from SchemaVisitor,\n            // then this class does not really implement the method.\n            return false;\n        }\n        return true;\n    }\n    // Concrete subclasses of SchemaVisitor should override one or more of these\n    // visitor methods, in order to express their interest in handling certain\n    // schema types/locations. Each method may return null to remove the given\n    // type from the schema, a non-null value of the same type to update the\n    // type in the schema, or nothing to leave the type as it was.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    visitSchema(_schema) { }\n    visitScalar(_scalar\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) { }\n    visitObject(_object\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) { }\n    visitFieldDefinition(_field, _details\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) { }\n    visitArgumentDefinition(_argument, _details\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) { }\n    visitInterface(_iface\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) { }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    visitUnion(_union) { }\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    visitEnum(_type) { }\n    visitEnumValue(_value, _details\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) { }\n    visitInputObject(_object\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) { }\n    visitInputFieldDefinition(_field, _details\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    ) { }\n}\n//# sourceMappingURL=SchemaVisitor.js.map","import { isNamedType, isSchema, isObjectType, isInterfaceType, isInputObjectType, isScalarType, isUnionType, isEnumType, isInputType, GraphQLEnumType, } from 'graphql';\nimport { VisitSchemaKind, } from './Interfaces';\nimport { healSchema } from './heal';\nfunction isSchemaVisitor(obj) {\n    if ('schema' in obj && isSchema(obj.schema)) {\n        if ('visitSchema' in obj && typeof obj.visitSchema === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\n// Generic function for visiting GraphQLSchema objects.\nexport function visitSchema(schema, \n// To accommodate as many different visitor patterns as possible, the\n// visitSchema function does not simply accept a single instance of the\n// SchemaVisitor class, but instead accepts a function that takes the\n// current VisitableSchemaType object and the name of a visitor method and\n// returns an array of SchemaVisitor instances that implement the visitor\n// method and have an interest in handling the given VisitableSchemaType\n// object. In the simplest case, this function can always return an array\n// containing a single visitor object, without even looking at the type or\n// methodName parameters. In other cases, this function might sometimes\n// return an empty array to indicate there are no visitors that should be\n// applied to the given VisitableSchemaType object. For an example of a\n// visitor pattern that benefits from this abstraction, see the\n// SchemaDirectiveVisitor class below.\nvisitorOrVisitorSelector) {\n    const visitorSelector = typeof visitorOrVisitorSelector === 'function' ? visitorOrVisitorSelector : () => visitorOrVisitorSelector;\n    // Helper function that calls visitorSelector and applies the resulting\n    // visitors to the given type, with arguments [type, ...args].\n    function callMethod(methodName, type, ...args) {\n        let visitors = visitorSelector(type, methodName);\n        visitors = Array.isArray(visitors) ? visitors : [visitors];\n        let finalType = type;\n        visitors.every(visitorOrVisitorDef => {\n            let newType;\n            if (isSchemaVisitor(visitorOrVisitorDef)) {\n                newType = visitorOrVisitorDef[methodName](finalType, ...args);\n            }\n            else if (isNamedType(finalType) &&\n                (methodName === 'visitScalar' ||\n                    methodName === 'visitEnum' ||\n                    methodName === 'visitObject' ||\n                    methodName === 'visitInputObject' ||\n                    methodName === 'visitUnion' ||\n                    methodName === 'visitInterface')) {\n                const specifiers = getTypeSpecifiers(finalType, schema);\n                const typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);\n                newType = typeVisitor != null ? typeVisitor(finalType, schema) : undefined;\n            }\n            if (typeof newType === 'undefined') {\n                // Keep going without modifying type.\n                return true;\n            }\n            if (methodName === 'visitSchema' || isSchema(finalType)) {\n                throw new Error(`Method ${methodName} cannot replace schema with ${newType}`);\n            }\n            if (newType === null) {\n                // Stop the loop and return null form callMethod, which will cause\n                // the type to be removed from the schema.\n                finalType = null;\n                return false;\n            }\n            // Update type to the new type returned by the visitor method, so that\n            // later directives will see the new type, and callMethod will return\n            // the final type.\n            finalType = newType;\n            return true;\n        });\n        // If there were no directives for this type object, or if all visitor\n        // methods returned nothing, type will be returned unmodified.\n        return finalType;\n    }\n    // Recursive helper function that calls any appropriate visitor methods for\n    // each object in the schema, then traverses the object's children (if any).\n    function visit(type) {\n        if (isSchema(type)) {\n            // Unlike the other types, the root GraphQLSchema object cannot be\n            // replaced by visitor methods, because that would make life very hard\n            // for SchemaVisitor subclasses that rely on the original schema object.\n            callMethod('visitSchema', type);\n            const typeMap = type.getTypeMap();\n            Object.entries(typeMap).forEach(([typeName, namedType]) => {\n                if (!typeName.startsWith('__') && namedType != null) {\n                    // Call visit recursively to let it determine which concrete\n                    // subclass of GraphQLNamedType we found in the type map.\n                    // We do not use updateEachKey because we want to preserve\n                    // deleted types in the typeMap so that other types that reference\n                    // the deleted types can be healed.\n                    typeMap[typeName] = visit(namedType);\n                }\n            });\n            return type;\n        }\n        if (isObjectType(type)) {\n            // Note that callMethod('visitObject', type) may not actually call any\n            // methods, if there are no @directive annotations associated with this\n            // type, or if this SchemaDirectiveVisitor subclass does not override\n            // the visitObject method.\n            const newObject = callMethod('visitObject', type);\n            if (newObject != null) {\n                visitFields(newObject);\n            }\n            return newObject;\n        }\n        if (isInterfaceType(type)) {\n            const newInterface = callMethod('visitInterface', type);\n            if (newInterface != null) {\n                visitFields(newInterface);\n            }\n            return newInterface;\n        }\n        if (isInputObjectType(type)) {\n            const newInputObject = callMethod('visitInputObject', type);\n            if (newInputObject != null) {\n                const fieldMap = newInputObject.getFields();\n                for (const key of Object.keys(fieldMap)) {\n                    fieldMap[key] = callMethod('visitInputFieldDefinition', fieldMap[key], {\n                        // Since we call a different method for input object fields, we\n                        // can't reuse the visitFields function here.\n                        objectType: newInputObject,\n                    });\n                    if (!fieldMap[key]) {\n                        delete fieldMap[key];\n                    }\n                }\n            }\n            return newInputObject;\n        }\n        if (isScalarType(type)) {\n            return callMethod('visitScalar', type);\n        }\n        if (isUnionType(type)) {\n            return callMethod('visitUnion', type);\n        }\n        if (isEnumType(type)) {\n            let newEnum = callMethod('visitEnum', type);\n            if (newEnum != null) {\n                const newValues = newEnum\n                    .getValues()\n                    .map(value => callMethod('visitEnumValue', value, {\n                    enumType: newEnum,\n                }))\n                    .filter(Boolean);\n                // Recreate the enum type if any of the values changed\n                const valuesUpdated = newValues.some((value, index) => value !== newEnum.getValues()[index]);\n                if (valuesUpdated) {\n                    newEnum = new GraphQLEnumType({\n                        ...newEnum.toConfig(),\n                        values: newValues.reduce((prev, value) => ({\n                            ...prev,\n                            [value.name]: {\n                                value: value.value,\n                                deprecationReason: value.deprecationReason,\n                                description: value.description,\n                                astNode: value.astNode,\n                            },\n                        }), {}),\n                    });\n                }\n            }\n            return newEnum;\n        }\n        throw new Error(`Unexpected schema type: ${type}`);\n    }\n    function visitFields(type) {\n        const fieldMap = type.getFields();\n        for (const [key, field] of Object.entries(fieldMap)) {\n            // It would be nice if we could call visit(field) recursively here, but\n            // GraphQLField is merely a type, not a value that can be detected using\n            // an instanceof check, so we have to visit the fields in this lexical\n            // context, so that TypeScript can validate the call to\n            // visitFieldDefinition.\n            const newField = callMethod('visitFieldDefinition', field, {\n                // While any field visitor needs a reference to the field object, some\n                // field visitors may also need to know the enclosing (parent) type,\n                // perhaps to determine if the parent is a GraphQLObjectType or a\n                // GraphQLInterfaceType. To obtain a reference to the parent, a\n                // visitor method can have a second parameter, which will be an object\n                // with an .objectType property referring to the parent.\n                objectType: type,\n            });\n            if (newField.args != null) {\n                newField.args = newField.args\n                    .map(arg => callMethod('visitArgumentDefinition', arg, {\n                    // Like visitFieldDefinition, visitArgumentDefinition takes a\n                    // second parameter that provides additional context, namely the\n                    // parent .field and grandparent .objectType. Remember that the\n                    // current GraphQLSchema is always available via this.schema.\n                    field: newField,\n                    objectType: type,\n                }))\n                    .filter(Boolean);\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n            if (newField) {\n                fieldMap[key] = newField;\n            }\n            else {\n                delete fieldMap[key];\n            }\n        }\n    }\n    visit(schema);\n    // Automatically update any references to named schema types replaced\n    // during the traversal, so implementors don't have to worry about that.\n    healSchema(schema);\n    // Return schema for convenience, even though schema parameter has all updated types.\n    return schema;\n}\nfunction getTypeSpecifiers(type, schema) {\n    const specifiers = [VisitSchemaKind.TYPE];\n    if (isObjectType(type)) {\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);\n        const query = schema.getQueryType();\n        const mutation = schema.getMutationType();\n        const subscription = schema.getSubscriptionType();\n        if (type === query) {\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);\n        }\n        else if (type === mutation) {\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);\n        }\n        else if (type === subscription) {\n            specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);\n        }\n    }\n    else if (isInputType(type)) {\n        specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);\n    }\n    else if (isInterfaceType(type)) {\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);\n    }\n    else if (isUnionType(type)) {\n        specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);\n    }\n    else if (isEnumType(type)) {\n        specifiers.push(VisitSchemaKind.ENUM_TYPE);\n    }\n    else if (isScalarType(type)) {\n        specifiers.push(VisitSchemaKind.SCALAR_TYPE);\n    }\n    return specifiers;\n}\nfunction getVisitor(visitorDef, specifiers) {\n    let typeVisitor;\n    const stack = [...specifiers];\n    while (!typeVisitor && stack.length > 0) {\n        const next = stack.pop();\n        typeVisitor = visitorDef[next];\n    }\n    return typeVisitor != null ? typeVisitor : null;\n}\n//# sourceMappingURL=visitSchema.js.map","import { valueFromASTUntyped, } from 'graphql';\nimport { SchemaVisitor } from './SchemaVisitor';\nimport { visitSchema } from './visitSchema';\nimport { getArgumentValues } from './getArgumentValues';\n// This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\nexport class SchemaDirectiveVisitor extends SchemaVisitor {\n    // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n    // subclasses (not instances) to visitSchemaDirectives.\n    constructor(config) {\n        super();\n        this.name = config.name;\n        this.args = config.args;\n        this.visitedType = config.visitedType;\n        this.schema = config.schema;\n        this.context = config.context;\n    }\n    // Override this method to return a custom GraphQLDirective (or modify one\n    // already present in the schema) to enforce argument types, provide default\n    // argument values, or specify schema locations where this @directive may\n    // appear. By default, any declaration found in the schema will be returned.\n    static getDirectiveDeclaration(directiveName, schema) {\n        return schema.getDirective(directiveName);\n    }\n    // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n    // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n    // instance to visit the object decorated by the @directive.\n    static visitSchemaDirectives(schema, \n    // The keys of this object correspond to directive names as they appear\n    // in the schema, and the values should be subclasses (not instances!)\n    // of the SchemaDirectiveVisitor class. This distinction is important\n    // because a new SchemaDirectiveVisitor instance will be created each\n    // time a matching directive is found in the schema AST, with arguments\n    // and other metadata specific to that occurrence. To help prevent the\n    // mistake of passing instances, the SchemaDirectiveVisitor constructor\n    // method is marked as protected.\n    directiveVisitors, \n    // Optional context object that will be available to all visitor instances\n    // via this.context. Defaults to an empty null-prototype object.\n    context = Object.create(null)\n    // The visitSchemaDirectives method returns a map from directive names to\n    // lists of SchemaDirectiveVisitors created while visiting the schema.\n    ) {\n        // If the schema declares any directives for public consumption, record\n        // them here so that we can properly coerce arguments when/if we encounter\n        // an occurrence of the directive while walking the schema below.\n        const declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors);\n        // Map from directive names to lists of SchemaDirectiveVisitor instances\n        // created while visiting the schema.\n        const createdVisitors = Object.keys(directiveVisitors).reduce((prev, item) => ({\n            ...prev,\n            [item]: [],\n        }), {});\n        const directiveVisitorMap = Object.entries(directiveVisitors).reduce((prev, [key, value]) => ({\n            ...prev,\n            [key]: value,\n        }), {});\n        function visitorSelector(type, methodName) {\n            var _a, _b;\n            let directiveNodes = (_b = (_a = type === null || type === void 0 ? void 0 : type.astNode) === null || _a === void 0 ? void 0 : _a.directives) !== null && _b !== void 0 ? _b : [];\n            const extensionASTNodes = type.extensionASTNodes;\n            if (extensionASTNodes != null) {\n                extensionASTNodes.forEach(extensionASTNode => {\n                    if (extensionASTNode.directives != null) {\n                        directiveNodes = directiveNodes.concat(extensionASTNode.directives);\n                    }\n                });\n            }\n            const visitors = [];\n            directiveNodes.forEach(directiveNode => {\n                const directiveName = directiveNode.name.value;\n                if (!(directiveName in directiveVisitorMap)) {\n                    return;\n                }\n                const VisitorClass = directiveVisitorMap[directiveName];\n                // Avoid creating visitor objects if visitorClass does not override\n                // the visitor method named by methodName.\n                if (!VisitorClass.implementsVisitorMethod(methodName)) {\n                    return;\n                }\n                const decl = declaredDirectives[directiveName];\n                let args;\n                if (decl != null) {\n                    // If this directive was explicitly declared, use the declared\n                    // argument types (and any default values) to check, coerce, and/or\n                    // supply default values for the given arguments.\n                    args = getArgumentValues(decl, directiveNode);\n                }\n                else {\n                    // If this directive was not explicitly declared, just convert the\n                    // argument nodes to their corresponding JavaScript values.\n                    args = Object.create(null);\n                    if (directiveNode.arguments != null) {\n                        directiveNode.arguments.forEach(arg => {\n                            args[arg.name.value] = valueFromASTUntyped(arg.value);\n                        });\n                    }\n                }\n                // As foretold in comments near the top of the visitSchemaDirectives\n                // method, this is where instances of the SchemaDirectiveVisitor class\n                // get created and assigned names. While subclasses could override the\n                // constructor method, the constructor is marked as protected, so\n                // these are the only arguments that will ever be passed.\n                visitors.push(new VisitorClass({\n                    name: directiveName,\n                    args,\n                    visitedType: type,\n                    schema,\n                    context,\n                }));\n            });\n            if (visitors.length > 0) {\n                visitors.forEach(visitor => {\n                    createdVisitors[visitor.name].push(visitor);\n                });\n            }\n            return visitors;\n        }\n        visitSchema(schema, visitorSelector);\n        return createdVisitors;\n    }\n    static getDeclaredDirectives(schema, directiveVisitors) {\n        const declaredDirectives = schema.getDirectives().reduce((prev, curr) => ({\n            ...prev,\n            [curr.name]: curr,\n        }), {});\n        // If the visitor subclass overrides getDirectiveDeclaration, and it\n        // returns a non-null GraphQLDirective, use that instead of any directive\n        // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n        // goes to the trouble of implementing getDirectiveDeclaration, it should\n        // be able to rely on that implementation.\n        Object.entries(directiveVisitors).forEach(([directiveName, visitorClass]) => {\n            const decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\n            if (decl != null) {\n                declaredDirectives[directiveName] = decl;\n            }\n        });\n        Object.entries(declaredDirectives).forEach(([name, decl]) => {\n            if (!(name in directiveVisitors)) {\n                // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n                // multiple times with partial directiveVisitors maps, so it's not\n                // necessarily an error for directiveVisitors to be missing an\n                // implementation of a directive that was declared in the schema.\n                return;\n            }\n            const visitorClass = directiveVisitors[name];\n            decl.locations.forEach(loc => {\n                const visitorMethodName = directiveLocationToVisitorMethodName(loc);\n                if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) &&\n                    !visitorClass.implementsVisitorMethod(visitorMethodName)) {\n                    // While visitor subclasses may implement extra visitor methods,\n                    // it's definitely a mistake if the GraphQLDirective declares itself\n                    // applicable to certain schema locations, and the visitor subclass\n                    // does not implement all the corresponding methods.\n                    throw new Error(`SchemaDirectiveVisitor for @${name} must implement ${visitorMethodName} method`);\n                }\n            });\n        });\n        return declaredDirectives;\n    }\n}\n// Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\nfunction directiveLocationToVisitorMethodName(loc) {\n    return ('visit' +\n        loc.replace(/([^_]*)_?/g, (_wholeMatch, part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()));\n}\n//# sourceMappingURL=SchemaDirectiveVisitor.js.map","import { isScalarType, isEnumType, isInterfaceType, isUnionType, isObjectType, isSpecifiedScalarType, } from 'graphql';\nimport { cloneType } from './clone';\nexport function getResolversFromSchema(schema) {\n    const resolvers = Object.create({});\n    const typeMap = schema.getTypeMap();\n    Object.keys(typeMap).forEach(typeName => {\n        const type = typeMap[typeName];\n        if (isScalarType(type)) {\n            if (!isSpecifiedScalarType(type)) {\n                resolvers[typeName] = cloneType(type);\n            }\n        }\n        else if (isEnumType(type)) {\n            resolvers[typeName] = {};\n            const values = type.getValues();\n            values.forEach(value => {\n                resolvers[typeName][value.name] = value.value;\n            });\n        }\n        else if (isInterfaceType(type)) {\n            if (type.resolveType != null) {\n                resolvers[typeName] = {\n                    __resolveType: type.resolveType,\n                };\n            }\n        }\n        else if (isUnionType(type)) {\n            if (type.resolveType != null) {\n                resolvers[typeName] = {\n                    __resolveType: type.resolveType,\n                };\n            }\n        }\n        else if (isObjectType(type)) {\n            resolvers[typeName] = {};\n            if (type.isTypeOf != null) {\n                resolvers[typeName].__isTypeOf = type.isTypeOf;\n            }\n            const fields = type.getFields();\n            Object.keys(fields).forEach(fieldName => {\n                const field = fields[fieldName];\n                resolvers[typeName][fieldName] = {\n                    resolve: field.resolve,\n                    subscribe: field.subscribe,\n                };\n            });\n        }\n    });\n    return resolvers;\n}\n//# sourceMappingURL=getResolversFromSchema.js.map","import { getNamedType, isObjectType } from 'graphql';\nexport function forEachField(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    Object.keys(typeMap).forEach(typeName => {\n        const type = typeMap[typeName];\n        // TODO: maybe have an option to include these?\n        if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n            const fields = type.getFields();\n            Object.keys(fields).forEach(fieldName => {\n                const field = fields[fieldName];\n                fn(field, typeName, fieldName);\n            });\n        }\n    });\n}\n//# sourceMappingURL=forEachField.js.map","import { getNamedType, isObjectType, isInputObjectType } from 'graphql';\nexport function forEachDefaultValue(schema, fn) {\n    const typeMap = schema.getTypeMap();\n    Object.keys(typeMap).forEach(typeName => {\n        const type = typeMap[typeName];\n        if (!getNamedType(type).name.startsWith('__')) {\n            if (isObjectType(type)) {\n                const fields = type.getFields();\n                Object.keys(fields).forEach(fieldName => {\n                    const field = fields[fieldName];\n                    field.args.forEach(arg => {\n                        arg.defaultValue = fn(arg.type, arg.defaultValue);\n                    });\n                });\n            }\n            else if (isInputObjectType(type)) {\n                const fields = type.getFields();\n                Object.keys(fields).forEach(fieldName => {\n                    const field = fields[fieldName];\n                    field.defaultValue = fn(field.type, field.defaultValue);\n                });\n            }\n        }\n    });\n}\n//# sourceMappingURL=forEachDefaultValue.js.map","// addTypes uses toConfig to create a new schema with a new or replaced\n// type or directive. Rewiring is employed so that the replaced type can be\n// reconnected with the existing types.\n//\n// Rewiring is employed even for new types or directives as a convenience, so\n// that type references within the new type or directive do not have to be to\n// the identical objects within the original schema.\n//\n// In fact, the type references could even be stub types with entirely different\n// fields, as long as the type references share the same name as the desired\n// type within the original schema's type map.\n//\n// This makes it easy to perform simple schema operations (e.g. adding a new\n// type with a fiew fields removed from an existing type) that could normally be\n// performed by using toConfig directly, but is blocked if any intervening\n// more advanced schema operations have caused the types to be recreated via\n// rewiring.\n//\n// Type recreation happens, for example, with every use of mapSchema, as the\n// types are always rewired. If fields are selected and removed using\n// mapSchema, adding those fields to a new type can no longer be simply done\n// by toConfig, as the types are not the identical Javascript objects, and\n// schema creation will fail with errors referencing multiple types with the\n// same names.\n//\n// enhanceSchema can fill this gap by adding an additional round of rewiring.\n//\nimport { GraphQLSchema, isNamedType, isDirective, } from 'graphql';\nimport { rewireTypes } from './rewire';\nexport function addTypes(schema, newTypesOrDirectives) {\n    const queryType = schema.getQueryType();\n    const mutationType = schema.getMutationType();\n    const subscriptionType = schema.getSubscriptionType();\n    const queryTypeName = queryType != null ? queryType.name : undefined;\n    const mutationTypeName = mutationType != null ? mutationType.name : undefined;\n    const subscriptionTypeName = subscriptionType != null ? subscriptionType.name : undefined;\n    const config = schema.toConfig();\n    const originalTypeMap = {};\n    config.types.forEach(type => {\n        originalTypeMap[type.name] = type;\n    });\n    const originalDirectiveMap = {};\n    config.directives.forEach(directive => {\n        originalDirectiveMap[directive.name] = directive;\n    });\n    newTypesOrDirectives.forEach(newTypeOrDirective => {\n        if (isNamedType(newTypeOrDirective)) {\n            originalTypeMap[newTypeOrDirective.name] = newTypeOrDirective;\n        }\n        else if (isDirective(newTypeOrDirective)) {\n            originalDirectiveMap[newTypeOrDirective.name] = newTypeOrDirective;\n        }\n    });\n    const { typeMap, directives } = rewireTypes(originalTypeMap, Object.keys(originalDirectiveMap).map(directiveName => originalDirectiveMap[directiveName]));\n    return new GraphQLSchema({\n        ...config,\n        query: queryTypeName ? typeMap[queryTypeName] : undefined,\n        mutation: mutationTypeName ? typeMap[mutationTypeName] : undefined,\n        subscription: subscriptionTypeName != null ? typeMap[subscriptionTypeName] : undefined,\n        types: Object.keys(typeMap).map(typeName => typeMap[typeName]),\n        directives,\n    });\n}\n//# sourceMappingURL=addTypes.js.map","import { getNamedType, isObjectType, isInterfaceType, isUnionType, isInputObjectType, } from 'graphql';\nimport { mapSchema } from './mapSchema';\nimport { MapperKind } from './Interfaces';\n/**\n * Prunes the provided schema, removing unused and empty types\n * @param schema The schema to prune\n * @param options Additional options for removing unused types from the schema\n */\nexport function pruneSchema(schema, options = {}) {\n    const pruningContext = {\n        schema,\n        unusedTypes: Object.create(null),\n        implementations: Object.create(null),\n    };\n    Object.keys(schema.getTypeMap()).forEach(typeName => {\n        const type = schema.getType(typeName);\n        if ('getInterfaces' in type) {\n            type.getInterfaces().forEach(iface => {\n                if (pruningContext.implementations[iface.name] == null) {\n                    pruningContext.implementations[iface.name] = Object.create(null);\n                }\n                pruningContext.implementations[iface.name][type.name] = true;\n            });\n        }\n    });\n    visitTypes(pruningContext, schema);\n    return mapSchema(schema, {\n        [MapperKind.TYPE]: (type) => {\n            if (isObjectType(type) || isInputObjectType(type)) {\n                if ((!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning) ||\n                    (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning)) {\n                    return null;\n                }\n            }\n            else if (isUnionType(type)) {\n                if ((!type.getTypes().length && !options.skipEmptyUnionPruning) ||\n                    (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning)) {\n                    return null;\n                }\n            }\n            else if (isInterfaceType(type)) {\n                if ((!Object.keys(type.getFields()).length && !options.skipEmptyCompositeTypePruning) ||\n                    (!Object.keys(pruningContext.implementations[type.name]).length &&\n                        !options.skipUnimplementedInterfacesPruning) ||\n                    (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning)) {\n                    return null;\n                }\n            }\n            else {\n                if (pruningContext.unusedTypes[type.name] && !options.skipUnusedTypesPruning) {\n                    return null;\n                }\n            }\n        },\n    });\n}\nfunction visitOutputType(visitedTypes, pruningContext, type) {\n    if (visitedTypes[type.name]) {\n        return;\n    }\n    visitedTypes[type.name] = true;\n    pruningContext.unusedTypes[type.name] = false;\n    if (isObjectType(type) || isInterfaceType(type)) {\n        const fields = type.getFields();\n        Object.keys(fields).forEach(fieldName => {\n            const field = fields[fieldName];\n            const namedType = getNamedType(field.type);\n            visitOutputType(visitedTypes, pruningContext, namedType);\n            const args = field.args;\n            args.forEach(arg => {\n                const type = getNamedType(arg.type);\n                visitInputType(visitedTypes, pruningContext, type);\n            });\n        });\n        if (isInterfaceType(type)) {\n            Object.keys(pruningContext.implementations[type.name]).forEach(typeName => {\n                visitOutputType(visitedTypes, pruningContext, pruningContext.schema.getType(typeName));\n            });\n        }\n        if ('getInterfaces' in type) {\n            type.getInterfaces().forEach(type => {\n                visitOutputType(visitedTypes, pruningContext, type);\n            });\n        }\n    }\n    else if (isUnionType(type)) {\n        const types = type.getTypes();\n        types.forEach(type => visitOutputType(visitedTypes, pruningContext, type));\n    }\n}\nfunction visitInputType(visitedTypes, pruningContext, type) {\n    if (visitedTypes[type.name]) {\n        return;\n    }\n    pruningContext.unusedTypes[type.name] = false;\n    visitedTypes[type.name] = true;\n    if (isInputObjectType(type)) {\n        const fields = type.getFields();\n        Object.keys(fields).forEach(fieldName => {\n            const field = fields[fieldName];\n            const namedType = getNamedType(field.type);\n            visitInputType(visitedTypes, pruningContext, namedType);\n        });\n    }\n}\nfunction visitTypes(pruningContext, schema) {\n    Object.keys(schema.getTypeMap()).forEach(typeName => {\n        if (!typeName.startsWith('__')) {\n            pruningContext.unusedTypes[typeName] = true;\n        }\n    });\n    const visitedTypes = Object.create(null);\n    const rootTypes = [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()].filter(type => type != null);\n    rootTypes.forEach(rootType => visitOutputType(visitedTypes, pruningContext, rootType));\n    schema.getDirectives().forEach(directive => {\n        directive.args.forEach(arg => {\n            const type = getNamedType(arg.type);\n            visitInputType(visitedTypes, pruningContext, type);\n        });\n    });\n}\n//# sourceMappingURL=prune.js.map","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\nimport { isScalarType } from 'graphql';\nexport function mergeDeep(target, ...sources) {\n    if (isScalarType(target)) {\n        return target;\n    }\n    const output = {\n        ...target,\n    };\n    for (const source of sources) {\n        if (isObject(target) && isObject(source)) {\n            for (const key in source) {\n                if (isObject(source[key])) {\n                    if (!(key in target)) {\n                        Object.assign(output, { [key]: source[key] });\n                    }\n                    else {\n                        output[key] = mergeDeep(target[key], source[key]);\n                    }\n                }\n                else {\n                    Object.assign(output, { [key]: source[key] });\n                }\n            }\n        }\n    }\n    return output;\n}\nfunction isObject(item) {\n    return item && typeof item === 'object' && !Array.isArray(item);\n}\n//# sourceMappingURL=mergeDeep.js.map","import { Kind } from 'graphql';\nexport function renameFieldNode(fieldNode, name) {\n    return {\n        ...fieldNode,\n        alias: {\n            kind: Kind.NAME,\n            value: fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value,\n        },\n        name: {\n            kind: Kind.NAME,\n            value: name,\n        },\n    };\n}\nexport function preAliasFieldNode(fieldNode, str) {\n    return {\n        ...fieldNode,\n        alias: {\n            kind: Kind.NAME,\n            value: `${str}${fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value}`,\n        },\n    };\n}\nexport function wrapFieldNode(fieldNode, path) {\n    let newFieldNode = fieldNode;\n    path.forEach(fieldName => {\n        newFieldNode = {\n            kind: Kind.FIELD,\n            name: {\n                kind: Kind.NAME,\n                value: fieldName,\n            },\n            selectionSet: {\n                kind: Kind.SELECTION_SET,\n                selections: [fieldNode],\n            },\n        };\n    });\n    return newFieldNode;\n}\nfunction collectFields(selectionSet, fragments, fields = [], visitedFragmentNames = {}) {\n    if (selectionSet != null) {\n        selectionSet.selections.forEach(selection => {\n            switch (selection.kind) {\n                case Kind.FIELD:\n                    fields.push(selection);\n                    break;\n                case Kind.INLINE_FRAGMENT:\n                    collectFields(selection.selectionSet, fragments, fields, visitedFragmentNames);\n                    break;\n                case Kind.FRAGMENT_SPREAD: {\n                    const fragmentName = selection.name.value;\n                    if (!visitedFragmentNames[fragmentName]) {\n                        visitedFragmentNames[fragmentName] = true;\n                        collectFields(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);\n                    }\n                    break;\n                }\n                default:\n                    // unreachable\n                    break;\n            }\n        });\n    }\n    return fields;\n}\nexport function hoistFieldNodes({ fieldNode, fieldNames, path = [], delimeter = '__gqltf__', fragments, }) {\n    const alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;\n    let newFieldNodes = [];\n    if (path.length) {\n        const remainingPathSegments = path.slice();\n        const initialPathSegment = remainingPathSegments.shift();\n        collectFields(fieldNode.selectionSet, fragments).forEach((possibleFieldNode) => {\n            if (possibleFieldNode.name.value === initialPathSegment) {\n                newFieldNodes = newFieldNodes.concat(hoistFieldNodes({\n                    fieldNode: preAliasFieldNode(possibleFieldNode, `${alias}${delimeter}`),\n                    fieldNames,\n                    path: remainingPathSegments,\n                    delimeter,\n                    fragments,\n                }));\n            }\n        });\n    }\n    else {\n        collectFields(fieldNode.selectionSet, fragments).forEach((possibleFieldNode) => {\n            if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {\n                newFieldNodes.push(preAliasFieldNode(possibleFieldNode, `${alias}${delimeter}`));\n            }\n        });\n    }\n    return newFieldNodes;\n}\n//# sourceMappingURL=fieldNodes.js.map","import { Kind, parse } from 'graphql';\nexport function concatInlineFragments(type, fragments) {\n    const fragmentSelections = fragments.reduce((selections, fragment) => selections.concat(fragment.selectionSet.selections), []);\n    const deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);\n    return {\n        kind: Kind.INLINE_FRAGMENT,\n        typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n                kind: Kind.NAME,\n                value: type,\n            },\n        },\n        selectionSet: {\n            kind: Kind.SELECTION_SET,\n            selections: deduplicatedFragmentSelection,\n        },\n    };\n}\nfunction deduplicateSelection(nodes) {\n    const selectionMap = nodes.reduce((map, node) => {\n        switch (node.kind) {\n            case 'Field': {\n                if (node.alias != null) {\n                    if (node.alias.value in map) {\n                        return map;\n                    }\n                    return {\n                        ...map,\n                        [node.alias.value]: node,\n                    };\n                }\n                if (node.name.value in map) {\n                    return map;\n                }\n                return {\n                    ...map,\n                    [node.name.value]: node,\n                };\n            }\n            case 'FragmentSpread': {\n                if (node.name.value in map) {\n                    return map;\n                }\n                return {\n                    ...map,\n                    [node.name.value]: node,\n                };\n            }\n            case 'InlineFragment': {\n                if (map.__fragment != null) {\n                    const fragment = map.__fragment;\n                    return {\n                        ...map,\n                        __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node]),\n                    };\n                }\n                return {\n                    ...map,\n                    __fragment: node,\n                };\n            }\n            default: {\n                return map;\n            }\n        }\n    }, Object.create(null));\n    const selection = Object.keys(selectionMap).reduce((selectionList, node) => selectionList.concat(selectionMap[node]), []);\n    return selection;\n}\nexport function parseFragmentToInlineFragment(definitions) {\n    if (definitions.trim().startsWith('fragment')) {\n        const document = parse(definitions);\n        for (const definition of document.definitions) {\n            if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n                return {\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: definition.typeCondition,\n                    selectionSet: definition.selectionSet,\n                };\n            }\n        }\n    }\n    const query = parse(`{${definitions}}`).definitions[0];\n    for (const selection of query.selectionSet.selections) {\n        if (selection.kind === Kind.INLINE_FRAGMENT) {\n            return selection;\n        }\n    }\n    throw new Error('Could not parse fragment');\n}\n//# sourceMappingURL=fragments.js.map","import { parse, Kind, getNamedType } from 'graphql';\nexport function parseSelectionSet(selectionSet) {\n    const query = parse(selectionSet).definitions[0];\n    return query.selectionSet;\n}\nexport function typesContainSelectionSet(types, selectionSet) {\n    const fieldMaps = types.map(type => type.getFields());\n    for (const selection of selectionSet.selections) {\n        if (selection.kind === Kind.FIELD) {\n            const fields = fieldMaps.map(fieldMap => fieldMap[selection.name.value]).filter(field => field != null);\n            if (!fields.length) {\n                return false;\n            }\n            if (selection.selectionSet != null) {\n                return typesContainSelectionSet(fields.map(field => getNamedType(field.type)), selection.selectionSet);\n            }\n        }\n        else if (selection.kind === Kind.INLINE_FRAGMENT && selection.typeCondition.name.value === types[0].name) {\n            return typesContainSelectionSet(types, selection.selectionSet);\n        }\n    }\n    return true;\n}\nexport function typeContainsSelectionSet(type, selectionSet) {\n    const fields = type.getFields();\n    for (const selection of selectionSet.selections) {\n        if (selection.kind === Kind.FIELD) {\n            const field = fields[selection.name.value];\n            if (field == null) {\n                return false;\n            }\n            if (selection.selectionSet != null) {\n                return typeContainsSelectionSet(getNamedType(field.type), selection.selectionSet);\n            }\n        }\n        else if (selection.kind === Kind.INLINE_FRAGMENT && selection.typeCondition.name.value === type.name) {\n            return typeContainsSelectionSet(type, selection.selectionSet);\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=selectionSets.js.map","/**\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\n * resolves aliases.\n * @param info The info argument to the resolver.\n */\nexport function getResponseKeyFromInfo(info) {\n    return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;\n}\n//# sourceMappingURL=getResponseKeyFromInfo.js.map","import { cloneSchema } from './clone';\nexport function applySchemaTransforms(originalSchema, transforms) {\n    return transforms.reduce((schema, transform) => transform.transformSchema != null ? transform.transformSchema(cloneSchema(schema)) : schema, originalSchema);\n}\nexport function applyRequestTransforms(originalRequest, transforms) {\n    return transforms.reduce((request, transform) => transform.transformRequest != null ? transform.transformRequest(request) : request, originalRequest);\n}\nexport function applyResultTransforms(originalResult, transforms) {\n    return transforms.reduceRight((result, transform) => transform.transformResult != null ? transform.transformResult(result) : result, originalResult);\n}\n//# sourceMappingURL=transforms.js.map","import { GraphQLObjectType } from 'graphql';\nimport { MapperKind } from './Interfaces';\nimport { mapSchema, correctASTNodes } from './mapSchema';\nimport { addTypes } from './addTypes';\nexport function appendObjectFields(schema, typeName, additionalFields) {\n    if (schema.getType(typeName) == null) {\n        return addTypes(schema, [\n            new GraphQLObjectType({\n                name: typeName,\n                fields: additionalFields,\n            }),\n        ]);\n    }\n    return mapSchema(schema, {\n        [MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                Object.keys(originalFieldConfigMap).forEach(fieldName => {\n                    newFieldConfigMap[fieldName] = originalFieldConfigMap[fieldName];\n                });\n                Object.keys(additionalFields).forEach(fieldName => {\n                    newFieldConfigMap[fieldName] = additionalFields[fieldName];\n                });\n                return correctASTNodes(new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n}\nexport function removeObjectFields(schema, typeName, testFn) {\n    const removedFields = {};\n    const newSchema = mapSchema(schema, {\n        [MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                Object.keys(originalFieldConfigMap).forEach(fieldName => {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        removedFields[fieldName] = originalFieldConfig;\n                    }\n                    else {\n                        newFieldConfigMap[fieldName] = originalFieldConfig;\n                    }\n                });\n                return correctASTNodes(new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n    return [newSchema, removedFields];\n}\nexport function selectObjectFields(schema, typeName, testFn) {\n    const selectedFields = {};\n    mapSchema(schema, {\n        [MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                Object.keys(originalFieldConfigMap).forEach(fieldName => {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        selectedFields[fieldName] = originalFieldConfig;\n                    }\n                });\n            }\n            return undefined;\n        },\n    });\n    return selectedFields;\n}\nexport function modifyObjectFields(schema, typeName, testFn, newFields) {\n    const removedFields = {};\n    const newSchema = mapSchema(schema, {\n        [MapperKind.OBJECT_TYPE]: type => {\n            if (type.name === typeName) {\n                const config = type.toConfig();\n                const originalFieldConfigMap = config.fields;\n                const newFieldConfigMap = {};\n                Object.keys(originalFieldConfigMap).forEach(fieldName => {\n                    const originalFieldConfig = originalFieldConfigMap[fieldName];\n                    if (testFn(fieldName, originalFieldConfig)) {\n                        removedFields[fieldName] = originalFieldConfig;\n                    }\n                    else {\n                        newFieldConfigMap[fieldName] = originalFieldConfig;\n                    }\n                });\n                Object.keys(newFields).forEach(fieldName => {\n                    const fieldConfig = newFields[fieldName];\n                    newFieldConfigMap[fieldName] = fieldConfig;\n                });\n                return correctASTNodes(new GraphQLObjectType({\n                    ...config,\n                    fields: newFieldConfigMap,\n                }));\n            }\n        },\n    });\n    return [newSchema, removedFields];\n}\n//# sourceMappingURL=fields.js.map","import { GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, isEnumType, isInterfaceType, isInputObjectType, isObjectType, isScalarType, isUnionType, } from 'graphql';\nexport function renameType(type, newTypeName) {\n    if (isObjectType(type)) {\n        return new GraphQLObjectType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (isInterfaceType(type)) {\n        return new GraphQLInterfaceType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (isUnionType(type)) {\n        return new GraphQLUnionType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (isInputObjectType(type)) {\n        return new GraphQLInputObjectType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (isEnumType(type)) {\n        return new GraphQLEnumType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    else if (isScalarType(type)) {\n        return new GraphQLScalarType({\n            ...type.toConfig(),\n            name: newTypeName,\n            astNode: type.astNode == null\n                ? type.astNode\n                : {\n                    ...type.astNode,\n                    name: {\n                        ...type.astNode.name,\n                        value: newTypeName,\n                    },\n                },\n            extensionASTNodes: type.extensionASTNodes == null\n                ? type.extensionASTNodes\n                : type.extensionASTNodes.map(node => ({\n                    ...node,\n                    name: {\n                        ...node.name,\n                        value: newTypeName,\n                    },\n                })),\n        });\n    }\n    throw new Error(`Unknown type ${type}.`);\n}\n//# sourceMappingURL=renameType.js.map","import { Kind, getDirectiveValues, GraphQLSkipDirective, GraphQLIncludeDirective, typeFromAST, isAbstractType, } from 'graphql';\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field which\n * returns an Interface or Union type, the \"runtime type\" will be the actual\n * Object type returned by that field.\n *\n * @internal\n */\nexport function collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {\n    for (const selection of selectionSet.selections) {\n        switch (selection.kind) {\n            case Kind.FIELD: {\n                if (!shouldIncludeNode(exeContext, selection)) {\n                    continue;\n                }\n                const name = getFieldEntryKey(selection);\n                if (!(name in fields)) {\n                    fields[name] = [];\n                }\n                fields[name].push(selection);\n                break;\n            }\n            case Kind.INLINE_FRAGMENT: {\n                if (!shouldIncludeNode(exeContext, selection) ||\n                    !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\n                    continue;\n                }\n                collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n                break;\n            }\n            case Kind.FRAGMENT_SPREAD: {\n                const fragName = selection.name.value;\n                if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {\n                    continue;\n                }\n                visitedFragmentNames[fragName] = true;\n                const fragment = exeContext.fragments[fragName];\n                if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\n                    continue;\n                }\n                collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n                break;\n            }\n        }\n    }\n    return fields;\n}\n/**\n * Determines if a field should be included based on the @include and @skip\n * directives, where @skip has higher precedence than @include.\n */\nfunction shouldIncludeNode(exeContext, node) {\n    const skip = getDirectiveValues(GraphQLSkipDirective, node, exeContext.variableValues);\n    if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {\n        return false;\n    }\n    const include = getDirectiveValues(GraphQLIncludeDirective, node, exeContext.variableValues);\n    if ((include === null || include === void 0 ? void 0 : include.if) === false) {\n        return false;\n    }\n    return true;\n}\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(exeContext, fragment, type) {\n    const typeConditionNode = fragment.typeCondition;\n    if (!typeConditionNode) {\n        return true;\n    }\n    const conditionalType = typeFromAST(exeContext.schema, typeConditionNode);\n    if (conditionalType === type) {\n        return true;\n    }\n    if (isAbstractType(conditionalType)) {\n        return exeContext.schema.isPossibleType(conditionalType, type);\n    }\n    return false;\n}\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    return node.alias ? node.alias.value : node.name.value;\n}\n//# sourceMappingURL=collectFields.js.map","/**\n * Given an AsyncIterable and a callback function, return an AsyncIterator\n * which produces values mapped via calling the callback function.\n */\nexport function mapAsyncIterator(iterator, callback, rejectCallback) {\n    let $return;\n    let abruptClose;\n    if (typeof iterator.return === 'function') {\n        $return = iterator.return;\n        abruptClose = (error) => {\n            const rethrow = () => Promise.reject(error);\n            return $return.call(iterator).then(rethrow, rethrow);\n        };\n    }\n    function mapResult(result) {\n        return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n    }\n    let mapReject;\n    if (rejectCallback) {\n        // Capture rejectCallback to ensure it cannot be null.\n        const reject = rejectCallback;\n        mapReject = (error) => asyncMapValue(error, reject).then(iteratorResult, abruptClose);\n    }\n    return {\n        next() {\n            return iterator.next().then(mapResult, mapReject);\n        },\n        return() {\n            return $return\n                ? $return.call(iterator).then(mapResult, mapReject)\n                : Promise.resolve({ value: undefined, done: true });\n        },\n        throw(error) {\n            if (typeof iterator.throw === 'function') {\n                return iterator.throw(error).then(mapResult, mapReject);\n            }\n            return Promise.reject(error).catch(abruptClose);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\nfunction asyncMapValue(value, callback) {\n    return new Promise(resolve => resolve(callback(value)));\n}\nfunction iteratorResult(value) {\n    return { value, done: false };\n}\n//# sourceMappingURL=mapAsyncIterator.js.map","import { isNonNullType, Kind, isListType } from 'graphql';\nexport function astFromType(type) {\n    if (isNonNullType(type)) {\n        const innerType = astFromType(type.ofType);\n        if (innerType.kind === Kind.NON_NULL_TYPE) {\n            throw new Error(`Invalid type node ${JSON.stringify(type)}. Inner type of non-null type cannot be a non-null type.`);\n        }\n        return {\n            kind: Kind.NON_NULL_TYPE,\n            type: innerType,\n        };\n    }\n    else if (isListType(type)) {\n        return {\n            kind: Kind.LIST_TYPE,\n            type: astFromType(type.ofType),\n        };\n    }\n    return {\n        kind: Kind.NAMED_TYPE,\n        name: {\n            kind: Kind.NAME,\n            value: type.name,\n        },\n    };\n}\n//# sourceMappingURL=astFromType.js.map","import { Kind } from 'graphql';\nimport { astFromType } from './astFromType';\nexport function updateArgument(argName, argType, argumentNodes, variableDefinitionsMap, variableValues, newArg) {\n    let varName;\n    let numGeneratedVariables = 0;\n    do {\n        varName = `_v${(numGeneratedVariables++).toString()}_${argName}`;\n    } while (varName in variableDefinitionsMap);\n    argumentNodes[argName] = {\n        kind: Kind.ARGUMENT,\n        name: {\n            kind: Kind.NAME,\n            value: argName,\n        },\n        value: {\n            kind: Kind.VARIABLE,\n            name: {\n                kind: Kind.NAME,\n                value: varName,\n            },\n        },\n    };\n    variableDefinitionsMap[varName] = {\n        kind: Kind.VARIABLE_DEFINITION,\n        variable: {\n            kind: Kind.VARIABLE,\n            name: {\n                kind: Kind.NAME,\n                value: varName,\n            },\n        },\n        type: astFromType(argType),\n    };\n    if (newArg === undefined) {\n        delete variableValues[varName];\n    }\n    else {\n        variableValues[varName] = newArg;\n    }\n}\n//# sourceMappingURL=updateArgument.js.map","import { doTypesOverlap, isCompositeType } from 'graphql';\nexport function implementsAbstractType(schema, typeA, typeB) {\n    if (typeA === typeB) {\n        return true;\n    }\n    else if (isCompositeType(typeA) && isCompositeType(typeB)) {\n        return doTypesOverlap(schema, typeA, typeB);\n    }\n    return false;\n}\n//# sourceMappingURL=implementsAbstractType.js.map","import { GraphQLError } from 'graphql';\nexport const ERROR_SYMBOL = Symbol('subschemaErrors');\nexport function relocatedError(originalError, path) {\n    return new GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? undefined : path === undefined ? originalError.path : path, originalError.originalError, originalError.extensions);\n}\nexport function slicedError(originalError) {\n    return relocatedError(originalError, originalError.path != null ? originalError.path.slice(1) : undefined);\n}\nexport function getErrorsByPathSegment(errors) {\n    const record = Object.create(null);\n    errors.forEach(error => {\n        if (!error.path || error.path.length < 2) {\n            return;\n        }\n        const pathSegment = error.path[1];\n        const current = pathSegment in record ? record[pathSegment] : [];\n        current.push(slicedError(error));\n        record[pathSegment] = current;\n    });\n    return record;\n}\nexport function setErrors(result, errors) {\n    result[ERROR_SYMBOL] = errors;\n}\nexport function getErrors(result, pathSegment) {\n    const errors = result != null ? result[ERROR_SYMBOL] : result;\n    if (!Array.isArray(errors)) {\n        return null;\n    }\n    const fieldErrors = [];\n    for (const error of errors) {\n        if (!error.path || error.path[0] === pathSegment) {\n            fieldErrors.push(error);\n        }\n    }\n    return fieldErrors;\n}\n//# sourceMappingURL=errors.js.map","export function inputFieldToFieldConfig(field) {\n    return {\n        description: field.description,\n        type: field.type,\n        defaultValue: field.defaultValue,\n        extensions: field.extensions,\n        astNode: field.astNode,\n    };\n}\nexport function fieldToFieldConfig(field) {\n    return {\n        description: field.description,\n        type: field.type,\n        args: argsToFieldConfigArgumentMap(field.args),\n        resolve: field.resolve,\n        subscribe: field.subscribe,\n        deprecationReason: field.deprecationReason,\n        extensions: field.extensions,\n        astNode: field.astNode,\n    };\n}\nexport function argsToFieldConfigArgumentMap(args) {\n    const newArguments = {};\n    args.forEach(arg => {\n        newArguments[arg.name] = argumentToArgumentConfig(arg);\n    });\n    return newArguments;\n}\nexport function argumentToArgumentConfig(arg) {\n    return {\n        description: arg.description,\n        type: arg.type,\n        defaultValue: arg.defaultValue,\n        extensions: arg.extensions,\n        astNode: arg.astNode,\n    };\n}\n//# sourceMappingURL=toConfig.js.map","export function observableToAsyncIterable(observable) {\n    const pullQueue = [];\n    const pushQueue = [];\n    let listening = true;\n    const pushValue = (value) => {\n        if (pullQueue.length !== 0) {\n            pullQueue.shift()({ value, done: false });\n        }\n        else {\n            pushQueue.push({ value });\n        }\n    };\n    const pushError = (error) => {\n        if (pullQueue.length !== 0) {\n            pullQueue.shift()({ value: { errors: [error] }, done: false });\n        }\n        else {\n            pushQueue.push({ value: { errors: [error] } });\n        }\n    };\n    const pullValue = () => new Promise(resolve => {\n        if (pushQueue.length !== 0) {\n            const element = pushQueue.shift();\n            // either {value: {errors: [...]}} or {value: ...}\n            resolve({\n                ...element,\n                done: false,\n            });\n        }\n        else {\n            pullQueue.push(resolve);\n        }\n    });\n    const subscription = observable.subscribe({\n        next(value) {\n            pushValue(value);\n        },\n        error(err) {\n            pushError(err);\n        },\n    });\n    const emptyQueue = () => {\n        if (listening) {\n            listening = false;\n            subscription.unsubscribe();\n            pullQueue.forEach(resolve => resolve({ value: undefined, done: true }));\n            pullQueue.length = 0;\n            pushQueue.length = 0;\n        }\n    };\n    return {\n        next() {\n            return listening ? pullValue() : this.return();\n        },\n        return() {\n            emptyQueue();\n            return Promise.resolve({ value: undefined, done: true });\n        },\n        throw(error) {\n            emptyQueue();\n            return Promise.reject(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n}\n//# sourceMappingURL=observableToAsyncIterable.js.map","import { getOperationRootType, getOperationAST, Kind, isListType, getNullableType, isAbstractType, isObjectType, } from 'graphql';\nimport { collectFields } from './collectFields';\nexport function visitData(data, enter, leave) {\n    if (Array.isArray(data)) {\n        return data.map(value => visitData(value, enter, leave));\n    }\n    else if (typeof data === 'object') {\n        const newData = enter != null ? enter(data) : data;\n        if (newData != null) {\n            Object.keys(newData).forEach(key => {\n                const value = newData[key];\n                newData[key] = visitData(value, enter, leave);\n            });\n        }\n        return leave != null ? leave(newData) : newData;\n    }\n    return data;\n}\nexport function visitErrors(errors, visitor) {\n    return errors.map(error => visitor(error));\n}\nexport function visitResult(result, request, schema, resultVisitorMap, errorVisitorMap) {\n    const partialExecutionContext = {\n        schema,\n        fragments: request.document.definitions.reduce((acc, def) => {\n            if (def.kind === Kind.FRAGMENT_DEFINITION) {\n                acc[def.name.value] = def;\n            }\n            return acc;\n        }, {}),\n        variableValues: request.variables,\n    };\n    const errorInfo = {\n        segmentInfoMap: new Map(),\n        unpathedErrors: [],\n    };\n    const data = result.data;\n    const errors = result.errors;\n    const visitingErrors = errors != null && errorVisitorMap != null;\n    if (data != null) {\n        result.data = visitRoot(data, getOperationAST(request.document, undefined), partialExecutionContext, resultVisitorMap, visitingErrors ? errors : undefined, errorInfo);\n    }\n    if (visitingErrors) {\n        result.errors = visitErrorsByType(errors, errorVisitorMap, errorInfo);\n    }\n    return result;\n}\nfunction visitErrorsByType(errors, errorVisitorMap, errorInfo) {\n    return errors.map(error => {\n        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n        if (pathSegmentsInfo == null) {\n            return error;\n        }\n        return pathSegmentsInfo.reduceRight((acc, segmentInfo) => {\n            const typeName = segmentInfo.type.name;\n            const typeVisitorMap = errorVisitorMap[typeName];\n            if (typeVisitorMap == null) {\n                return acc;\n            }\n            const errorVisitor = typeVisitorMap[segmentInfo.fieldName];\n            return errorVisitor == null ? acc : errorVisitor(acc, segmentInfo.pathIndex);\n        }, error);\n    });\n}\nfunction visitRoot(root, operation, exeContext, resultVisitorMap, errors, errorInfo) {\n    const operationRootType = getOperationRootType(exeContext.schema, operation);\n    const collectedFields = collectFields(exeContext, operationRootType, operation.selectionSet, Object.create(null), Object.create(null));\n    return visitObjectValue(root, operationRootType, collectedFields, exeContext, resultVisitorMap, 0, errors, errorInfo);\n}\nfunction visitObjectValue(object, type, fieldNodeMap, exeContext, resultVisitorMap, pathIndex, errors, errorInfo) {\n    const fieldMap = type.getFields();\n    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[type.name];\n    const enterObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__enter;\n    const newObject = enterObject != null ? enterObject(object) : object;\n    let sortedErrors;\n    let errorMap;\n    if (errors != null) {\n        sortedErrors = sortErrorsByPathSegment(errors, pathIndex);\n        errorMap = sortedErrors.errorMap;\n        errorInfo.unpathedErrors = errorInfo.unpathedErrors.concat(sortedErrors.unpathedErrors);\n    }\n    Object.keys(fieldNodeMap).forEach(responseKey => {\n        const subFieldNodes = fieldNodeMap[responseKey];\n        const fieldName = subFieldNodes[0].name.value;\n        const fieldType = fieldMap[fieldName].type;\n        const newPathIndex = pathIndex + 1;\n        let fieldErrors;\n        if (errors != null) {\n            fieldErrors = errorMap[responseKey];\n            if (fieldErrors != null) {\n                delete errorMap[responseKey];\n            }\n            addPathSegmentInfo(type, fieldName, newPathIndex, fieldErrors, errorInfo);\n        }\n        const newValue = visitFieldValue(object[responseKey], fieldType, subFieldNodes, exeContext, resultVisitorMap, newPathIndex, fieldErrors, errorInfo);\n        updateObject(newObject, responseKey, newValue, typeVisitorMap, fieldName);\n    });\n    const oldTypename = newObject.__typename;\n    if (oldTypename != null) {\n        updateObject(newObject, '__typename', oldTypename, typeVisitorMap, '__typename');\n    }\n    if (errors != null) {\n        Object.keys(errorMap).forEach(unknownResponseKey => {\n            errorInfo.unpathedErrors = errorInfo.unpathedErrors.concat(errorMap[unknownResponseKey]);\n        });\n    }\n    const leaveObject = typeVisitorMap === null || typeVisitorMap === void 0 ? void 0 : typeVisitorMap.__leave;\n    return leaveObject != null ? leaveObject(newObject) : newObject;\n}\nfunction updateObject(object, responseKey, newValue, typeVisitorMap, fieldName) {\n    if (typeVisitorMap == null) {\n        object[responseKey] = newValue;\n        return;\n    }\n    const fieldVisitor = typeVisitorMap[fieldName];\n    if (fieldVisitor == null) {\n        object[responseKey] = newValue;\n        return;\n    }\n    const visitedValue = fieldVisitor(newValue);\n    if (visitedValue === undefined) {\n        delete object[responseKey];\n        return;\n    }\n    object[responseKey] = visitedValue;\n}\nfunction visitListValue(list, returnType, fieldNodes, exeContext, resultVisitorMap, pathIndex, errors, errorInfo) {\n    return list.map(listMember => visitFieldValue(listMember, returnType, fieldNodes, exeContext, resultVisitorMap, pathIndex + 1, errors, errorInfo));\n}\nfunction visitFieldValue(value, returnType, fieldNodes, exeContext, resultVisitorMap, pathIndex, errors = [], errorInfo) {\n    if (value == null) {\n        return value;\n    }\n    const nullableType = getNullableType(returnType);\n    if (isListType(nullableType)) {\n        return visitListValue(value, nullableType.ofType, fieldNodes, exeContext, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    else if (isAbstractType(nullableType)) {\n        const finalType = exeContext.schema.getType(value.__typename);\n        const collectedFields = collectSubFields(exeContext, finalType, fieldNodes);\n        return visitObjectValue(value, finalType, collectedFields, exeContext, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    else if (isObjectType(nullableType)) {\n        const collectedFields = collectSubFields(exeContext, nullableType, fieldNodes);\n        return visitObjectValue(value, nullableType, collectedFields, exeContext, resultVisitorMap, pathIndex, errors, errorInfo);\n    }\n    const typeVisitorMap = resultVisitorMap === null || resultVisitorMap === void 0 ? void 0 : resultVisitorMap[nullableType.name];\n    if (typeVisitorMap == null) {\n        return value;\n    }\n    const visitedValue = typeVisitorMap(value);\n    return visitedValue === undefined ? value : visitedValue;\n}\nfunction sortErrorsByPathSegment(errors, pathIndex) {\n    const errorMap = Object.create(null);\n    const unpathedErrors = [];\n    errors.forEach(error => {\n        var _a;\n        const pathSegment = (_a = error.path) === null || _a === void 0 ? void 0 : _a[pathIndex];\n        if (pathSegment == null) {\n            unpathedErrors.push(error);\n            return;\n        }\n        if (pathSegment in errorMap) {\n            errorMap[pathSegment].push(error);\n        }\n        else {\n            errorMap[pathSegment] = [error];\n        }\n    });\n    return {\n        errorMap,\n        unpathedErrors,\n    };\n}\nfunction addPathSegmentInfo(type, fieldName, pathIndex, errors = [], errorInfo) {\n    errors.forEach(error => {\n        const segmentInfo = {\n            type,\n            fieldName,\n            pathIndex,\n        };\n        const pathSegmentsInfo = errorInfo.segmentInfoMap.get(error);\n        if (pathSegmentsInfo == null) {\n            errorInfo.segmentInfoMap.set(error, [segmentInfo]);\n        }\n        else {\n            pathSegmentsInfo.push(segmentInfo);\n        }\n    });\n}\nfunction collectSubFields(exeContext, type, fieldNodes) {\n    let subFieldNodes = Object.create(null);\n    const visitedFragmentNames = Object.create(null);\n    fieldNodes.forEach(fieldNode => {\n        subFieldNodes = collectFields(exeContext, type, fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n    });\n    return subFieldNodes;\n}\n//# sourceMappingURL=visitResult.js.map","export function valueMatchesCriteria(value, criteria) {\n    if (value == null) {\n        return value === criteria;\n    }\n    else if (Array.isArray(value)) {\n        return Array.isArray(criteria) && value.every((val, index) => valueMatchesCriteria(val, criteria[index]));\n    }\n    else if (typeof value === 'object') {\n        return (typeof criteria === 'object' &&\n            criteria &&\n            Object.keys(criteria).every(propertyName => valueMatchesCriteria(value[propertyName], criteria[propertyName])));\n    }\n    else if (criteria instanceof RegExp) {\n        return criteria.test(value);\n    }\n    return value === criteria;\n}\n//# sourceMappingURL=valueMatchesCriteria.js.map"]},"metadata":{},"sourceType":"module"}