{"ast":null,"code":"import { printSchemaWithDirectives } from '@graphql-tools/utils';\nimport { concatAST, parse } from 'graphql';\nimport { transform as transform$2 } from 'relay-compiler/lib/transforms/SkipRedundantNodesTransform';\nimport { transform as transform$3 } from 'relay-compiler/lib/transforms/InlineFragmentsTransform';\nimport { transform as transform$1 } from 'relay-compiler/lib/transforms/ApplyFragmentArgumentTransform';\nimport { transformWithOptions } from 'relay-compiler/lib/transforms/FlattenTransform';\nimport CompilerContext from 'relay-compiler/lib/core/CompilerContext';\nimport { transform } from 'relay-compiler/lib/core/RelayParser';\nimport { print } from 'relay-compiler/lib/core/IRPrinter';\nimport { create } from 'relay-compiler/lib/core/Schema';\n\nfunction optimizeDocuments(schema, documents, options = {}) {\n  options = {\n    noLocation: true,\n    ...options\n  }; // @TODO way for users to define directives they use, otherwise relay will throw an unknown directive error\n  // Maybe we can scan the queries and add them dynamically without users having to do some extra stuff\n  // transformASTSchema creates a new schema instance instead of mutating the old one\n\n  const adjustedSchema = create(printSchemaWithDirectives(schema, options));\n  const documentAsts = concatAST(documents);\n  const relayDocuments = transform(adjustedSchema, documentAsts.definitions);\n  const result = [];\n\n  if (options.includeFragments) {\n    const fragmentCompilerContext = new CompilerContext(adjustedSchema).addAll(relayDocuments).applyTransforms([transform$1, transformWithOptions({\n      flattenAbstractTypes: false\n    }), transform$2]);\n    result.push(...fragmentCompilerContext.documents().filter(doc => doc.kind === 'Fragment').map(doc => parse(print(adjustedSchema, doc), options)));\n  }\n\n  const queryCompilerContext = new CompilerContext(adjustedSchema).addAll(relayDocuments).applyTransforms([transform$1, transform$3, transformWithOptions({\n    flattenAbstractTypes: false\n  }), transform$2]);\n  result.push(...queryCompilerContext.documents().map(doc => parse(print(adjustedSchema, doc), options)));\n  return result;\n}\n\nexport { optimizeDocuments };","map":{"version":3,"sources":["../../../dist/relay-operation-optimizer/src/index.js"],"names":["relayCreate","relayTransform","applyFragmentArgumentTransform","flattenTransformWithOptions","skipRedundantNodesTransform","relayPrint","inlineFragmentsTransform"],"mappings":";;;;;;;;;;;AAUO,SAAS,iBAAT,CAA2B,MAA3B,EAAmC,SAAnC,EAA8C,OAAO,GAAG,EAAxD,EAA4D;AAC/D,EAAA,OAAO,GAAG;AACN,IAAA,UAAU,EAAE,IADN;AAEN,OAAG;AAFG,GAAV,CAD+D,CAKnE;AACA;AACA;;AACI,QAAM,cAAc,GAAGA,MAAW,CAAC,yBAAyB,CAAC,MAAD,EAAS,OAAT,CAA1B,CAAlC;AACA,QAAM,YAAY,GAAG,SAAS,CAAC,SAAD,CAA9B;AACA,QAAM,cAAc,GAAGC,SAAc,CAAC,cAAD,EAAiB,YAAY,CAAC,WAA9B,CAArC;AACA,QAAM,MAAM,GAAG,EAAf;;AACA,MAAI,OAAO,CAAC,gBAAZ,EAA8B;AAC1B,UAAM,uBAAuB,GAAG,IAAI,eAAJ,CAAoB,cAApB,EAC3B,MAD2B,CACpB,cADoB,EAE3B,eAF2B,CAEX,CACjBC,WADiB,EAEjBC,oBAA2B,CAAC;AAAE,MAAA,oBAAoB,EAAE;AAAxB,KAAD,CAFV,EAGjBC,WAHiB,CAFW,CAAhC;AAOA,IAAA,MAAM,CAAC,IAAP,CAAY,GAAG,uBAAuB,CACjC,SADU,GAEV,MAFU,CAEH,GAAG,IAAI,GAAG,CAAC,IAAJ,KAAa,UAFjB,EAGV,GAHU,CAGN,GAAG,IAAI,KAAK,CAACC,KAAU,CAAC,cAAD,EAAiB,GAAjB,CAAX,EAAkC,OAAlC,CAHN,CAAf;AAIH;;AACD,QAAM,oBAAoB,GAAG,IAAI,eAAJ,CAAoB,cAApB,EACxB,MADwB,CACjB,cADiB,EAExB,eAFwB,CAER,CACjBH,WADiB,EAEjBI,WAFiB,EAGjBH,oBAA2B,CAAC;AAAE,IAAA,oBAAoB,EAAE;AAAxB,GAAD,CAHV,EAIjBC,WAJiB,CAFQ,CAA7B;AAQA,EAAA,MAAM,CAAC,IAAP,CAAY,GAAG,oBAAoB,CAAC,SAArB,GAAiC,GAAjC,CAAqC,GAAG,IAAI,KAAK,CAACC,KAAU,CAAC,cAAD,EAAiB,GAAjB,CAAX,EAAkC,OAAlC,CAAjD,CAAf;AACA,SAAO,MAAP;AACJ","sourcesContent":["import { printSchemaWithDirectives } from '@graphql-tools/utils';\nimport { parse, concatAST } from 'graphql';\nimport { transform as skipRedundantNodesTransform } from 'relay-compiler/lib/transforms/SkipRedundantNodesTransform';\nimport { transform as inlineFragmentsTransform } from 'relay-compiler/lib/transforms/InlineFragmentsTransform';\nimport { transform as applyFragmentArgumentTransform } from 'relay-compiler/lib/transforms/ApplyFragmentArgumentTransform';\nimport { transformWithOptions as flattenTransformWithOptions } from 'relay-compiler/lib/transforms/FlattenTransform';\nimport CompilerContext from 'relay-compiler/lib/core/CompilerContext';\nimport { transform as relayTransform } from 'relay-compiler/lib/core/RelayParser';\nimport { print as relayPrint } from 'relay-compiler/lib/core/IRPrinter';\nimport { create as relayCreate } from 'relay-compiler/lib/core/Schema';\nexport function optimizeDocuments(schema, documents, options = {}) {\n    options = {\n        noLocation: true,\n        ...options,\n    };\n    // @TODO way for users to define directives they use, otherwise relay will throw an unknown directive error\n    // Maybe we can scan the queries and add them dynamically without users having to do some extra stuff\n    // transformASTSchema creates a new schema instance instead of mutating the old one\n    const adjustedSchema = relayCreate(printSchemaWithDirectives(schema, options));\n    const documentAsts = concatAST(documents);\n    const relayDocuments = relayTransform(adjustedSchema, documentAsts.definitions);\n    const result = [];\n    if (options.includeFragments) {\n        const fragmentCompilerContext = new CompilerContext(adjustedSchema)\n            .addAll(relayDocuments)\n            .applyTransforms([\n            applyFragmentArgumentTransform,\n            flattenTransformWithOptions({ flattenAbstractTypes: false }),\n            skipRedundantNodesTransform,\n        ]);\n        result.push(...fragmentCompilerContext\n            .documents()\n            .filter(doc => doc.kind === 'Fragment')\n            .map(doc => parse(relayPrint(adjustedSchema, doc), options)));\n    }\n    const queryCompilerContext = new CompilerContext(adjustedSchema)\n        .addAll(relayDocuments)\n        .applyTransforms([\n        applyFragmentArgumentTransform,\n        inlineFragmentsTransform,\n        flattenTransformWithOptions({ flattenAbstractTypes: false }),\n        skipRedundantNodesTransform,\n    ]);\n    result.push(...queryCompilerContext.documents().map(doc => parse(relayPrint(adjustedSchema, doc), options)));\n    return result;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}