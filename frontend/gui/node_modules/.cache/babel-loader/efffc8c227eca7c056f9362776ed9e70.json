{"ast":null,"code":"import { Kind, parse, Source } from 'graphql';\nimport { readFileSync, realpathSync } from 'fs-extra';\nimport { join, isAbsolute, dirname } from 'path';\nimport resolveFrom from 'resolve-from';\n/* eslint-disable no-unused-expressions */\n\nconst builtinTypes = ['String', 'Float', 'Int', 'Boolean', 'ID', 'Upload'];\nconst builtinDirectives = ['deprecated', 'skip', 'include', 'cacheControl', 'key', 'external', 'requires', 'provides', 'connection', 'client'];\nconst IMPORT_FROM_REGEX = /^import\\s+(\\*|(.*))\\s+from\\s+('|\")(.*)('|\");?$/;\nconst IMPORT_DEFAULT_REGEX = /^import\\s+('|\")(.*)('|\");?$/;\n\nfunction processImport(filePath, cwd = process.cwd(), predefinedImports = {}) {\n  const visitedFiles = new Map();\n  const set = visitFile(filePath, join(cwd + '/root.graphql'), visitedFiles, predefinedImports);\n  const definitionSet = new Set();\n\n  for (const defs of set.values()) {\n    for (const def of defs) {\n      definitionSet.add(def);\n    }\n  }\n\n  return {\n    kind: Kind.DOCUMENT,\n    definitions: [...definitionSet]\n  };\n}\n\nfunction visitFile(filePath, cwd, visitedFiles, predefinedImports) {\n  if (!isAbsolute(filePath) && !(filePath in predefinedImports)) {\n    filePath = resolveFilePath(cwd, filePath);\n  }\n\n  if (!visitedFiles.has(filePath)) {\n    const fileContent = filePath in predefinedImports ? predefinedImports[filePath] : readFileSync(filePath, 'utf8');\n    const importLines = [];\n    let otherLines = '';\n\n    for (const line of fileContent.split('\\n')) {\n      const trimmedLine = line.trim();\n\n      if (trimmedLine.startsWith('#import ') || trimmedLine.startsWith('# import ')) {\n        importLines.push(trimmedLine);\n      } else if (trimmedLine) {\n        otherLines += line + '\\n';\n      }\n    }\n\n    const definitionsByName = new Map();\n    const dependenciesByDefinitionName = new Map();\n\n    if (otherLines) {\n      const fileDefinitionMap = new Map(); // To prevent circular dependency\n\n      visitedFiles.set(filePath, fileDefinitionMap);\n      const document = parse(new Source(otherLines, filePath), {\n        noLocation: true\n      });\n\n      for (const definition of document.definitions) {\n        if ('name' in definition || definition.kind === Kind.SCHEMA_DEFINITION) {\n          const definitionName = 'name' in definition ? definition.name.value : 'schema';\n\n          if (!definitionsByName.has(definitionName)) {\n            definitionsByName.set(definitionName, new Set());\n          }\n\n          const definitionsSet = definitionsByName.get(definitionName);\n          definitionsSet.add(definition);\n\n          if (!dependenciesByDefinitionName.has(definitionName)) {\n            dependenciesByDefinitionName.set(definitionName, new Set());\n          }\n\n          const dependencySet = dependenciesByDefinitionName.get(definitionName);\n\n          switch (definition.kind) {\n            case Kind.OPERATION_DEFINITION:\n              visitOperationDefinitionNode(definition, dependencySet);\n              break;\n\n            case Kind.FRAGMENT_DEFINITION:\n              visitFragmentDefinitionNode(definition, dependencySet);\n              break;\n\n            case Kind.OBJECT_TYPE_DEFINITION:\n              visitObjectTypeDefinitionNode(definition, dependencySet, dependenciesByDefinitionName);\n              break;\n\n            case Kind.INTERFACE_TYPE_DEFINITION:\n              visitInterfaceTypeDefinitionNode(definition, dependencySet, dependenciesByDefinitionName);\n              break;\n\n            case Kind.UNION_TYPE_DEFINITION:\n              visitUnionTypeDefinitionNode(definition, dependencySet);\n              break;\n\n            case Kind.ENUM_TYPE_DEFINITION:\n              visitEnumTypeDefinitionNode(definition, dependencySet);\n              break;\n\n            case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n              visitInputObjectTypeDefinitionNode(definition, dependencySet);\n              break;\n\n            case Kind.DIRECTIVE_DEFINITION:\n              visitDirectiveDefinitionNode(definition, dependencySet);\n              break;\n\n            case Kind.SCALAR_TYPE_DEFINITION:\n              visitScalarDefinitionNode(definition, dependencySet);\n              break;\n\n            case Kind.SCHEMA_DEFINITION:\n              visitSchemaDefinitionNode(definition, dependencySet);\n              break;\n\n            case Kind.OBJECT_TYPE_EXTENSION:\n              visitObjectTypeExtensionNode(definition, dependencySet, dependenciesByDefinitionName);\n              break;\n\n            case Kind.INTERFACE_TYPE_EXTENSION:\n              visitInterfaceTypeExtensionNode(definition, dependencySet, dependenciesByDefinitionName);\n              break;\n\n            case Kind.UNION_TYPE_EXTENSION:\n              visitUnionTypeExtensionNode(definition, dependencySet);\n              break;\n\n            case Kind.ENUM_TYPE_EXTENSION:\n              visitEnumTypeExtensionNode(definition, dependencySet);\n              break;\n\n            case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n              visitInputObjectTypeExtensionNode(definition, dependencySet);\n              break;\n\n            case Kind.SCALAR_TYPE_EXTENSION:\n              visitScalarExtensionNode(definition, dependencySet);\n              break;\n          }\n\n          if ('fields' in definition) {\n            for (const field of definition.fields) {\n              const definitionName = definition.name.value + '.' + field.name.value;\n\n              if (!definitionsByName.has(definitionName)) {\n                definitionsByName.set(definitionName, new Set());\n              }\n\n              const definitionsSet = definitionsByName.get(definitionName);\n              definitionsSet.add({ ...definition,\n                fields: [field]\n              });\n\n              if (!dependenciesByDefinitionName.has(definitionName)) {\n                dependenciesByDefinitionName.set(definitionName, new Set());\n              }\n\n              const dependencySet = dependenciesByDefinitionName.get(definitionName);\n\n              switch (field.kind) {\n                case Kind.FIELD_DEFINITION:\n                  visitFieldDefinitionNode(field, dependencySet);\n                  break;\n\n                case Kind.INPUT_VALUE_DEFINITION:\n                  visitInputValueDefinitionNode(field, dependencySet);\n                  break;\n              }\n            }\n          }\n        }\n      }\n\n      for (const [definitionName, definitions] of definitionsByName) {\n        if (!fileDefinitionMap.has(definitionName)) {\n          fileDefinitionMap.set(definitionName, new Set());\n        }\n\n        const definitionsWithDependencies = fileDefinitionMap.get(definitionName);\n\n        for (const definition of definitions) {\n          definitionsWithDependencies.add(definition);\n        }\n\n        const dependenciesOfDefinition = dependenciesByDefinitionName.get(definitionName);\n\n        for (const dependencyName of dependenciesOfDefinition) {\n          const dependencyDefinitions = definitionsByName.get(dependencyName);\n          dependencyDefinitions === null || dependencyDefinitions === void 0 ? void 0 : dependencyDefinitions.forEach(dependencyDefinition => {\n            definitionsWithDependencies.add(dependencyDefinition);\n          });\n        }\n      }\n    }\n\n    const allImportedDefinitionsMap = new Map();\n\n    for (const line of importLines) {\n      const {\n        imports,\n        from\n      } = parseImportLine(line.replace('#', '').trim());\n      const importFileDefinitionMap = visitFile(from, filePath, visitedFiles, predefinedImports);\n\n      if (imports.includes('*')) {\n        for (const [importedDefinitionName, importedDefinitions] of importFileDefinitionMap) {\n          const [importedDefinitionTypeName] = importedDefinitionName.split('.');\n\n          if (!allImportedDefinitionsMap.has(importedDefinitionTypeName)) {\n            allImportedDefinitionsMap.set(importedDefinitionTypeName, new Set());\n          }\n\n          const allImportedDefinitions = allImportedDefinitionsMap.get(importedDefinitionTypeName);\n\n          for (const importedDefinition of importedDefinitions) {\n            allImportedDefinitions.add(importedDefinition);\n          }\n        }\n      } else {\n        for (let importedDefinitionName of imports) {\n          if (importedDefinitionName.endsWith('.*')) {\n            // Adding whole type means the same thing with adding every single field\n            importedDefinitionName = importedDefinitionName.replace('.*', '');\n          }\n\n          const [importedDefinitionTypeName] = importedDefinitionName.split('.');\n\n          if (!allImportedDefinitionsMap.has(importedDefinitionTypeName)) {\n            allImportedDefinitionsMap.set(importedDefinitionTypeName, new Set());\n          }\n\n          const allImportedDefinitions = allImportedDefinitionsMap.get(importedDefinitionTypeName);\n          const importedDefinitions = importFileDefinitionMap.get(importedDefinitionName);\n\n          if (!importedDefinitions) {\n            throw new Error(`${importedDefinitionName} is not exported by ${from} imported by ${filePath}`);\n          }\n\n          for (const importedDefinition of importedDefinitions) {\n            allImportedDefinitions.add(importedDefinition);\n          }\n        }\n      }\n    }\n\n    if (!otherLines) {\n      visitedFiles.set(filePath, allImportedDefinitionsMap);\n    } else {\n      const fileDefinitionMap = visitedFiles.get(filePath);\n\n      for (const [definitionName] of definitionsByName) {\n        const addDefinition = definition => {\n          definitionsWithDependencies.add(definition); // Regenerate field exports if some fields are imported after visitor\n\n          if ('fields' in definition) {\n            for (const field of definition.fields) {\n              const fieldName = field.name.value;\n              const fieldDefinitionName = definition.name.value + '.' + fieldName;\n              const allImportedDefinitions = allImportedDefinitionsMap.get(definitionName);\n              allImportedDefinitions === null || allImportedDefinitions === void 0 ? void 0 : allImportedDefinitions.forEach(importedDefinition => {\n                if (!fileDefinitionMap.has(fieldDefinitionName)) {\n                  fileDefinitionMap.set(fieldDefinitionName, new Set());\n                }\n\n                const definitionsWithDeps = fileDefinitionMap.get(fieldDefinitionName);\n                definitionsWithDeps.add(importedDefinition);\n              });\n            }\n          }\n        };\n\n        const definitionsWithDependencies = fileDefinitionMap.get(definitionName);\n        const allImportedDefinitions = allImportedDefinitionsMap.get(definitionName);\n        allImportedDefinitions === null || allImportedDefinitions === void 0 ? void 0 : allImportedDefinitions.forEach(importedDefinition => {\n          addDefinition(importedDefinition);\n        });\n        const dependenciesOfDefinition = dependenciesByDefinitionName.get(definitionName);\n\n        for (const dependencyName of dependenciesOfDefinition) {\n          // If that dependency cannot be found both in imports and this file, throw an error\n          if (!allImportedDefinitionsMap.has(dependencyName) && !definitionsByName.has(dependencyName)) {\n            throw new Error(`Couldn't find type ${dependencyName} in any of the schemas.`);\n          }\n\n          const dependencyDefinitionsFromImports = allImportedDefinitionsMap.get(dependencyName);\n          dependencyDefinitionsFromImports === null || dependencyDefinitionsFromImports === void 0 ? void 0 : dependencyDefinitionsFromImports.forEach(dependencyDefinition => {\n            addDefinition(dependencyDefinition);\n          });\n        }\n      }\n    }\n  }\n\n  return visitedFiles.get(filePath);\n}\n\nfunction parseImportLine(importLine) {\n  if (IMPORT_FROM_REGEX.test(importLine)) {\n    // Apply regex to import line\n    // Extract matches into named variables\n    const [, wildcard, importsString,, from] = importLine.match(IMPORT_FROM_REGEX);\n\n    if (from) {\n      // Extract imported types\n      const imports = wildcard === '*' ? ['*'] : importsString.split(',').map(d => d.trim()); // Return information about the import line\n\n      return {\n        imports,\n        from\n      };\n    }\n  } else if (IMPORT_DEFAULT_REGEX.test(importLine)) {\n    const [,, from] = importLine.match(IMPORT_DEFAULT_REGEX);\n\n    if (from) {\n      return {\n        imports: ['*'],\n        from\n      };\n    }\n  }\n\n  throw new Error(`\n    Import statement is not valid:\n    > ${importLine}\n    If you want to have comments starting with '# import', please use ''' instead!\n    You can only have 'import' statements in the following pattern;\n    # import [Type].[Field] from [File]\n  `);\n}\n\nfunction resolveFilePath(filePath, importFrom) {\n  const dirName = dirname(filePath);\n\n  try {\n    const fullPath = join(dirName, importFrom);\n    return realpathSync(fullPath);\n  } catch (e) {\n    if (e.code === 'ENOENT') {\n      return resolveFrom(dirName, importFrom);\n    }\n  }\n}\n\nfunction visitOperationDefinitionNode(node, dependencySet) {\n  dependencySet.add(node.name.value);\n  node.selectionSet.selections.forEach(selectionNode => visitSelectionNode(selectionNode, dependencySet));\n}\n\nfunction visitSelectionNode(node, dependencySet) {\n  switch (node.kind) {\n    case Kind.FIELD:\n      visitFieldNode(node, dependencySet);\n      break;\n\n    case Kind.FRAGMENT_SPREAD:\n      visitFragmentSpreadNode(node, dependencySet);\n      break;\n\n    case Kind.INLINE_FRAGMENT:\n      visitInlineFragmentNode(node, dependencySet);\n      break;\n  }\n}\n\nfunction visitFieldNode(node, dependencySet) {\n  var _a;\n\n  (_a = node.selectionSet) === null || _a === void 0 ? void 0 : _a.selections.forEach(selectionNode => visitSelectionNode(selectionNode, dependencySet));\n}\n\nfunction visitFragmentSpreadNode(node, dependencySet) {\n  dependencySet.add(node.name.value);\n}\n\nfunction visitInlineFragmentNode(node, dependencySet) {\n  node.selectionSet.selections.forEach(selectionNode => visitSelectionNode(selectionNode, dependencySet));\n}\n\nfunction visitFragmentDefinitionNode(node, dependencySet) {\n  dependencySet.add(node.name.value);\n  node.selectionSet.selections.forEach(selectionNode => visitSelectionNode(selectionNode, dependencySet));\n}\n\nfunction visitObjectTypeDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n  var _a, _b, _c;\n\n  const typeName = node.name.value;\n  dependencySet.add(typeName);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(fieldDefinitionNode => visitFieldDefinitionNode(fieldDefinitionNode, dependencySet));\n  (_c = node.interfaces) === null || _c === void 0 ? void 0 : _c.forEach(namedTypeNode => {\n    visitNamedTypeNode(namedTypeNode, dependencySet);\n    const interfaceName = namedTypeNode.name.value; // interface should be dependent to the type as well\n\n    if (!dependenciesByDefinitionName.has(interfaceName)) {\n      dependenciesByDefinitionName.set(interfaceName, new Set());\n    }\n\n    dependenciesByDefinitionName.get(interfaceName).add(typeName);\n  });\n}\n\nfunction visitDirectiveNode(node, dependencySet) {\n  const directiveName = node.name.value;\n\n  if (!builtinDirectives.includes(directiveName)) {\n    dependencySet.add(node.name.value);\n  }\n}\n\nfunction visitFieldDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n  var _a, _b;\n\n  (_a = node.arguments) === null || _a === void 0 ? void 0 : _a.forEach(inputValueDefinitionNode => visitInputValueDefinitionNode(inputValueDefinitionNode, dependencySet));\n  (_b = node.directives) === null || _b === void 0 ? void 0 : _b.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  visitTypeNode(node.type, dependencySet);\n}\n\nfunction visitTypeNode(node, dependencySet, dependenciesByDefinitionName) {\n  switch (node.kind) {\n    case Kind.LIST_TYPE:\n      visitListTypeNode(node, dependencySet);\n      break;\n\n    case Kind.NON_NULL_TYPE:\n      visitNonNullTypeNode(node, dependencySet);\n      break;\n\n    case Kind.NAMED_TYPE:\n      visitNamedTypeNode(node, dependencySet);\n      break;\n  }\n}\n\nfunction visitListTypeNode(node, dependencySet, dependenciesByDefinitionName) {\n  visitTypeNode(node.type, dependencySet);\n}\n\nfunction visitNonNullTypeNode(node, dependencySet, dependenciesByDefinitionName) {\n  visitTypeNode(node.type, dependencySet);\n}\n\nfunction visitNamedTypeNode(node, dependencySet) {\n  const namedTypeName = node.name.value;\n\n  if (!builtinTypes.includes(namedTypeName)) {\n    dependencySet.add(node.name.value);\n  }\n}\n\nfunction visitInputValueDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n  var _a;\n\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  visitTypeNode(node.type, dependencySet);\n}\n\nfunction visitInterfaceTypeDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n  var _a, _b, _c;\n\n  const typeName = node.name.value;\n  dependencySet.add(typeName);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(fieldDefinitionNode => visitFieldDefinitionNode(fieldDefinitionNode, dependencySet));\n  (_c = node.interfaces) === null || _c === void 0 ? void 0 : _c.forEach(namedTypeNode => {\n    visitNamedTypeNode(namedTypeNode, dependencySet);\n    const interfaceName = namedTypeNode.name.value; // interface should be dependent to the type as well\n\n    if (!dependenciesByDefinitionName.has(interfaceName)) {\n      dependenciesByDefinitionName.set(interfaceName, new Set());\n    }\n\n    dependenciesByDefinitionName.get(interfaceName).add(typeName);\n  });\n}\n\nfunction visitUnionTypeDefinitionNode(node, dependencySet) {\n  var _a;\n\n  dependencySet.add(node.name.value);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  node.types.forEach(namedTypeNode => visitNamedTypeNode(namedTypeNode, dependencySet));\n}\n\nfunction visitEnumTypeDefinitionNode(node, dependencySet) {\n  var _a;\n\n  dependencySet.add(node.name.value);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n}\n\nfunction visitInputObjectTypeDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n  var _a, _b;\n\n  dependencySet.add(node.name.value);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(inputValueDefinitionNode => visitInputValueDefinitionNode(inputValueDefinitionNode, dependencySet));\n}\n\nfunction visitDirectiveDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n  var _a;\n\n  dependencySet.add(node.name.value);\n  (_a = node.arguments) === null || _a === void 0 ? void 0 : _a.forEach(inputValueDefinitionNode => visitInputValueDefinitionNode(inputValueDefinitionNode, dependencySet));\n}\n\nfunction visitObjectTypeExtensionNode(node, dependencySet, dependenciesByDefinitionName) {\n  var _a, _b, _c;\n\n  const typeName = node.name.value;\n  dependencySet.add(typeName);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(fieldDefinitionNode => visitFieldDefinitionNode(fieldDefinitionNode, dependencySet));\n  (_c = node.interfaces) === null || _c === void 0 ? void 0 : _c.forEach(namedTypeNode => {\n    visitNamedTypeNode(namedTypeNode, dependencySet);\n    const interfaceName = namedTypeNode.name.value; // interface should be dependent to the type as well\n\n    if (!dependenciesByDefinitionName.has(interfaceName)) {\n      dependenciesByDefinitionName.set(interfaceName, new Set());\n    }\n\n    dependenciesByDefinitionName.get(interfaceName).add(typeName);\n  });\n}\n\nfunction visitInterfaceTypeExtensionNode(node, dependencySet, dependenciesByDefinitionName) {\n  var _a, _b, _c;\n\n  const typeName = node.name.value;\n  dependencySet.add(typeName);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(fieldDefinitionNode => visitFieldDefinitionNode(fieldDefinitionNode, dependencySet));\n  (_c = node.interfaces) === null || _c === void 0 ? void 0 : _c.forEach(namedTypeNode => {\n    visitNamedTypeNode(namedTypeNode, dependencySet);\n    const interfaceName = namedTypeNode.name.value; // interface should be dependent to the type as well\n\n    if (!dependenciesByDefinitionName.has(interfaceName)) {\n      dependenciesByDefinitionName.set(interfaceName, new Set());\n    }\n\n    dependenciesByDefinitionName.get(interfaceName).add(typeName);\n  });\n}\n\nfunction visitUnionTypeExtensionNode(node, dependencySet) {\n  var _a;\n\n  dependencySet.add(node.name.value);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  node.types.forEach(namedTypeNode => visitNamedTypeNode(namedTypeNode, dependencySet));\n}\n\nfunction visitEnumTypeExtensionNode(node, dependencySet) {\n  var _a;\n\n  dependencySet.add(node.name.value);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n}\n\nfunction visitInputObjectTypeExtensionNode(node, dependencySet, dependenciesByDefinitionName) {\n  var _a, _b;\n\n  dependencySet.add(node.name.value);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(inputValueDefinitionNode => visitInputValueDefinitionNode(inputValueDefinitionNode, dependencySet));\n}\n\nfunction visitSchemaDefinitionNode(node, dependencySet) {\n  var _a;\n\n  dependencySet.add('schema');\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n  node.operationTypes.forEach(operationTypeDefinitionNode => visitOperationTypeDefinitionNode(operationTypeDefinitionNode, dependencySet));\n}\n\nfunction visitScalarDefinitionNode(node, dependencySet) {\n  var _a;\n\n  dependencySet.add(node.name.value);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n}\n\nfunction visitScalarExtensionNode(node, dependencySet) {\n  var _a;\n\n  dependencySet.add(node.name.value);\n  (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n}\n\nfunction visitOperationTypeDefinitionNode(node, dependencySet) {\n  visitNamedTypeNode(node.type, dependencySet);\n}\n\nexport { parseImportLine, processImport };","map":{"version":3,"sources":["../../../dist/import/src/index.js"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable no-unused-expressions */\nimport { Source, parse, Kind, } from 'graphql';\nimport { readFileSync, realpathSync } from 'fs-extra';\nimport { dirname, join, isAbsolute } from 'path';\nimport resolveFrom from 'resolve-from';\nconst builtinTypes = ['String', 'Float', 'Int', 'Boolean', 'ID', 'Upload'];\nconst builtinDirectives = [\n    'deprecated',\n    'skip',\n    'include',\n    'cacheControl',\n    'key',\n    'external',\n    'requires',\n    'provides',\n    'connection',\n    'client',\n];\nconst IMPORT_FROM_REGEX = /^import\\s+(\\*|(.*))\\s+from\\s+('|\")(.*)('|\");?$/;\nconst IMPORT_DEFAULT_REGEX = /^import\\s+('|\")(.*)('|\");?$/;\nexport function processImport(filePath, cwd = process.cwd(), predefinedImports = {}) {\n    const visitedFiles = new Map();\n    const set = visitFile(filePath, join(cwd + '/root.graphql'), visitedFiles, predefinedImports);\n    const definitionSet = new Set();\n    for (const defs of set.values()) {\n        for (const def of defs) {\n            definitionSet.add(def);\n        }\n    }\n    return {\n        kind: Kind.DOCUMENT,\n        definitions: [...definitionSet],\n    };\n}\nfunction visitFile(filePath, cwd, visitedFiles, predefinedImports) {\n    if (!isAbsolute(filePath) && !(filePath in predefinedImports)) {\n        filePath = resolveFilePath(cwd, filePath);\n    }\n    if (!visitedFiles.has(filePath)) {\n        const fileContent = filePath in predefinedImports ? predefinedImports[filePath] : readFileSync(filePath, 'utf8');\n        const importLines = [];\n        let otherLines = '';\n        for (const line of fileContent.split('\\n')) {\n            const trimmedLine = line.trim();\n            if (trimmedLine.startsWith('#import ') || trimmedLine.startsWith('# import ')) {\n                importLines.push(trimmedLine);\n            }\n            else if (trimmedLine) {\n                otherLines += line + '\\n';\n            }\n        }\n        const definitionsByName = new Map();\n        const dependenciesByDefinitionName = new Map();\n        if (otherLines) {\n            const fileDefinitionMap = new Map();\n            // To prevent circular dependency\n            visitedFiles.set(filePath, fileDefinitionMap);\n            const document = parse(new Source(otherLines, filePath), {\n                noLocation: true,\n            });\n            for (const definition of document.definitions) {\n                if ('name' in definition || definition.kind === Kind.SCHEMA_DEFINITION) {\n                    const definitionName = 'name' in definition ? definition.name.value : 'schema';\n                    if (!definitionsByName.has(definitionName)) {\n                        definitionsByName.set(definitionName, new Set());\n                    }\n                    const definitionsSet = definitionsByName.get(definitionName);\n                    definitionsSet.add(definition);\n                    if (!dependenciesByDefinitionName.has(definitionName)) {\n                        dependenciesByDefinitionName.set(definitionName, new Set());\n                    }\n                    const dependencySet = dependenciesByDefinitionName.get(definitionName);\n                    switch (definition.kind) {\n                        case Kind.OPERATION_DEFINITION:\n                            visitOperationDefinitionNode(definition, dependencySet);\n                            break;\n                        case Kind.FRAGMENT_DEFINITION:\n                            visitFragmentDefinitionNode(definition, dependencySet);\n                            break;\n                        case Kind.OBJECT_TYPE_DEFINITION:\n                            visitObjectTypeDefinitionNode(definition, dependencySet, dependenciesByDefinitionName);\n                            break;\n                        case Kind.INTERFACE_TYPE_DEFINITION:\n                            visitInterfaceTypeDefinitionNode(definition, dependencySet, dependenciesByDefinitionName);\n                            break;\n                        case Kind.UNION_TYPE_DEFINITION:\n                            visitUnionTypeDefinitionNode(definition, dependencySet);\n                            break;\n                        case Kind.ENUM_TYPE_DEFINITION:\n                            visitEnumTypeDefinitionNode(definition, dependencySet);\n                            break;\n                        case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n                            visitInputObjectTypeDefinitionNode(definition, dependencySet, dependenciesByDefinitionName);\n                            break;\n                        case Kind.DIRECTIVE_DEFINITION:\n                            visitDirectiveDefinitionNode(definition, dependencySet, dependenciesByDefinitionName);\n                            break;\n                        case Kind.SCALAR_TYPE_DEFINITION:\n                            visitScalarDefinitionNode(definition, dependencySet);\n                            break;\n                        case Kind.SCHEMA_DEFINITION:\n                            visitSchemaDefinitionNode(definition, dependencySet);\n                            break;\n                        case Kind.OBJECT_TYPE_EXTENSION:\n                            visitObjectTypeExtensionNode(definition, dependencySet, dependenciesByDefinitionName);\n                            break;\n                        case Kind.INTERFACE_TYPE_EXTENSION:\n                            visitInterfaceTypeExtensionNode(definition, dependencySet, dependenciesByDefinitionName);\n                            break;\n                        case Kind.UNION_TYPE_EXTENSION:\n                            visitUnionTypeExtensionNode(definition, dependencySet);\n                            break;\n                        case Kind.ENUM_TYPE_EXTENSION:\n                            visitEnumTypeExtensionNode(definition, dependencySet);\n                            break;\n                        case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n                            visitInputObjectTypeExtensionNode(definition, dependencySet, dependenciesByDefinitionName);\n                            break;\n                        case Kind.SCALAR_TYPE_EXTENSION:\n                            visitScalarExtensionNode(definition, dependencySet);\n                            break;\n                    }\n                    if ('fields' in definition) {\n                        for (const field of definition.fields) {\n                            const definitionName = definition.name.value + '.' + field.name.value;\n                            if (!definitionsByName.has(definitionName)) {\n                                definitionsByName.set(definitionName, new Set());\n                            }\n                            const definitionsSet = definitionsByName.get(definitionName);\n                            definitionsSet.add({\n                                ...definition,\n                                fields: [field],\n                            });\n                            if (!dependenciesByDefinitionName.has(definitionName)) {\n                                dependenciesByDefinitionName.set(definitionName, new Set());\n                            }\n                            const dependencySet = dependenciesByDefinitionName.get(definitionName);\n                            switch (field.kind) {\n                                case Kind.FIELD_DEFINITION:\n                                    visitFieldDefinitionNode(field, dependencySet, dependenciesByDefinitionName);\n                                    break;\n                                case Kind.INPUT_VALUE_DEFINITION:\n                                    visitInputValueDefinitionNode(field, dependencySet, dependenciesByDefinitionName);\n                                    break;\n                            }\n                        }\n                    }\n                }\n            }\n            for (const [definitionName, definitions] of definitionsByName) {\n                if (!fileDefinitionMap.has(definitionName)) {\n                    fileDefinitionMap.set(definitionName, new Set());\n                }\n                const definitionsWithDependencies = fileDefinitionMap.get(definitionName);\n                for (const definition of definitions) {\n                    definitionsWithDependencies.add(definition);\n                }\n                const dependenciesOfDefinition = dependenciesByDefinitionName.get(definitionName);\n                for (const dependencyName of dependenciesOfDefinition) {\n                    const dependencyDefinitions = definitionsByName.get(dependencyName);\n                    dependencyDefinitions === null || dependencyDefinitions === void 0 ? void 0 : dependencyDefinitions.forEach(dependencyDefinition => {\n                        definitionsWithDependencies.add(dependencyDefinition);\n                    });\n                }\n            }\n        }\n        const allImportedDefinitionsMap = new Map();\n        for (const line of importLines) {\n            const { imports, from } = parseImportLine(line.replace('#', '').trim());\n            const importFileDefinitionMap = visitFile(from, filePath, visitedFiles, predefinedImports);\n            if (imports.includes('*')) {\n                for (const [importedDefinitionName, importedDefinitions] of importFileDefinitionMap) {\n                    const [importedDefinitionTypeName] = importedDefinitionName.split('.');\n                    if (!allImportedDefinitionsMap.has(importedDefinitionTypeName)) {\n                        allImportedDefinitionsMap.set(importedDefinitionTypeName, new Set());\n                    }\n                    const allImportedDefinitions = allImportedDefinitionsMap.get(importedDefinitionTypeName);\n                    for (const importedDefinition of importedDefinitions) {\n                        allImportedDefinitions.add(importedDefinition);\n                    }\n                }\n            }\n            else {\n                for (let importedDefinitionName of imports) {\n                    if (importedDefinitionName.endsWith('.*')) {\n                        // Adding whole type means the same thing with adding every single field\n                        importedDefinitionName = importedDefinitionName.replace('.*', '');\n                    }\n                    const [importedDefinitionTypeName] = importedDefinitionName.split('.');\n                    if (!allImportedDefinitionsMap.has(importedDefinitionTypeName)) {\n                        allImportedDefinitionsMap.set(importedDefinitionTypeName, new Set());\n                    }\n                    const allImportedDefinitions = allImportedDefinitionsMap.get(importedDefinitionTypeName);\n                    const importedDefinitions = importFileDefinitionMap.get(importedDefinitionName);\n                    if (!importedDefinitions) {\n                        throw new Error(`${importedDefinitionName} is not exported by ${from} imported by ${filePath}`);\n                    }\n                    for (const importedDefinition of importedDefinitions) {\n                        allImportedDefinitions.add(importedDefinition);\n                    }\n                }\n            }\n        }\n        if (!otherLines) {\n            visitedFiles.set(filePath, allImportedDefinitionsMap);\n        }\n        else {\n            const fileDefinitionMap = visitedFiles.get(filePath);\n            for (const [definitionName] of definitionsByName) {\n                const addDefinition = (definition) => {\n                    definitionsWithDependencies.add(definition);\n                    // Regenerate field exports if some fields are imported after visitor\n                    if ('fields' in definition) {\n                        for (const field of definition.fields) {\n                            const fieldName = field.name.value;\n                            const fieldDefinitionName = definition.name.value + '.' + fieldName;\n                            const allImportedDefinitions = allImportedDefinitionsMap.get(definitionName);\n                            allImportedDefinitions === null || allImportedDefinitions === void 0 ? void 0 : allImportedDefinitions.forEach(importedDefinition => {\n                                if (!fileDefinitionMap.has(fieldDefinitionName)) {\n                                    fileDefinitionMap.set(fieldDefinitionName, new Set());\n                                }\n                                const definitionsWithDeps = fileDefinitionMap.get(fieldDefinitionName);\n                                definitionsWithDeps.add(importedDefinition);\n                            });\n                        }\n                    }\n                };\n                const definitionsWithDependencies = fileDefinitionMap.get(definitionName);\n                const allImportedDefinitions = allImportedDefinitionsMap.get(definitionName);\n                allImportedDefinitions === null || allImportedDefinitions === void 0 ? void 0 : allImportedDefinitions.forEach(importedDefinition => {\n                    addDefinition(importedDefinition);\n                });\n                const dependenciesOfDefinition = dependenciesByDefinitionName.get(definitionName);\n                for (const dependencyName of dependenciesOfDefinition) {\n                    // If that dependency cannot be found both in imports and this file, throw an error\n                    if (!allImportedDefinitionsMap.has(dependencyName) && !definitionsByName.has(dependencyName)) {\n                        throw new Error(`Couldn't find type ${dependencyName} in any of the schemas.`);\n                    }\n                    const dependencyDefinitionsFromImports = allImportedDefinitionsMap.get(dependencyName);\n                    dependencyDefinitionsFromImports === null || dependencyDefinitionsFromImports === void 0 ? void 0 : dependencyDefinitionsFromImports.forEach(dependencyDefinition => {\n                        addDefinition(dependencyDefinition);\n                    });\n                }\n            }\n        }\n    }\n    return visitedFiles.get(filePath);\n}\nexport function parseImportLine(importLine) {\n    if (IMPORT_FROM_REGEX.test(importLine)) {\n        // Apply regex to import line\n        // Extract matches into named variables\n        const [, wildcard, importsString, , from] = importLine.match(IMPORT_FROM_REGEX);\n        if (from) {\n            // Extract imported types\n            const imports = wildcard === '*' ? ['*'] : importsString.split(',').map(d => d.trim());\n            // Return information about the import line\n            return { imports, from };\n        }\n    }\n    else if (IMPORT_DEFAULT_REGEX.test(importLine)) {\n        const [, , from] = importLine.match(IMPORT_DEFAULT_REGEX);\n        if (from) {\n            return { imports: ['*'], from };\n        }\n    }\n    throw new Error(`\n    Import statement is not valid:\n    > ${importLine}\n    If you want to have comments starting with '# import', please use ''' instead!\n    You can only have 'import' statements in the following pattern;\n    # import [Type].[Field] from [File]\n  `);\n}\nfunction resolveFilePath(filePath, importFrom) {\n    const dirName = dirname(filePath);\n    try {\n        const fullPath = join(dirName, importFrom);\n        return realpathSync(fullPath);\n    }\n    catch (e) {\n        if (e.code === 'ENOENT') {\n            return resolveFrom(dirName, importFrom);\n        }\n    }\n}\nfunction visitOperationDefinitionNode(node, dependencySet) {\n    dependencySet.add(node.name.value);\n    node.selectionSet.selections.forEach(selectionNode => visitSelectionNode(selectionNode, dependencySet));\n}\nfunction visitSelectionNode(node, dependencySet) {\n    switch (node.kind) {\n        case Kind.FIELD:\n            visitFieldNode(node, dependencySet);\n            break;\n        case Kind.FRAGMENT_SPREAD:\n            visitFragmentSpreadNode(node, dependencySet);\n            break;\n        case Kind.INLINE_FRAGMENT:\n            visitInlineFragmentNode(node, dependencySet);\n            break;\n    }\n}\nfunction visitFieldNode(node, dependencySet) {\n    var _a;\n    (_a = node.selectionSet) === null || _a === void 0 ? void 0 : _a.selections.forEach(selectionNode => visitSelectionNode(selectionNode, dependencySet));\n}\nfunction visitFragmentSpreadNode(node, dependencySet) {\n    dependencySet.add(node.name.value);\n}\nfunction visitInlineFragmentNode(node, dependencySet) {\n    node.selectionSet.selections.forEach(selectionNode => visitSelectionNode(selectionNode, dependencySet));\n}\nfunction visitFragmentDefinitionNode(node, dependencySet) {\n    dependencySet.add(node.name.value);\n    node.selectionSet.selections.forEach(selectionNode => visitSelectionNode(selectionNode, dependencySet));\n}\nfunction visitObjectTypeDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n    var _a, _b, _c;\n    const typeName = node.name.value;\n    dependencySet.add(typeName);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(fieldDefinitionNode => visitFieldDefinitionNode(fieldDefinitionNode, dependencySet, dependenciesByDefinitionName));\n    (_c = node.interfaces) === null || _c === void 0 ? void 0 : _c.forEach(namedTypeNode => {\n        visitNamedTypeNode(namedTypeNode, dependencySet);\n        const interfaceName = namedTypeNode.name.value;\n        // interface should be dependent to the type as well\n        if (!dependenciesByDefinitionName.has(interfaceName)) {\n            dependenciesByDefinitionName.set(interfaceName, new Set());\n        }\n        dependenciesByDefinitionName.get(interfaceName).add(typeName);\n    });\n}\nfunction visitDirectiveNode(node, dependencySet) {\n    const directiveName = node.name.value;\n    if (!builtinDirectives.includes(directiveName)) {\n        dependencySet.add(node.name.value);\n    }\n}\nfunction visitFieldDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n    var _a, _b;\n    (_a = node.arguments) === null || _a === void 0 ? void 0 : _a.forEach(inputValueDefinitionNode => visitInputValueDefinitionNode(inputValueDefinitionNode, dependencySet, dependenciesByDefinitionName));\n    (_b = node.directives) === null || _b === void 0 ? void 0 : _b.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    visitTypeNode(node.type, dependencySet, dependenciesByDefinitionName);\n}\nfunction visitTypeNode(node, dependencySet, dependenciesByDefinitionName) {\n    switch (node.kind) {\n        case Kind.LIST_TYPE:\n            visitListTypeNode(node, dependencySet, dependenciesByDefinitionName);\n            break;\n        case Kind.NON_NULL_TYPE:\n            visitNonNullTypeNode(node, dependencySet, dependenciesByDefinitionName);\n            break;\n        case Kind.NAMED_TYPE:\n            visitNamedTypeNode(node, dependencySet);\n            break;\n    }\n}\nfunction visitListTypeNode(node, dependencySet, dependenciesByDefinitionName) {\n    visitTypeNode(node.type, dependencySet, dependenciesByDefinitionName);\n}\nfunction visitNonNullTypeNode(node, dependencySet, dependenciesByDefinitionName) {\n    visitTypeNode(node.type, dependencySet, dependenciesByDefinitionName);\n}\nfunction visitNamedTypeNode(node, dependencySet) {\n    const namedTypeName = node.name.value;\n    if (!builtinTypes.includes(namedTypeName)) {\n        dependencySet.add(node.name.value);\n    }\n}\nfunction visitInputValueDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n    var _a;\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    visitTypeNode(node.type, dependencySet, dependenciesByDefinitionName);\n}\nfunction visitInterfaceTypeDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n    var _a, _b, _c;\n    const typeName = node.name.value;\n    dependencySet.add(typeName);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(fieldDefinitionNode => visitFieldDefinitionNode(fieldDefinitionNode, dependencySet, dependenciesByDefinitionName));\n    (_c = node.interfaces) === null || _c === void 0 ? void 0 : _c.forEach((namedTypeNode) => {\n        visitNamedTypeNode(namedTypeNode, dependencySet);\n        const interfaceName = namedTypeNode.name.value;\n        // interface should be dependent to the type as well\n        if (!dependenciesByDefinitionName.has(interfaceName)) {\n            dependenciesByDefinitionName.set(interfaceName, new Set());\n        }\n        dependenciesByDefinitionName.get(interfaceName).add(typeName);\n    });\n}\nfunction visitUnionTypeDefinitionNode(node, dependencySet) {\n    var _a;\n    dependencySet.add(node.name.value);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    node.types.forEach(namedTypeNode => visitNamedTypeNode(namedTypeNode, dependencySet));\n}\nfunction visitEnumTypeDefinitionNode(node, dependencySet) {\n    var _a;\n    dependencySet.add(node.name.value);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n}\nfunction visitInputObjectTypeDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n    var _a, _b;\n    dependencySet.add(node.name.value);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(inputValueDefinitionNode => visitInputValueDefinitionNode(inputValueDefinitionNode, dependencySet, dependenciesByDefinitionName));\n}\nfunction visitDirectiveDefinitionNode(node, dependencySet, dependenciesByDefinitionName) {\n    var _a;\n    dependencySet.add(node.name.value);\n    (_a = node.arguments) === null || _a === void 0 ? void 0 : _a.forEach(inputValueDefinitionNode => visitInputValueDefinitionNode(inputValueDefinitionNode, dependencySet, dependenciesByDefinitionName));\n}\nfunction visitObjectTypeExtensionNode(node, dependencySet, dependenciesByDefinitionName) {\n    var _a, _b, _c;\n    const typeName = node.name.value;\n    dependencySet.add(typeName);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(fieldDefinitionNode => visitFieldDefinitionNode(fieldDefinitionNode, dependencySet, dependenciesByDefinitionName));\n    (_c = node.interfaces) === null || _c === void 0 ? void 0 : _c.forEach(namedTypeNode => {\n        visitNamedTypeNode(namedTypeNode, dependencySet);\n        const interfaceName = namedTypeNode.name.value;\n        // interface should be dependent to the type as well\n        if (!dependenciesByDefinitionName.has(interfaceName)) {\n            dependenciesByDefinitionName.set(interfaceName, new Set());\n        }\n        dependenciesByDefinitionName.get(interfaceName).add(typeName);\n    });\n}\nfunction visitInterfaceTypeExtensionNode(node, dependencySet, dependenciesByDefinitionName) {\n    var _a, _b, _c;\n    const typeName = node.name.value;\n    dependencySet.add(typeName);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(fieldDefinitionNode => visitFieldDefinitionNode(fieldDefinitionNode, dependencySet, dependenciesByDefinitionName));\n    (_c = node.interfaces) === null || _c === void 0 ? void 0 : _c.forEach((namedTypeNode) => {\n        visitNamedTypeNode(namedTypeNode, dependencySet);\n        const interfaceName = namedTypeNode.name.value;\n        // interface should be dependent to the type as well\n        if (!dependenciesByDefinitionName.has(interfaceName)) {\n            dependenciesByDefinitionName.set(interfaceName, new Set());\n        }\n        dependenciesByDefinitionName.get(interfaceName).add(typeName);\n    });\n}\nfunction visitUnionTypeExtensionNode(node, dependencySet) {\n    var _a;\n    dependencySet.add(node.name.value);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    node.types.forEach(namedTypeNode => visitNamedTypeNode(namedTypeNode, dependencySet));\n}\nfunction visitEnumTypeExtensionNode(node, dependencySet) {\n    var _a;\n    dependencySet.add(node.name.value);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n}\nfunction visitInputObjectTypeExtensionNode(node, dependencySet, dependenciesByDefinitionName) {\n    var _a, _b;\n    dependencySet.add(node.name.value);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    (_b = node.fields) === null || _b === void 0 ? void 0 : _b.forEach(inputValueDefinitionNode => visitInputValueDefinitionNode(inputValueDefinitionNode, dependencySet, dependenciesByDefinitionName));\n}\nfunction visitSchemaDefinitionNode(node, dependencySet) {\n    var _a;\n    dependencySet.add('schema');\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n    node.operationTypes.forEach(operationTypeDefinitionNode => visitOperationTypeDefinitionNode(operationTypeDefinitionNode, dependencySet));\n}\nfunction visitScalarDefinitionNode(node, dependencySet) {\n    var _a;\n    dependencySet.add(node.name.value);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n}\nfunction visitScalarExtensionNode(node, dependencySet) {\n    var _a;\n    dependencySet.add(node.name.value);\n    (_a = node.directives) === null || _a === void 0 ? void 0 : _a.forEach(directiveNode => visitDirectiveNode(directiveNode, dependencySet));\n}\nfunction visitOperationTypeDefinitionNode(node, dependencySet) {\n    visitNamedTypeNode(node.type, dependencySet);\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}